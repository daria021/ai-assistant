[
  {
    "path": "__init__.py",
    "content": ""
  },
  {
    "path": "login_script.py",
    "content": "import asyncio\n\nfrom telethon import TelegramClient\nfrom telethon.errors import SessionPasswordNeededError\nfrom telethon.sessions import StringSession\n\n# Replace these with your own values\napi_id = 27878010  # e.g. 123456\napi_hash = 'a8c3c7628be9f25001bd387bd713f6f8'\nphone = '+79776721730'  # your phone number in international format\n\n# Session file will be created as 'user.session'\nsession_name = 'service'\nproxy = ('socks5', '91.236.79.114', '80', True, 'silent', 'bob',  )\n\n\nasync def main():\n    client = TelegramClient(session_name, api_id, api_hash, proxy=proxy)\n    await client.connect()\n    h = await client.send_code_request(phone)\n    h = h.phone_code_hash\n    code = input('Enter the code: ')\n    try:\n        await client.sign_in(phone, code, phone_code_hash=h)\n    except SessionPasswordNeededError:\n        await client.sign_in(password='gRizzli1980')\n\n    string = StringSession.save(client.session)\n    with open(f'{session_name}.txt', 'w') as f:\n        print(string, file=f)\n\n    await client.disconnect()\n\n    # async with TelegramClient(session_name, api_id, api_hash) as client:\n    #     h = await client.send_code_request(phone)\n    #     h = h.phone_code_hash\n    #     code = input('Enter the code: ')\n    #     await client.sign_in(phone, code, phone_code_hash=h, password='1106')\n    #     # chat_id = await client.get_entity('https://t.me/+1wnlX4i4t55jMzQy')\n    #     # print(chat_id.id)\n    #     string = StringSession.save(client.session)\n    #     with open(f'{session_name}.txt', 'w') as f:\n    #         print(string, file=f)\n\n\nif __name__ == '__main__':\n    # Run the async main\n    asyncio.run(main())\n"
  },
  {
    "path": "scrape.py",
    "content": "#!/usr/bin/env python3\n\"\"\"\nScript to collect all .py files in a project, excluding specified files and directories,\nand write their names and contents to an output file in JSON format.\n\"\"\"\n\nimport os\nimport fnmatch\nimport json\nimport argparse\n\n\ndef parse_args():\n    parser = argparse.ArgumentParser(\n        description=\"Collect .py files from a project, excluding specified patterns.\"\n    )\n    parser.add_argument(\n        \"root_dir\",\n        nargs=\"?\",\n        default=\".\",\n        help=\"Root directory of the project (default: current directory).\"\n    )\n    parser.add_argument(\n        \"-o\", \"--output\",\n        default=\"collected_py_files.json\",\n        help=\"Output file to write the collected data (default: collected_py_files.json).\"\n    )\n    parser.add_argument(\n        \"--exclude-files\",\n        nargs=\"*\",\n        default=[\"*.lock\", \"*~\"],\n        help=\"File patterns to exclude (default: ['*.lock', '*~']).\"\n    )\n    parser.add_argument(\n        \"--exclude-dirs\",\n        nargs=\"*\",\n        default=[\"__pycache__\", \".git\", \"node_modules\", \".venv\", \"migrations\"],\n        help=\"Directory names to exclude (default: ['__pycache__', '.git', 'node_modules']).\"\n    )\n    return parser.parse_args()\n\n\ndef should_exclude(name, patterns):\n    \"\"\"Check if a filename or directory matches any of the exclusion patterns.\"\"\"\n    return any(fnmatch.fnmatch(name, pat) for pat in patterns)\n\n\ndef collect_py_files(root_dir, exclude_files, exclude_dirs):\n    collected = []\n    for dirpath, dirnames, filenames in os.walk(root_dir):\n        # Exclude specified directories in-place to avoid descending into them\n        dirnames[:] = [d for d in dirnames if not should_exclude(d, exclude_dirs)]\n        for filename in filenames:\n            # Only .py files\n            if not filename.endswith(\".py\"):\n                continue\n            # Skip excluded file patterns\n            if should_exclude(filename, exclude_files):\n                continue\n            full_path = os.path.join(dirpath, filename)\n            try:\n                with open(full_path, \"r\", encoding=\"utf-8\") as f:\n                    content = f.read()\n            except Exception as e:\n                print(f\"Warning: Could not read {full_path}: {e}\")\n                continue\n            rel_path = os.path.relpath(full_path, root_dir)\n            collected.append({\n                \"path\": rel_path,\n                \"content\": content\n            })\n    return collected\n\n\ndef main():\n    args = parse_args()\n    data = collect_py_files(args.root_dir, args.exclude_files, args.exclude_dirs)\n    with open(args.output, \"w\", encoding=\"utf-8\") as out_f:\n        json.dump(data, out_f, ensure_ascii=False, indent=2)\n    print(f\"Collected {len(data)} .py files and wrote to {args.output}\")\n\n\nif __name__ == \"__main__\":\n    main()\n"
  },
  {
    "path": "worker-manager/__init__.py",
    "content": ""
  },
  {
    "path": "worker-manager/main.py",
    "content": "import asyncio\nimport logging\n\nfrom shared.infrastructure.main_db import init_db\n\nfrom settings import settings\nfrom dependencies.services.consumer import get_consumer\nfrom dependencies.services.container_manager import get_container_manager\n\nlogger = logging.getLogger(__name__)\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n)\n\n\nasync def main():\n    logger.info(\"Initializing service...\")\n\n    init_db(settings.db.url)\n    consumer = get_consumer()\n\n    container_manager = get_container_manager()\n\n    logger.info(\"Service initialized, starting...\")\n\n    try:\n        await asyncio.gather(consumer.execute(), container_manager.start_watching())\n    except KeyboardInterrupt:\n        logger.info(\"Shutting down...\")\n    except Exception as e:\n        logger.error(\"Unexpected exception\", exc_info=True)\n    finally:\n        logger.info(\"Service has been successfully shut down\")\n\n\nif __name__ == '__main__':\n    asyncio.run(main())\n"
  },
  {
    "path": "worker-manager/scrape.py",
    "content": "#!/usr/bin/env python3\n\"\"\"\nScript to collect all .py files in a project, excluding specified files and directories,\nand write their names and contents to an output file in JSON format.\n\"\"\"\n\nimport os\nimport fnmatch\nimport json\nimport argparse\n\n\ndef parse_args():\n    parser = argparse.ArgumentParser(\n        description=\"Collect .py files from a project, excluding specified patterns.\"\n    )\n    parser.add_argument(\n        \"root_dir\",\n        nargs=\"?\",\n        default=\".\",\n        help=\"Root directory of the project (default: current directory).\"\n    )\n    parser.add_argument(\n        \"-o\", \"--output\",\n        default=\"collected_py_files.json\",\n        help=\"Output file to write the collected data (default: collected_py_files.json).\"\n    )\n    parser.add_argument(\n        \"--exclude-files\",\n        nargs=\"*\",\n        default=[\"*.lock\", \"*~\"],\n        help=\"File patterns to exclude (default: ['*.lock', '*~']).\"\n    )\n    parser.add_argument(\n        \"--exclude-dirs\",\n        nargs=\"*\",\n        default=[\"__pycache__\", \".git\", \"node_modules\", \".venv\", \"migrations\"],\n        help=\"Directory names to exclude (default: ['__pycache__', '.git', 'node_modules']).\"\n    )\n    return parser.parse_args()\n\n\ndef should_exclude(name, patterns):\n    \"\"\"Check if a filename or directory matches any of the exclusion patterns.\"\"\"\n    return any(fnmatch.fnmatch(name, pat) for pat in patterns)\n\n\ndef collect_py_files(root_dir, exclude_files, exclude_dirs):\n    collected = []\n    for dirpath, dirnames, filenames in os.walk(root_dir):\n        # Exclude specified directories in-place to avoid descending into them\n        dirnames[:] = [d for d in dirnames if not should_exclude(d, exclude_dirs)]\n        for filename in filenames:\n            # Only .py files\n            if not filename.endswith(\".py\"):\n                continue\n            # Skip excluded file patterns\n            if should_exclude(filename, exclude_files):\n                continue\n            full_path = os.path.join(dirpath, filename)\n            try:\n                with open(full_path, \"r\", encoding=\"utf-8\") as f:\n                    content = f.read()\n            except Exception as e:\n                print(f\"Warning: Could not read {full_path}: {e}\")\n                continue\n            rel_path = os.path.relpath(full_path, root_dir)\n            collected.append({\n                \"path\": rel_path,\n                \"content\": content\n            })\n    return collected\n\n\ndef main():\n    args = parse_args()\n    data = collect_py_files(args.root_dir, args.exclude_files, args.exclude_dirs)\n    with open(args.output, \"w\", encoding=\"utf-8\") as out_f:\n        json.dump(data, out_f, ensure_ascii=False, indent=2)\n    print(f\"Collected {len(data)} .py files and wrote to {args.output}\")\n\n\nif __name__ == \"__main__\":\n    main()\n"
  },
  {
    "path": "worker-manager/settings/worker.py",
    "content": "from shared.settings import AbstractSettings\n\n\nclass CommonWorkerSettings(AbstractSettings):\n    api_id: int\n    api_hash: str\n"
  },
  {
    "path": "worker-manager/settings/__init__.py",
    "content": "from pathlib import Path\n\nfrom pydantic import Field\nfrom pydantic_settings import (\n    SettingsConfigDict,\n)\nfrom shared.infrastructure.main_db import MainDBSettings\nfrom shared.services.upload.settings import UploadSettings\nfrom shared.services.watcher_client import WatcherSettings\nfrom shared.settings import AbstractSettings, DockerSettings, BotSettings\n\nfrom .posting_bot import PostingBotSettings\nfrom .worker import CommonWorkerSettings\n\n\nclass Settings(AbstractSettings):\n    db: MainDBSettings = Field(default_factory=MainDBSettings)\n    upload: UploadSettings = Field(default_factory=UploadSettings)\n    watcher: WatcherSettings = Field(default_factory=WatcherSettings)\n    docker: DockerSettings\n    worker: CommonWorkerSettings\n    posting_bot: PostingBotSettings\n\n    model_config = SettingsConfigDict(\n        extra=\"ignore\",\n        json_file=Path(__file__).parent.parent / \"settings.json\",\n        json_file_encoding=\"utf-8\",\n    )\n\n\nsettings = Settings()\n"
  },
  {
    "path": "worker-manager/settings/posting_bot.py",
    "content": "from pydantic import SecretStr, Field\nfrom shared.settings import BotSettings\n\n\nclass PostingBotSettings(BotSettings):\n    token: SecretStr = Field(..., alias=\"POSTING_BOT_TOKEN\")\n    username: str = Field(..., alias=\"POSTING_BOT_USERNAME\")\n"
  },
  {
    "path": "worker-manager/dependencies/__init__.py",
    "content": ""
  },
  {
    "path": "worker-manager/dependencies/services/bot_service.py",
    "content": "from abstractions.services.bot_service import BotServiceInterface\nfrom services.bot_service import AiogramBotService\n\ndef get_bot_service() -> BotServiceInterface:\n    return AiogramBotService()\n"
  },
  {
    "path": "worker-manager/dependencies/services/__init__.py",
    "content": ""
  },
  {
    "path": "worker-manager/dependencies/services/watcher_client.py",
    "content": "from shared.abstractions.services.watcher_client import WatcherClientInterface\nfrom shared.dependencies.services.watcher_client import get_watcher_client_from_url\n\nfrom settings import settings\n\n\ndef get_watcher_client() -> WatcherClientInterface:\n    return get_watcher_client_from_url(settings.watcher.url)\n"
  },
  {
    "path": "worker-manager/dependencies/services/account_manager.py",
    "content": "from pathlib import Path\n\nfrom shared.dependencies.repositories import get_user_repository\nfrom shared.dependencies.repositories.worker_message import get_worker_message_repository\n\nfrom abstractions.services.manager import AccountManagerInterface\nfrom dependencies.services.bot_service import get_bot_service\nfrom dependencies.services.container_manager import get_container_manager\nfrom dependencies.services.watcher_client import get_watcher_client\nfrom services.account_manager import AccountManager\nfrom settings import settings\n\n\ndef get_account_manager() -> AccountManagerInterface:\n    return AccountManager(\n        container_manager=get_container_manager(),\n        worker_message_repository=get_worker_message_repository(),\n        user_repository=get_user_repository(),\n        watcher_client=get_watcher_client(),\n\n        app_root_config_path=Path(settings.docker.app_root_config_path),\n        api_id=settings.worker.api_id,\n        api_hash=settings.worker.api_hash,\n        bot_service=get_bot_service()\n    )\n"
  },
  {
    "path": "worker-manager/dependencies/services/consumer.py",
    "content": "from abstractions.services.sending_consumer import SendingConsumerInterface\nfrom dependencies.services.account_manager import get_account_manager\nfrom dependencies.services.sending_request import get_sending_request_service\nfrom services.sending_consumer import SendingConsumer\n\n\ndef get_consumer() -> SendingConsumerInterface:\n    return SendingConsumer(\n        account_manager=get_account_manager(),\n        sending_request_service=get_sending_request_service(),\n    )\n"
  },
  {
    "path": "worker-manager/dependencies/services/sending_request.py",
    "content": "from shared.dependencies.repositories import get_post_request_repository\n\nfrom abstractions.services.sending_request import SendingRequestServiceInterface\nfrom services.sending_request import SendingRequestService\n\n\ndef get_sending_request_service() -> SendingRequestServiceInterface:\n    return SendingRequestService(\n        post_request_repository=get_post_request_repository(),\n    )\n"
  },
  {
    "path": "worker-manager/dependencies/services/container_manager.py",
    "content": "from pathlib import Path\n\nfrom abstractions.services.container_manager import ContainerManagerInterface\nfrom infrastructure.docker import AsyncDockerAPIRepository\nfrom settings import settings\n\n\ndef get_container_manager() -> ContainerManagerInterface:\n    return AsyncDockerAPIRepository(\n        host_root_config_path=Path(settings.docker.host_root_config_path),\n        host_upload_dir=Path(settings.upload.host_upload_dir),\n        app_upload_dir=Path(settings.upload.app_upload_dir),\n\n        network_name=settings.docker.workers_network_name,\n        worker_image=settings.docker.worker_image,\n    )\n"
  },
  {
    "path": "worker-manager/abstractions/__init__.py",
    "content": ""
  },
  {
    "path": "worker-manager/abstractions/services/bot_service.py",
    "content": "from abc import ABC, abstractmethod\n\nclass BotServiceInterface(ABC):\n    @abstractmethod\n    async def send_post(\n        self,\n        chat_id: int,\n        text: str,\n        entities: list = None,\n        media_path: str = None,\n    ) -> None:\n        ...\n"
  },
  {
    "path": "worker-manager/abstractions/services/__init__.py",
    "content": ""
  },
  {
    "path": "worker-manager/abstractions/services/sending_consumer.py",
    "content": "from abc import ABC\n\nfrom shared.abstractions.services.consumer import ConsumerInterface\n\nfrom abstractions.services.manager import AccountManagerInterface\n\n\nclass SendingConsumerInterface(\n    ConsumerInterface[AccountManagerInterface],\n    ABC,\n):\n    ...\n"
  },
  {
    "path": "worker-manager/abstractions/services/sending_request.py",
    "content": "from abc import ABC, abstractmethod\nfrom typing import Optional\n\nfrom shared.domain.models import SendingRequest\n\n\nclass SendingRequestServiceInterface(ABC):\n    @abstractmethod\n    async def get_queued_message(self) -> Optional[SendingRequest]:\n        ...\n\n    @abstractmethod\n    async def set_in_progress(self, request: SendingRequest) -> None:\n        ...\n\n    @abstractmethod\n    async def set_failed(self, request: SendingRequest) -> None:\n        ..."
  },
  {
    "path": "worker-manager/abstractions/services/manager.py",
    "content": "from abc import ABC, abstractmethod\n\nfrom shared.domain.models import SendingRequest\n\nclass AccountManagerInterface(ABC):\n    @abstractmethod\n    async def send(self, request: SendingRequest):\n        ...\n"
  },
  {
    "path": "worker-manager/abstractions/services/container_manager.py",
    "content": "from abc import ABC, abstractmethod\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom uuid import UUID\n\nfrom shared.domain.models import UserWithSessionString\n\n\n@dataclass\nclass WorkerContainer:\n    id: UUID\n    config_path: Path\n    restarts: int = 0\n    container_id: str = None\n\n\nclass ContainerManagerInterface(ABC):\n    @abstractmethod\n    async def get_container(self, worker_id: UUID) -> WorkerContainer:\n        pass\n\n    @abstractmethod\n    async def start_container(self, worker_id: UUID, config_path: Path) -> None:\n        pass\n\n    @abstractmethod\n    async def stop_container(self, worker_id: UUID) -> None:\n        pass\n\n    @abstractmethod\n    async def get_running_containers(self) -> list[WorkerContainer]:\n        pass\n\n    @abstractmethod\n    async def check_health(self, worker_id: UUID) -> bool:\n        pass\n\n    @abstractmethod\n    async def repair_container(self, worker_id: UUID) -> bool:\n        pass\n\n    @abstractmethod\n    async def check_for_active_worker(self, user_id: UUID) -> bool:\n        ...\n\n    @abstractmethod\n    async def start_watching(self) -> None:\n        ...\n"
  },
  {
    "path": "worker-manager/infrastructure/bot_db.py",
    "content": ""
  },
  {
    "path": "worker-manager/infrastructure/__init__.py",
    "content": ""
  },
  {
    "path": "worker-manager/infrastructure/docker/__init__.py",
    "content": "from asyncio import sleep\nfrom dataclasses import dataclass, field\nfrom logging import getLogger\nfrom pathlib import Path\nfrom typing import Any\nfrom uuid import UUID\n\nfrom aiodocker import Docker\nfrom dotenv import dotenv_values\nfrom shared.abstractions.singleton import Singleton\n\nfrom abstractions.services.container_manager import ContainerManagerInterface, WorkerContainer\n\nlogger = getLogger(__name__)\n\n\n@dataclass\nclass AsyncDockerAPIRepository(\n    ContainerManagerInterface,\n    Singleton,\n):\n    host_root_config_path: Path\n    host_upload_dir: Path\n    app_upload_dir: Path\n\n    client: Docker = field(default_factory=Docker)\n\n    worker_image: str = 'account-worker'\n    network_name: str = \"assistant_bridge\"\n    config_file_destination: Path = Path(\"/app/settings.json\")\n    # fluentd_address: str = \"localhost:24224\"   # todo: logging\n\n    max_restarts: int = 3\n\n    _containers: dict[UUID, WorkerContainer] = field(default_factory=dict)\n\n    container_watcher_delay: float = 5\n\n    async def start_watching(self) -> None:\n        logger.info(f\"Starting container watcher, {id(self)}\")\n        while True:\n            logger.info(f\"Refreshing containers!\")\n            await self.refresh_containers()\n            await sleep(self.container_watcher_delay)\n\n    async def check_for_active_worker(self, user_id: UUID) -> bool:\n        return user_id in self._containers\n\n    async def get_container(self, worker_id: UUID) -> WorkerContainer:\n        return self._containers.get(worker_id)\n\n    async def refresh_containers(self) -> None:\n        to_remove = []\n        for worker_id, worker in self._containers.items():\n            if not await self.check_health(worker_id):\n                logger.info(f\"Container {worker_id} is not running, clean up...\")\n                to_remove.append(worker_id)\n\n        for worker_id in to_remove:\n            del self._containers[worker_id]\n\n    async def start_container(self, worker_id: UUID, config_path: Path) -> None:\n        logger.info(f\"Starting container with worker ID {worker_id} and config {config_path}\")\n\n        container_name = f\"{self.worker_image}-{worker_id}\"\n        container = await self.client.containers.create_or_replace(\n            name=container_name,\n            config=self._get_container_config(\n                self.worker_image,\n                config_path,\n                worker_id,\n            )\n        )\n        await container.start()\n\n        # network = await self.client.networks.get(self.network_name)\n        # await network.connect({\"Container\": container.id})\n\n        worker = WorkerContainer(\n            id=worker_id,\n            config_path=config_path,\n            container_id=container.id,\n        )\n\n        self._containers[worker_id] = worker\n\n        return container.id\n\n    def _get_container_config(self, image: str, config_path: Path, worker_id: UUID) -> dict[str, Any]:\n        env_map = dotenv_values(str('.env'))\n        env_list = [f\"{k}={v}\" for k, v in env_map.items() if v is not None]\n\n        return {\n            \"Image\": image,\n            \"Env\": env_list,\n            \"HostConfig\": {\n                \"Binds\": [\n                    f\"{self.host_root_config_path / config_path.name}:{self.config_file_destination}:ro\",\n                    f\"{self.host_upload_dir}:{self.app_upload_dir}\"\n                ],\n                # \"LogConfig\": {  # todo: logging\n                #     \"Type\": \"fluentd\",\n                #     \"Config\": {\n                #         \"fluentd-address\": self.fluentd_address,\n                #         \"tag\": \"{0}.{1}\".format(image, worker_id)\n                #     },\n                # },\n                \"NetworkMode\": self.network_name,\n            },\n        }\n\n    async def stop_container(self, worker_id: UUID) -> None:\n        logger.info(f\"Stopping container {worker_id}\")\n        bot = self._containers.pop(worker_id, None)\n        if not bot:\n            return\n        container = await self.client.containers.get(\n            container_id=bot.container_id\n        )\n        await container.delete(force=True)\n\n    async def get_running_containers(self) -> list[WorkerContainer]:\n        return list(self._containers.values())\n\n    async def check_health(self, worker_id: UUID) -> bool:\n        bot = self._containers.get(worker_id)\n        if not bot:\n            return False\n        container = await self.client.containers.get(\n            container_id=bot.container_id\n        )\n        data = await container.show()\n        return data.get(\"State\", {}).get(\"Running\", False)\n\n    async def repair_container(self, worker_id: UUID) -> bool:\n        bot = self._containers.get(worker_id)\n        if not bot:\n            return False\n        container = await self.client.containers.get(\n            container_id=bot.container_id\n        )\n        if not await self.check_health(worker_id):\n            if bot.restarts >= self.max_restarts:\n                return False\n            bot.restarts += 1\n            await container.restart()\n        return True\n"
  },
  {
    "path": "worker-manager/services/bot_service.py",
    "content": "import logging\nfrom aiogram import Bot, types\nfrom aiogram.client.default import DefaultBotProperties\nfrom aiogram.enums import ParseMode\n\n# from aiogram.client.session import SessionMiddleware\n\nfrom abstractions.services.bot_service import BotServiceInterface\nfrom settings import settings\n\nlogger = logging.getLogger(__name__)\n\nclass AiogramBotService(BotServiceInterface):\n    def __init__(self):\n        token = settings.posting_bot.token.get_secret_value()\n        # устанавливаем HTML-парсинг по умолчанию\n        default_props = DefaultBotProperties(parse_mode=ParseMode.HTML)\n        self.bot = Bot(\n            token=token,\n            default=default_props,\n            # при желании можно явно попросить бот сам закрыть сессию в деструкторе\n            # auto_close=True,\n        )\n\n    async def send_post(\n        self,\n        chat_id: int,\n        text: str,\n        entities: list = None,\n        media_path: str = None,\n    ) -> None:\n        \"\"\"\n        Отправляем либо текст, либо фото+текст пользователю/каналу.\n        Поддержка платных эмоджи: просто встраиваются в text.\n        \"\"\"\n        if media_path:\n            logger.info(f\"BotService: send_photo to {chat_id}\")\n            await self.bot.send_photo(chat_id, photo=media_path, caption=text, entities=entities)\n        else:\n            logger.info(f\"BotService: send_message to {chat_id}\")\n            await self.bot.send_message(chat_id, text, entities=entities)\n"
  },
  {
    "path": "worker-manager/services/__init__.py",
    "content": ""
  },
  {
    "path": "worker-manager/services/sending_consumer.py",
    "content": "import logging\nfrom asyncio import sleep\nfrom dataclasses import dataclass\nfrom typing import NoReturn\n\nfrom abstractions.services.manager import AccountManagerInterface\nfrom abstractions.services.sending_consumer import SendingConsumerInterface\nfrom abstractions.services.sending_request import SendingRequestServiceInterface\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass SendingConsumer(SendingConsumerInterface):\n    account_manager: AccountManagerInterface\n    sending_request_service: SendingRequestServiceInterface\n\n    idle_delay: float = 5\n    global_delay: float = 5\n\n    async def execute(self) -> NoReturn:\n        while True:\n            message_to_send = await self.sending_request_service.get_queued_message()\n            if message_to_send is None:\n                await sleep(self.idle_delay)\n                continue\n\n            logger.info(f\"new message! {message_to_send.id}\")\n            await self.sending_request_service.set_in_progress(message_to_send)\n\n            try:\n                await self.account_manager.send(message_to_send)\n            except Exception as e:\n                logger.error(e, exc_info=True)\n                await self.sending_request_service.set_failed(message_to_send)\n\n            await sleep(self.global_delay)\n"
  },
  {
    "path": "worker-manager/services/account_manager.py",
    "content": "import logging\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom uuid import UUID, uuid4\n\nfrom shared.abstractions.services.watcher_client import WatcherClientInterface\nfrom shared.domain.models import SendingRequest\nfrom shared.abstractions.repositories import UserRepositoryInterface\nfrom shared.abstractions.repositories.worker_message import WorkerMessageRepositoryInterface\nfrom shared.domain.dto import CreateWorkerMessageDTO\nfrom shared.domain.models import SendPostRequest, UserWithSessionString\nfrom shared.domain.enums import WorkerMessageType, WorkerMessageStatus\nfrom shared.settings.worker import WorkerSettings\n\nfrom abstractions.services.bot_service import BotServiceInterface\nfrom abstractions.services.container_manager import ContainerManagerInterface\nfrom abstractions.services.manager import AccountManagerInterface\nfrom dependencies.services.bot_service import get_bot_service\nfrom services.exceptions import UnknownRequestTypeException\n\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass AccountManager(AccountManagerInterface):\n    container_manager: ContainerManagerInterface\n    worker_message_repository: WorkerMessageRepositoryInterface\n    user_repository: UserRepositoryInterface\n    bot_service: BotServiceInterface\n    watcher_client: WatcherClientInterface\n\n    app_root_config_path: Path\n    api_id: int\n    api_hash: str\n\n    async def send(self, request: SendingRequest) -> None:\n        if isinstance(request, SendPostRequest):\n            await self._send_post(request)\n            return\n\n        raise UnknownRequestTypeException(f\"{type(request)} requests are not supported\")\n\n    async def _send_post(self, request: SendPostRequest) -> None:\n                await self.bot_service.send_post(\n                        chat_id = request.chat.chat_id,\n                    text = request.post.text,\n                    entities = request.post.entities,\n                    media_path = request.post.image_path,\n                )\n\n    async def ensure_worker_running(self, user_id: UUID) -> None:\n        user = await self.user_repository.get(user_id)\n\n        if await self.container_manager.check_for_active_worker(user.id):\n            return\n\n        worker_settings = self._make_worker_settings(user)\n        worker_settings_file = self.settings_to_file(worker_settings)\n\n        logger.info(worker_settings.model_dump())\n        logger.info(worker_settings_file)\n        with worker_settings_file.open('rt') as f:\n            logger.info(f.read())\n\n        await self.container_manager.start_container(\n            worker_id=worker_settings.user.id,\n            config_path=worker_settings_file,\n        )\n\n    def _make_worker_settings(self, user: UserWithSessionString) -> WorkerSettings:\n        return WorkerSettings(\n            user=user,\n            api_id=self.api_id,\n            api_hash=self.api_hash,\n        )\n\n    def settings_to_file(self, settings: WorkerSettings) -> Path:\n        filename = f\"{settings.user.telegram_username}.{uuid4()}.json\"\n        file_path = self.app_root_config_path / filename\n\n        if isinstance(settings, WorkerSettings):\n            structured_settings = settings.model_dump_json(\n                indent=4,\n            )\n            with file_path.open('wt') as f:\n                f.write(structured_settings)\n        else:\n            raise Exception('Settings should be of type WorkerSettings')\n\n        return file_path\n"
  },
  {
    "path": "worker-manager/services/exceptions.py",
    "content": "class UnknownRequestTypeException(Exception):\n    ...\n"
  },
  {
    "path": "worker-manager/services/sending_request.py",
    "content": "import logging\nfrom dataclasses import dataclass\nfrom typing import Optional\n\nfrom shared.abstractions.repositories import SendPostRequestRepositoryInterface\nfrom shared.domain.dto import UpdateSendPostRequestDTO\nfrom shared.domain.enums import SendPostRequestStatus\nfrom shared.domain.models import SendingRequest, SendPostRequest\n\nfrom abstractions.services.sending_request import SendingRequestServiceInterface\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass SendingRequestService(SendingRequestServiceInterface):\n    post_request_repository: SendPostRequestRepositoryInterface\n\n    async def get_queued_message(self) -> Optional[SendingRequest]:\n        message = await self.post_request_repository.get_queued_message()\n        logger.info(f\"Received message {message}\")\n        return message\n\n    async def set_in_progress(self, request: SendingRequest):\n        if isinstance(request, SendPostRequest):\n            dto = UpdateSendPostRequestDTO(\n                status=SendPostRequestStatus.IN_PROGRESS,\n            )\n\n            await self.post_request_repository.update(\n                obj_id=request.id,\n                obj=dto,\n            )\n\n    async def set_failed(self, request: SendingRequest) -> None:\n        if isinstance(request, SendPostRequest):\n            dto = UpdateSendPostRequestDTO(\n                status=SendPostRequestStatus.FAILED,\n            )\n\n            await self.post_request_repository.update(\n                obj_id=request.id,\n                obj=dto,\n            )\n"
  },
  {
    "path": "migrator/__init__.py",
    "content": ""
  },
  {
    "path": "migrator/main.py",
    "content": "import asyncio\nimport logging\nfrom pathlib import Path\n\nfrom pydantic import Field\nfrom pydantic_settings import SettingsConfigDict\nfrom shared.infrastructure.main_db import apply_migrations, MainDBSettings\nfrom shared.settings import AbstractSettings\n\nlogger = logging.getLogger(__name__)\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n)\n\n\nclass MigratorSettings(AbstractSettings):\n    main_db: MainDBSettings = Field(default_factory=MainDBSettings)\n\n    model_config = SettingsConfigDict(\n        extra=\"ignore\",\n        json_file=Path(__file__).parent / \"settings.json\",\n        json_file_encoding=\"utf-8\",\n    )\n\n\nasync def main():\n    settings = MigratorSettings()\n\n    await apply_migrations(url=settings.main_db.url)\n    logger.info(\"DB upgrade successfully\")\n\n\nif __name__ == '__main__':\n    asyncio.run(main())\n"
  },
  {
    "path": "posts-service/__init__.py",
    "content": ""
  },
  {
    "path": "posts-service/settings.py",
    "content": "from pathlib import Path\n\nfrom pydantic import Field\nfrom pydantic_settings import SettingsConfigDict\nfrom shared.infrastructure.main_db import MainDBSettings\nfrom shared.services.watcher_client import WatcherSettings\nfrom shared.settings import AbstractSettings\nfrom shared.settings.scheduler import SchedulerSettings\n\n\nclass Settings(AbstractSettings):\n    db: MainDBSettings = Field(default_factory=MainDBSettings)\n    scheduler: SchedulerSettings = Field(default_factory=SchedulerSettings)\n    watcher: WatcherSettings = Field(default_factory=WatcherSettings)\n\n    model_config = SettingsConfigDict(\n        extra=\"ignore\",\n        json_file=Path(__file__).parent / \"settings.json\",\n        json_file_encoding=\"utf-8\",\n    )\n\n\nsettings = Settings()\n"
  },
  {
    "path": "posts-service/main.py",
    "content": "import asyncio\nimport logging\n\nfrom shared.infrastructure.main_db import init_db\n\nfrom dependencies.services.consumer import get_posts_consumer\nfrom settings import settings\n\nlogger = logging.getLogger(__name__)\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n)\n\nasync def main():\n    logger.info(\"Starting posting service\")\n\n    init_db(settings.db.url)\n\n    consumer = get_posts_consumer()\n\n    try:\n        await consumer.execute()\n    except KeyboardInterrupt:\n        logger.info(\"Received KeyboardInterrupt, shutting down...\")\n        exit(0)\n    except Exception as e:\n        logger.error(f\"An error occurred: {e}\", exc_info=True)\n        exit(1)\n\n\nlogger.info(__name__)\n\nif __name__ == \"__main__\":\n\n    asyncio.run(main())\n\n"
  },
  {
    "path": "posts-service/dependencies/__init__.py",
    "content": ""
  },
  {
    "path": "posts-service/dependencies/services/posting.py",
    "content": "from shared.dependencies.repositories import get_post_request_repository\nfrom shared.dependencies.services.get_scheduler import get_scheduler\n\nfrom abstractions.services.posting import PostingServiceInterface\nfrom services.posting import PostingService\nfrom settings import settings\n\n\ndef get_posting_service() -> PostingServiceInterface:\n    return PostingService(\n        posts_requests_repository=get_post_request_repository(),\n        scheduler=get_scheduler(settings.scheduler.job_store_sqlite_path),\n    )\n"
  },
  {
    "path": "posts-service/dependencies/services/__init__.py",
    "content": ""
  },
  {
    "path": "posts-service/dependencies/services/watcher_client.py",
    "content": "from shared.abstractions.services.watcher_client import WatcherClientInterface\nfrom shared.dependencies.services.watcher_client import get_watcher_client_from_url\n\nfrom settings import settings\n\n\ndef get_watcher_client() -> WatcherClientInterface:\n    return get_watcher_client_from_url(\n        base_url=settings.watcher.url,\n    )\n"
  },
  {
    "path": "posts-service/dependencies/services/consumer.py",
    "content": "from shared.dependencies.repositories.post_to_publish import get_post_to_publish_repository\n\nfrom abstractions.services.cosumer import PostsConsumerInterface\nfrom dependencies.services.posting import get_posting_service\nfrom services.consumer import PostsConsumer\n\n\ndef get_posts_consumer() -> PostsConsumerInterface:\n    return PostsConsumer(\n        posting_service=get_posting_service(),\n        posts_to_publish_repository=get_post_to_publish_repository(),\n    )\n"
  },
  {
    "path": "posts-service/abstractions/__init__.py",
    "content": ""
  },
  {
    "path": "posts-service/abstractions/services/posting.py",
    "content": "from abc import ABC, abstractmethod\n\n\nclass PostingServiceInterface(ABC):\n    @abstractmethod\n    async def schedule_post(self, post):\n        ...\n"
  },
  {
    "path": "posts-service/abstractions/services/__init__.py",
    "content": ""
  },
  {
    "path": "posts-service/abstractions/services/cosumer.py",
    "content": "from abc import ABC\n\nfrom shared.abstractions.services import ConsumerInterface\n\nfrom abstractions.services.posting import PostingServiceInterface\n\n\nclass PostsConsumerInterface(\n    ConsumerInterface[PostingServiceInterface],\n    ABC,\n):\n    ...\n"
  },
  {
    "path": "posts-service/services/__init__.py",
    "content": ""
  },
  {
    "path": "posts-service/services/consumer.py",
    "content": "import logging\nfrom asyncio import sleep\nfrom dataclasses import dataclass\nfrom typing import NoReturn\n\nfrom shared.abstractions.repositories import PostToPublishRepositoryInterface\nfrom shared.domain.enums import PublicationStatus\n\nfrom abstractions.services.cosumer import PostsConsumerInterface\nfrom abstractions.services.posting import PostingServiceInterface\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass PostsConsumer(PostsConsumerInterface):\n    posting_service: PostingServiceInterface\n\n    posts_to_publish_repository: PostToPublishRepositoryInterface\n\n    idle_delay: int = 10\n    global_delay: int = 10\n\n    async def execute(self) -> NoReturn:\n        logger.info(\"Consumer started\")\n        while True:\n            post_to_publish = await self.posts_to_publish_repository.get_queued_post()\n            if not post_to_publish:\n                logger.info(\"No posts to publish\")\n                await sleep(self.idle_delay)\n                continue\n\n            logger.info(\"Scheduling post\")\n            await self.posts_to_publish_repository.set_status(\n                post_id=post_to_publish.id,\n                status=PublicationStatus.SCHEDULING,\n            )\n            try:\n                await self.posting_service.schedule_post(post_to_publish)\n            except Exception as e:\n                logger.error(f\"Failed to schedule post: {e}\", exc_info=True)\n                await self.posts_to_publish_repository.set_status(\n                    post_id=post_to_publish.id,\n                    status=PublicationStatus.FAILED,\n                )\n            else:\n                logger.info(\"Post scheduled successfully\")\n                await self.posts_to_publish_repository.set_status(\n                    post_id=post_to_publish.id,\n                    status=PublicationStatus.SCHEDULED,\n                )\n\n            await sleep(self.global_delay)\n"
  },
  {
    "path": "posts-service/services/posting/__init__.py",
    "content": "import logging\nfrom dataclasses import dataclass\nfrom datetime import datetime, date, timedelta\nfrom uuid import UUID\n\nfrom shared.abstractions.repositories import SendPostRequestRepositoryInterface\nfrom shared.abstractions.services.scheduler import SchedulerInterface\nfrom shared.abstractions.singleton import Singleton\nfrom shared.domain.enums import ScheduledType\nfrom shared.domain.models import PostToPublish\n\nfrom abstractions.services.posting import PostingServiceInterface\nfrom .jobs import publish\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass PostingService(\n    PostingServiceInterface,\n    Singleton,\n):\n    posts_requests_repository: SendPostRequestRepositoryInterface\n\n    scheduler: SchedulerInterface\n\n    async def schedule_post(self, post: PostToPublish):\n        match post.scheduled_type:\n            case ScheduledType.SINGLE:\n                logger.info(\"Found single scheduled post, scheduling it\")\n                self._schedule_post(\n                    post_id=post.id,\n                    schedule_at=datetime.combine(\n                        post.scheduled_date,\n                        post.scheduled_time,\n                    ),\n                )\n            case ScheduledType.EVERYDAY:\n                logger.info(\"Found daily scheduled post, scheduling it\")\n                next_run_date = date.today() \\\n                    if post.scheduled_time > datetime.now().time() \\\n                    else date.today() + timedelta(days=1)\n\n                self._schedule_post(\n                    post_id=post.id,\n                    schedule_at=datetime.combine(\n                        next_run_date,\n                        post.scheduled_time,\n                    ),\n                )\n\n    def _schedule_post(self, post_id: UUID, schedule_at: datetime) -> None:\n        self.scheduler.schedule_once(\n            callback=publish,\n            runs_on=schedule_at,\n            args=(post_id,),\n            job_id=f\"post_{post_id}\",\n        )\n"
  },
  {
    "path": "posts-service/services/posting/jobs.py",
    "content": "import logging\nfrom uuid import UUID\n\nfrom shared.dependencies.repositories import get_post_request_repository\nfrom shared.dependencies.repositories.post_to_publish import get_post_to_publish_repository\nfrom shared.domain.dto import CreateSendPostRequestDTO\nfrom shared.domain.enums import SendPostRequestStatus\nfrom shared.domain.requests import PostPublicationStartedRequest\n\nfrom dependencies.services.watcher_client import get_watcher_client\n\n\nasync def publish(post_id: UUID) -> None:\n    posts_to_publish_repository = get_post_to_publish_repository()\n    post_requests_repository = get_post_request_repository()\n    watcher_client = get_watcher_client()\n\n    logger = logging.getLogger(f'publisher_job_{post_id}')\n\n    post = await posts_to_publish_repository.get(post_id)\n\n    logger.info(f\"Publishing post {post.id}\")\n\n    try:\n        child_requests: list[UUID] = []\n        for chat in post.chats:\n            post_request_dto = CreateSendPostRequestDTO(\n                post_id=post.post_id,\n                chat_id=chat.id,\n                user_id=post.manager_id,\n                status=SendPostRequestStatus.PLANNED,\n                publication_id=post.id,\n            )\n\n            new = await post_requests_repository.create(post_request_dto)\n            logger.info(f\"Post request created: {new}\")\n            child_requests.append(new)\n\n    except Exception as e:\n        logger.error(f\"Failed to publish post: {e}\", exc_info=True)\n"
  },
  {
    "path": "watcher/__init__.py",
    "content": ""
  },
  {
    "path": "watcher/settings.py",
    "content": "from pathlib import Path\n\nfrom pydantic import Field\n\nfrom pydantic_settings import SettingsConfigDict\n\nfrom shared.infrastructure.main_db import MainDBSettings\nfrom shared.settings import AbstractSettings\n\n\nclass Settings(AbstractSettings):\n    db: MainDBSettings = Field(default_factory=MainDBSettings)\n\n    model_config = SettingsConfigDict(\n        extra=\"ignore\",\n        json_file=Path(__file__).parent.parent / \"settings.json\",\n        json_file_encoding=\"utf-8\",\n    )\n\nsettings = Settings()\n"
  },
  {
    "path": "watcher/main.py",
    "content": "import logging\nfrom contextlib import asynccontextmanager\nfrom typing import AsyncGenerator\n\nfrom fastapi import FastAPI\nfrom shared.infrastructure.main_db import init_db\n\nfrom routes import (\n    watch_router,\n)\nfrom settings import settings\n\nlogger = logging.getLogger(__name__)\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n)\n\n\n@asynccontextmanager\nasync def lifespan(_) -> AsyncGenerator[None, None]:\n    init_db(settings.db.url)\n\n    yield\n\n\napp = FastAPI(lifespan=lifespan)\n\napp.include_router(watch_router)\n"
  },
  {
    "path": "watcher/dependencies/__init__.py",
    "content": ""
  },
  {
    "path": "watcher/dependencies/services/__init__.py",
    "content": ""
  },
  {
    "path": "watcher/dependencies/services/publication.py",
    "content": "from shared.dependencies.repositories import get_post_request_repository\nfrom shared.dependencies.repositories.post_to_publish import get_post_to_publish_repository\n\nfrom abstractions.services.publication import PublicationServiceInterface\nfrom services.publication import PublicationService\n\n\ndef get_publication_service() -> PublicationServiceInterface:\n    return PublicationService(\n        post_to_publish_repository=get_post_to_publish_repository(),\n        posts_request_repository=get_post_request_repository(),\n    )\n"
  },
  {
    "path": "watcher/dependencies/services/messages.py",
    "content": "from shared.dependencies.repositories import get_post_request_repository\nfrom shared.dependencies.repositories.post_to_publish import get_post_to_publish_repository\nfrom shared.dependencies.repositories.worker_message import get_worker_message_repository\n\nfrom abstractions.services.messages import MessageServiceInterface\nfrom dependencies.services.requests import get_requests_service\nfrom services.messages import MessageService\n\n\ndef get_messages_service() -> MessageServiceInterface:\n    return MessageService(\n        worker_message_repository=get_worker_message_repository(),\n        post_requests_repository=get_post_request_repository(),\n        posts_to_publish_repository=get_post_to_publish_repository(),\n        requests_service=get_requests_service(),\n    )"
  },
  {
    "path": "watcher/dependencies/services/watcher.py",
    "content": "from abstractions.services.watcher import WatcherInterface\nfrom dependencies.services.messages import get_messages_service\nfrom dependencies.services.publication import get_publication_service\nfrom dependencies.services.requests import get_requests_service\nfrom services.watcher import Watcher\n\n\ndef get_watcher() -> WatcherInterface:\n    return Watcher(\n        publication_service=get_publication_service(),\n        requests_service=get_requests_service(),\n        message_service=get_messages_service(),\n    )\n"
  },
  {
    "path": "watcher/dependencies/services/requests.py",
    "content": "from shared.dependencies.repositories import get_post_request_repository\nfrom shared.dependencies.repositories.worker_message import get_worker_message_repository\n\nfrom abstractions.services.requests import SendingRequestsServiceInterface\nfrom dependencies.services.publication import get_publication_service\nfrom services.requests import SendingRequestsService\n\n\ndef get_requests_service() -> SendingRequestsServiceInterface:\n    return SendingRequestsService(\n        post_requests_repository=get_post_request_repository(),\n        messages_repository=get_worker_message_repository(),\n        publication_service=get_publication_service(),\n    )\n"
  },
  {
    "path": "watcher/abstractions/__init__.py",
    "content": ""
  },
  {
    "path": "watcher/abstractions/services/__init__.py",
    "content": ""
  },
  {
    "path": "watcher/abstractions/services/publication.py",
    "content": "from abc import ABC, abstractmethod\nfrom typing import Optional\nfrom uuid import UUID\n\nfrom shared.domain.models import Publication, SendingRequest\nfrom shared.domain.requests import PublicationType, PublicationStartedRequest\n\n\nclass PublicationServiceInterface(ABC):\n    @abstractmethod\n    async def register_finished_request(self, request: SendingRequest) -> None:\n        ...\n"
  },
  {
    "path": "watcher/abstractions/services/messages.py",
    "content": "from abc import ABC, abstractmethod\nfrom typing import Optional\nfrom uuid import UUID\n\nfrom shared.domain.models import WorkerMessage\nfrom shared.domain.requests import MessageSentRequest\n\n\nclass MessageServiceInterface(ABC):\n    @abstractmethod\n    async def get_message(self, message_id: UUID) -> Optional[WorkerMessage]:\n        ...\n\n    @abstractmethod\n    async def register_message(self, request: MessageSentRequest) -> None:\n        ...\n"
  },
  {
    "path": "watcher/abstractions/services/watcher.py",
    "content": "from abc import ABC, abstractmethod\n\nfrom shared.domain.requests import PublicationStartedRequest, RequestProcessingStartedRequest, MessageSentRequest\n\n\nclass WatcherInterface(\n    ABC,\n):\n    @abstractmethod\n    async def register_message(self, request: MessageSentRequest) -> None:\n        ...\n"
  },
  {
    "path": "watcher/abstractions/services/requests.py",
    "content": "from abc import ABC, abstractmethod\nfrom typing import Optional\nfrom uuid import UUID\n\nfrom shared.domain.models import WorkerMessage, SendingRequest\nfrom shared.domain.requests import PublicationType, RequestProcessingStartedRequest\n\n\nclass SendingRequestsServiceInterface(ABC):\n    @abstractmethod\n    async def get_request(self, request_id: UUID, request_type: PublicationType) -> Optional[SendingRequest]:\n        ...\n\n    @abstractmethod\n    async def register_sent_message(self, message: WorkerMessage) -> None:\n        ...\n"
  },
  {
    "path": "watcher/routes/__init__.py",
    "content": "from .watch import router as watch_router\n"
  },
  {
    "path": "watcher/routes/watch.py",
    "content": "import logging\n\nfrom fastapi import APIRouter, HTTPException\nfrom shared.domain.requests import PublicationStartedRequest, RequestProcessingStartedRequest, MessageSentRequest\n\nfrom dependencies.services.watcher import get_watcher\nfrom services.exceptions import RepeatedRegistrationException\n\nrouter = APIRouter(\n    prefix='/watch',\n)\n\nlogger = logging.getLogger(__name__)\n\n@router.post('/message')\nasync def message(report: MessageSentRequest):\n    watcher = get_watcher()\n    try:\n        await watcher.register_message(report)\n    except RepeatedRegistrationException as e:\n        logger.error(e)\n        raise HTTPException(\n            status_code=400,\n            detail=str(e),\n        )\n"
  },
  {
    "path": "watcher/services/__init__.py",
    "content": ""
  },
  {
    "path": "watcher/services/publication.py",
    "content": "from dataclasses import dataclass\n\nfrom shared.abstractions.repositories import PostToPublishRepositoryInterface, SendPostRequestRepositoryInterface\nfrom shared.domain.dto import UpdatePostToPublishDTO\nfrom shared.domain.enums import SendPostRequestStatus, PublicationStatus\nfrom shared.domain.models import SendingRequest, SendPostRequest\n\nfrom abstractions.services.publication import PublicationServiceInterface\n\n\n@dataclass\nclass PublicationService(PublicationServiceInterface):\n    post_to_publish_repository: PostToPublishRepositoryInterface\n    posts_request_repository: SendPostRequestRepositoryInterface\n\n    async def register_finished_request(self, request: SendingRequest) -> None:\n        if isinstance(request, SendPostRequest):\n            requests = await self.posts_request_repository.get_requests_from_same_publication(request.id)\n            if done := all(map(lambda x: x.status == SendPostRequestStatus.SENT, requests)):\n                update_request_dto = UpdatePostToPublishDTO(\n                    status=PublicationStatus.POSTED,\n                )\n\n                await self.post_to_publish_repository.update(\n                    obj_id=request.publication_id,\n                    obj=update_request_dto,\n                )\n\n        # todo: stories"
  },
  {
    "path": "watcher/services/messages.py",
    "content": "from dataclasses import dataclass\nfrom typing import Optional\nfrom uuid import UUID\n\nfrom shared.abstractions.repositories import SendPostRequestRepositoryInterface, PostToPublishRepositoryInterface\nfrom shared.abstractions.repositories.worker_message import WorkerMessageRepositoryInterface\nfrom shared.domain.enums import WorkerMessageType, WorkerMessageStatus\nfrom shared.domain.models import WorkerMessage\nfrom shared.domain.requests import MessageSentRequest\nfrom shared.infrastructure.sqlalchemy import NotFoundException\n\nfrom abstractions.services.messages import MessageServiceInterface\nfrom abstractions.services.requests import SendingRequestsServiceInterface\nfrom services.exceptions import MessageNotFoundException\n\n\n@dataclass\nclass MessageService(MessageServiceInterface):\n    worker_message_repository: WorkerMessageRepositoryInterface\n    post_requests_repository: SendPostRequestRepositoryInterface\n    posts_to_publish_repository: PostToPublishRepositoryInterface\n\n    requests_service: SendingRequestsServiceInterface\n\n    async def get_message(self, message_id: UUID) -> Optional[WorkerMessage]:\n        try:\n            message = await self.worker_message_repository.get(message_id)\n            return message\n        except NotFoundException:\n            return None\n\n    async def register_message(self, request: MessageSentRequest) -> None:\n        message = await self.worker_message_repository.get(request.message_id)\n        if not message:\n            raise MessageNotFoundException\n\n        await self.requests_service.register_sent_message(message)\n"
  },
  {
    "path": "watcher/services/exceptions.py",
    "content": "class RepeatedRegistrationException(Exception):\n    ...\n\nclass MessageNotFoundException(Exception):\n    ...\n"
  },
  {
    "path": "watcher/services/watcher.py",
    "content": "import logging\nfrom dataclasses import dataclass\nfrom enum import StrEnum\n\nfrom shared.abstractions.singleton import Singleton\nfrom shared.domain.enums import WorkerMessageStatus\nfrom shared.domain.requests import MessageSentRequest, RequestProcessingStartedRequest, PublicationStartedRequest\n\nfrom abstractions.services.messages import MessageServiceInterface\nfrom abstractions.services.publication import PublicationServiceInterface\nfrom abstractions.services.requests import SendingRequestsServiceInterface\nfrom abstractions.services.watcher import WatcherInterface\nfrom services.exceptions import RepeatedRegistrationException\n\nlogger = logging.getLogger(__name__)\n\n\nclass ChildEntityStatus(StrEnum):\n    PENDING = 'pending'\n    COMPLETED = 'completed'\n    FAILED = 'failed'\n\n\n@dataclass\nclass Watcher(\n    WatcherInterface,\n    Singleton,\n):\n    publication_service: PublicationServiceInterface\n    requests_service: SendingRequestsServiceInterface\n    message_service: MessageServiceInterface\n\n    async def register_message(self, request: MessageSentRequest) -> None:\n        # if (await self.message_service.get_message(request.message_id)).status == WorkerMessageStatus.SENT:\n        #     logger.error(f'Message {request.message_id} already registered')\n        #     raise RepeatedRegistrationException(f\"Message {request.message_id} already registered.\")\n\n        await self.message_service.register_message(request)\n        logger.info(f'Message {request.message_id} registered')\n"
  },
  {
    "path": "watcher/services/requests.py",
    "content": "import logging\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom typing import Optional\nfrom uuid import UUID\n\nfrom shared.abstractions.repositories import SendPostRequestRepositoryInterface\nfrom shared.abstractions.repositories.worker_message import WorkerMessageRepositoryInterface\nfrom shared.domain.dto import UpdateSendPostRequestDTO\nfrom shared.domain.enums import WorkerMessageStatus, SendPostRequestStatus, WorkerMessageType\nfrom shared.domain.models import WorkerMessage, SendingRequest\nfrom shared.domain.requests import PublicationType, RequestProcessingStartedRequest\n\nfrom abstractions.services.publication import PublicationServiceInterface\nfrom abstractions.services.requests import SendingRequestsServiceInterface\n\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass SendingRequestsService(SendingRequestsServiceInterface):\n    post_requests_repository: SendPostRequestRepositoryInterface\n    messages_repository: WorkerMessageRepositoryInterface\n\n    publication_service: PublicationServiceInterface\n\n    async def get_request(self, request_id: UUID, request_type: PublicationType) -> Optional[SendingRequest]:\n        if request_type == PublicationType.POST:\n            return await self.post_requests_repository.get(request_id)\n\n        ...\n\n    async def register_sent_message(self, message: WorkerMessage) -> None:\n        messages = await self.messages_repository.get_messages_from_same_request(message.id)\n        logger.info(f'messages: {messages}')\n        if done := all(map(lambda x: x.status == WorkerMessageStatus.SENT, messages)):\n            logger.info(f'done: {done}')\n            logger.info(f'type: {message.type}')\n            if message.type == WorkerMessageType.POST:\n                update_request_dto = UpdateSendPostRequestDTO(\n                    status=SendPostRequestStatus.SENT,\n                    sent_at=datetime.now(),\n                )\n\n                await self.post_requests_repository.update(\n                    obj_id=message.request_id,\n                    obj=update_request_dto,\n                )\n\n                request = await self.get_request(message.request_id, PublicationType.POST)\n\n                await self.publication_service.register_finished_request(request)\n\n            # todo: stories\n"
  },
  {
    "path": "user_bot/handlers.py",
    "content": "import logging\nfrom datetime import datetime, timezone\n\nfrom telethon import TelegramClient\nfrom telethon import events\nfrom telethon.tl.functions.stories import SendStoryRequest\nfrom telethon.tl.types import InputPrivacyValueAllowAll\nfrom telethon.tl.types import User as TelegramUser\n\nfrom backend.dependencies.services.gpt import get_gpt_service\nfrom backend.dependencies.services.user import get_user_service\nfrom domain.dto.user import CreateUserDTO\nfrom infrastructure.enums.user_status import UserStatus\nfrom user_bot.settings import settings\n\nbot = TelegramClient(\n    session='ai_assistant_bot',\n    api_id=settings.account.api_id,\n    api_hash=settings.account.api_hash,\n)\n\nbot.start(\n    phone=settings.account.phone,\n)\n\nstory_states = {}\nstory_schedule_states = {}\n\nlogger = logging.getLogger(__name__)\n\n\n\nasync def get_sender(event: events.NewMessage.Event) -> TelegramUser:\n    return await bot.get_entity(event.chat_id)\n\n\n# Команда для немедленной публикации истории\n@bot.on(events.NewMessage(pattern='/post_story'))\nasync def cmd_post_story(event: events.NewMessage.Event):\n    sender = await get_sender(event)\n    if sender.username != 'firs_iln':\n        return\n\n    user_service = get_user_service()\n    user = await user_service.get_user_by_telegram_id(sender.id)\n    if not user:\n        await user_service.create_user(CreateUserDTO(\n            telegram_id=sender.id,\n            nickname=sender.username,\n        ))\n\n        user = await user_service.get_user_by_telegram_id(sender.id)\n\n    if user.status != UserStatus.MANAGER:\n        return await event.respond('🚫 Нет доступа.')\n\n    story_states[event.sender_id] = {}\n    await event.respond('📝 Введите текст истории:')\n\n\n# Команда для отложенной публикации истории\n@bot.on(events.NewMessage(pattern='/schedule_story'))\nasync def cmd_schedule_story(event: events.NewMessage.Event):\n    sender = await get_sender(event)\n    if sender.username != 'firs_iln':\n        return\n\n    user_service = get_user_service()\n    user = await user_service.get_user_by_telegram_id(event.chat_id)\n    if user.status != UserStatus.MANAGER:\n        return await event.respond('🚫 Нет доступа.')\n\n    story_schedule_states[event.sender_id] = {}\n    await event.respond('📝 Введите текст истории:')\n\n\n# Общий обработчик публикаций и регистрации\n@bot.on(events.NewMessage())\nasync def handle_messages(event):\n    sender = await get_sender(event)\n    if sender.username != 'firs_iln':\n        return\n\n    user_id = event.sender_id\n    # Немедленная публикация\n    if user_id in story_states:\n        state = story_states[user_id]\n        if 'text' not in state:\n            state['text'] = event.raw_text\n            return await event.respond('📷 Пришлите изображение или /skip:')\n        if event.raw_text.strip() == '/skip':\n            # await user_bot.send_message('@ampstats', state['text'])\n            await event.respond('✅ Опубликовано без изображения.')\n            del story_states[user_id]\n            return\n        if event.photo or event.document:\n            media = event.photo or event.document\n            if media:\n                # uploaded = await user_bot.upload_file(state['file'])\n                # file_id = uploaded\n\n                await bot(SendStoryRequest(\n                    peer='daria0028',\n                    media=media,\n                    privacy_rules=[InputPrivacyValueAllowAll()],\n                ))\n            # await user_bot.send_file('@ampstats', media, caption=state['text'])\n            await event.respond('✅ Опубликовано с изображением.')\n            del story_states[user_id]\n            return\n        return\n    # Отложенная публикация\n    if user_id in story_schedule_states:\n        state = story_schedule_states[user_id]\n        if 'text' not in state:\n            state['text'] = event.raw_text\n            return await event.respond('📷 Пришлите изображение или /skip:')\n        if 'file' not in state:\n            if event.raw_text.strip() == '/skip':\n                state['file'] = None\n            elif event.photo or event.document:\n                state['file'] = event.photo or event.document\n            else:\n                return await event.respond('❗ Отправьте изображение или /skip.')\n            return await event.respond('⏰ Введите дату и время (YYYY-MM-DD HH:MM, UTC):')\n        # Шаг даты и времени\n        try:\n            dt = datetime.strptime(event.raw_text.strip(), '%Y-%m-%d %H:%M')\n            dt = dt.replace(tzinfo=timezone.utc)\n        except ValueError:\n            return await event.respond('❗ Неверный формат. Повторите (YYYY-MM-DD HH:MM):')\n\n        # story_service = get_story_service()\n        # file_id = None\n        if state['file']:\n            uploaded = await bot.upload_file(state['file'])\n            # file_id = uploaded\n\n            await bot(SendStoryRequest(\n                peer='daria0028',\n                media=uploaded,\n                privacy_rules=[InputPrivacyValueAllowAll()],\n            ))\n        # await story_service.schedule_story(text=state['text'], file_id=file_id, publish_at=dt)\n        await event.respond(f'✅ История запланирована на {dt.isoformat()}')\n        del story_schedule_states[user_id]\n        return\n    return\n    # # Регистрация пользователя в базе\n    # user_service = get_user_service()\n    # await user_service.create_user(event.sender_id)\n\n\n\n@bot.on(events.NewMessage(incoming=True))\nasync def handle_client_reply(event: events.NewMessage.Event):\n    if not event.is_private:\n        return\n    gpt_service = get_gpt_service()\n    user_service = get_user_service()\n\n    sender_id = event.sender_id\n    text = event.raw_text\n\n    # 1) Если это команды менеджера — пропускаем (у вас уже есть логика выше)\n    if text.startswith('/') and sender_id in (story_states or {}) | (story_schedule_states or {}):\n        return\n\n    # 2) Если у нас нет истории по этому user_id — начинаем новый диалог\n    await gpt_service.start_gpt_conversation(sender_id)\n\n    # 3) Посылаем текст клиента в GPT, получаем ответ\n    reply = await gpt_service.get_gpt_response(\n        user_id=sender_id,\n        user_input=text,\n    )\n\n    # 4) Отправляем ответ обратно клиенту\n    await event.respond(reply)\n\n\n# # Inline-кнопки статуса сервисов\n# def build_service_buttons(services):\n#     buttons = []\n#     for svc in services:\n#         label = f\"✅ {svc.name}\" if svc.is_active else f\"❌ {svc.name}\"\n#         buttons.append(Button.inline(label, data=f\"toggle:{svc.name}\"))\n#     return [buttons[i:i + 2] for i in range(0, len(buttons), 2)]\n#\n#\n# # Команда: показать и переключить статус сервисов\n# @user_bot.on(events.NewMessage(pattern='/services_status'))\n# async def cmd_services_status(event):\n#     user_service = get_user_service()\n#     user = await user_service.get_user_by_telegram_id(event.sender.id)\n#     if user.status != UserStatus.MANAGER:\n#         return await event.respond('🚫 Нет доступа.')\n#\n#     analytics_service = get_analytics_service_service()\n#     services = await analytics_service.get_all_services()\n#     text = '🛠 Статус сервисов:'\n#     await event.respond(text, buttons=build_service_buttons(services))\n#\n#\n# # Обработка нажатия inline-кнопки для смены статуса\n# @user_bot.on(events.CallbackQuery)\n# async def callback_toggle(event):\n#     data = event.data.decode()\n#     user_service = get_user_service()\n#     user = await user_service.get_user_by_telegram_id(event.sender.id)\n#\n#     if not data.startswith('toggle:') or user.status != UserStatus.MANAGER:\n#         return\n#\n#     _, name = data.split(':', 1)\n#     analytics_service = get_analytics_service_service()\n#     services = await analytics_service.get_all_services()\n#     svc = next((s for s in services if s.name == name), None)\n#     if not svc:\n#         return await event.answer('Сервис не найден', alert=True)\n#\n#     new_status = not svc.is_active\n#     success = await analytics_service.update_service_active_status(svc.id, new_status)\n#     if success:\n#         updated = await analytics_service.get_all_services()\n#         await event.edit(buttons=build_service_buttons(updated))\n#         await event.answer(f\"Статус {name} \" + (\"включён\" if new_status else \"отключён\"))\n#     else:\n#         await event.answer('Ошибка при обновлении.', alert=True)\n\n#\n# @user_bot.on(events.NewMessage())\n# async def auto_register(event: events.NewMessage.Event):\n#     # \\\"\\\"\\\"\n#     # При любом сообщении создаём или обновляем клиента в БД,\n#     # заполняя telegram_id, nickname, а статус остаётся дефолтным.\n#     # \\\"\\\"\\\"\n#     user_service = get_user_service()\n#\n#     # Получаем полную информацию о пользователе\n#     sender = await event.get_sender()\n#     nickname = sender.username or ((sender.first_name or '') +\n#                                    (' ' + (sender.last_name or '') if sender.last_name else '')).strip()\n#\n#     user = await user_service.get_user_by_telegram_id(event.sender.id)\n#\n#     if user:\n#         return\n#     else:\n#         dto = CreateUserDTO(\n#             telegram_id=event.sender_id,\n#             nickname=nickname,\n#         )\n#\n#     await user_service.create_user(dto)\n"
  },
  {
    "path": "user_bot/__init__.py",
    "content": "from .handlers import bot\n"
  },
  {
    "path": "user_bot/settings.py",
    "content": "import os\nfrom pathlib import Path\nfrom typing import Type, Tuple, Optional\n\nfrom pydantic import SecretStr\nfrom pydantic_settings import (\n    BaseSettings,\n    SettingsConfigDict,\n    PydanticBaseSettingsSource,\n    JsonConfigSettingsSource,\n)\n\nENV = os.getenv(\"ENVIRONMENT\", \"local\")\n\n\nclass DBSettings(BaseSettings):\n    host: str\n    port: int\n    name: str\n    user: str\n    password: SecretStr\n\n    @property\n    def url(self):\n        return (\n            f\"postgresql+asyncpg://{self.user}:{self.password.get_secret_value()}@\"\n            f\"{self.host}:{self.port}/{self.name}\"\n        )\n\n\nclass AccountSettings(BaseSettings):\n    phone: str\n    api_id: int\n    api_hash: str\n    session_string: Optional[str] = None\n\n\nclass AssistantSettings(BaseSettings):\n    openai_api_key: str\n    assistant_id: str\n\n\nclass JwtSettings(BaseSettings):\n    secret_key: SecretStr\n    issuer: str\n    audience: str\n    access_expire: int\n    refresh_expire: int\n\n\nclass BotTokenSettings(BaseSettings):\n    token: str\n    username: str\n\n\nclass MailingSettings(BaseSettings):\n    a_days: str\n    b_days: str\n    c_days: str\n    a_hour: int\n    a_minute: int\n    b_hour: int\n    b_minute: int\n    c_hour: int\n    c_minute: int\n\n\n\nclass Settings(BaseSettings):\n    db: DBSettings\n    jwt: JwtSettings\n    account: AccountSettings\n    assistant: AssistantSettings\n    mailing: MailingSettings\n\n    debug: bool = True\n\n    model_config = SettingsConfigDict(\n        extra=\"ignore\",\n        json_file=Path(__file__).parent / \"settings.json\",\n        json_file_encoding=\"utf-8\",\n    )\n\n    @classmethod\n    def settings_customise_sources(\n            cls,\n            settings_cls: Type[BaseSettings],\n            init_settings: PydanticBaseSettingsSource,\n            env_settings: PydanticBaseSettingsSource,\n            dotenv_settings: PydanticBaseSettingsSource,\n            file_secret_settings: PydanticBaseSettingsSource,\n    ) -> Tuple[PydanticBaseSettingsSource, ...]:\n        return (\n            JsonConfigSettingsSource(settings_cls),  # Fallback to JSON\n        )\n\n\nsettings = Settings()\n"
  },
  {
    "path": "admin/__init__.py",
    "content": ""
  },
  {
    "path": "admin/backend/__init__.py",
    "content": ""
  },
  {
    "path": "admin/backend/main.py",
    "content": "import logging\nfrom contextlib import asynccontextmanager\nfrom typing import AsyncGenerator\n\nfrom fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\n# from fastapi.openapi.utils import get_openapi\nfrom shared.infrastructure.main_db import init_db\nfrom settings import settings\nfrom middlewares.auth_middleware import check_for_auth\n# from middlewares import check_for_auth\nfrom routes import (\n    api_router,\n)\n\nlogger = logging.getLogger(__name__)\nlogging.basicConfig(\n    level=logging.INFO,\n    # level=logging.DEBUG if settings.environment.is_debug else logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n)\n\n\n@asynccontextmanager\nasync def lifespan(_) -> AsyncGenerator[None, None]:\n    init_db(settings.db.url)\n\n    yield\n\n\napp = FastAPI(lifespan=lifespan)\n\napp.middleware('http')(check_for_auth)\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=settings.jwt.allowed_origins,\n    allow_credentials=True,\n    allow_methods=[\"GET\", \"POST\", \"OPTIONS\", \"PATCH\", \"DELETE\"],\n    allow_headers=[\"*\"],\n)\n\napp.include_router(api_router)\n\n# def custom_openapi():\n#     if app.openapi_schema:\n#         return app.openapi_schema\n#     openapi_schema = get_openapi(\n#         title=\"Assistant Admin Panel API\",\n#         version=\"0.1.0\",\n#         description=\"meow\",\n#         routes=app.routes,\n#     )\n#     openapi_schema[\"components\"][\"securitySchemes\"] = {\n#         \"bearerAuth\": {\n#             \"type\": \"http\",\n#             \"scheme\": \"bearer\",\n#             \"bearerFormat\": \"JWT\",\n#         }\n#     }\n#     openapi_schema[\"security\"] = [{\"bearerAuth\": []}]\n#     app.openapi_schema = openapi_schema\n#     return app.openapi_schema\n#\n#\n# app.openapi = custom_openapi\n"
  },
  {
    "path": "admin/backend/settings/service_account.py",
    "content": "from pydantic import SecretStr, Field\nfrom shared.settings import AbstractSettings\n\n\nclass ServiceAccountSettings(AbstractSettings):\n    api_id: int\n    api_hash: str\n    session_string: SecretStr\n    proxy: str\n    service_bot_token: SecretStr = Field(..., alias=\"SERVICE_BOT_TOKEN\")\n    use_bot_for_service: bool = False\n"
  },
  {
    "path": "admin/backend/settings/__init__.py",
    "content": "from pathlib import Path\n\nfrom pydantic import Field\nfrom pydantic_settings import SettingsConfigDict\n\nfrom shared.settings import AbstractSettings, JwtSettings, EnvironmentSettings, BotSettings\nfrom shared.infrastructure.main_db import MainDBSettings\n\nfrom .service_account import ServiceAccountSettings\n\n\nclass Settings(AbstractSettings):\n    db: MainDBSettings = Field(default_factory=MainDBSettings)\n    jwt: JwtSettings\n    environment: EnvironmentSettings\n    bot: BotSettings = Field(default_factory=BotSettings)\n    service_account: ServiceAccountSettings\n\n    model_config = SettingsConfigDict(\n        extra=\"ignore\",\n        json_file=Path(__file__).parent.parent / \"settings.json\",\n        json_file_encoding=\"utf-8\",\n    )\n\nsettings = Settings()\n"
  },
  {
    "path": "admin/backend/forms/update_post_form.py",
    "content": "from typing import Optional\n\nfrom fastapi import UploadFile\nfrom pydantic import BaseModel\n\n\nclass UpdatePostForm(BaseModel):\n    name: Optional[str] = None\n    text: Optional[str] = None\n    html: Optional[str] = None\n    entities: Optional[str] = None\n    image: Optional[UploadFile] = None\n"
  },
  {
    "path": "admin/backend/forms/auth_code_form.py",
    "content": "from domain.schemas.auth import Credentials\n\n\ndef auth_code_form(\n        credentials: Credentials\n) -> Credentials:\n    return credentials\n"
  },
  {
    "path": "admin/backend/middlewares/__init__.py",
    "content": "from .auth_middleware import check_for_auth\n"
  },
  {
    "path": "admin/backend/middlewares/auth_middleware.py",
    "content": "import logging\n\nfrom fastapi import Request\nfrom fastapi.responses import JSONResponse\nfrom shared.infrastructure.sqlalchemy import NotFoundException\n\nfrom dependencies.services.auth import get_auth_service\nfrom services.auth.exceptions import InvalidTokenException, ExpiredTokenException\nfrom services.exceptions import PermissionException, BannedUserException\n\n\nasync def check_for_auth(\n        request: Request,\n        call_next,\n):\n    url_path = request.url.path.replace(\"/api\", \"\")\n    if (\n            url_path.startswith(\"/auth\") or\n            url_path.startswith(\"/docs\") or\n            url_path.startswith(\"/openapi\") or\n            url_path.startswith(\"/upload\") or\n            request.method == 'OPTIONS'\n    ):\n        response = await call_next(request)\n        return response\n\n    if 'Authorization' not in request.headers:\n        return JSONResponse(\n            status_code=401,\n            content={\n                'detail': 'Token is empty',\n            }\n        )\n\n    access_token = request.headers['Authorization'].replace('Bearer ', '')\n\n    auth_service = get_auth_service()\n    try:\n        # user_id = UUID('')\n        user_id = await auth_service.get_user_id_from_jwt(access_token)\n    except Exception as e:\n        logging.getLogger(__name__).error(f\"fuuuck {access_token}\", exc_info=True)\n        code, detail = 401, 'Unknown authorization exception'\n        match e:\n            case InvalidTokenException():\n                detail = 'Token is invalid'\n            case ExpiredTokenException():\n                detail = 'Token is expired'\n            case NotFoundException():\n                detail = 'User ID found in token does not exist'\n            case BannedUserException():\n                detail = \"You're banned\"\n                code = 403\n\n        return JSONResponse(\n            status_code=code,\n            content={\n                'detail': detail,\n            }\n        )\n\n    request.scope['x_user_id'] = user_id\n    try:\n        response = await call_next(request)\n        return response\n    except PermissionException as e:\n        return JSONResponse(\n            status_code=403,\n            content={\n                'detail': \"You're lacking permissions to do this.\",\n            }\n        )\n"
  },
  {
    "path": "admin/backend/dependencies/__init__.py",
    "content": ""
  },
  {
    "path": "admin/backend/dependencies/services/post.py",
    "content": "from shared.dependencies.repositories import get_post_repository\n\nfrom abstractions.services.post import PostServiceInterface\nfrom dependencies.services.upload import get_upload_service\nfrom services.post import PostService\n\n\ndef get_post_service() -> PostServiceInterface:\n    return PostService(\n        post_repository=get_post_repository(),\n        upload_service=get_upload_service(),\n    )\n\n"
  },
  {
    "path": "admin/backend/dependencies/services/story.py",
    "content": "from shared.dependencies.repositories import get_story_repository\n\nfrom abstractions.services.story import StoryServiceInterface\nfrom services.story import StoryService\n\n\ndef get_story_service() -> StoryServiceInterface:\n    return StoryService(\n        story_repository=get_story_repository()\n    )\n\n"
  },
  {
    "path": "admin/backend/dependencies/services/user.py",
    "content": "from shared.dependencies.repositories import get_user_repository, get_proxy_repository\n\nfrom abstractions.services.user import UserServiceInterface\nfrom dependencies.services.telegram import get_telegram_service\nfrom services.user import UserService\n\n\ndef get_user_service() -> UserServiceInterface:\n    return UserService(\n        user_repository=get_user_repository(),\n        telegram_service=get_telegram_service(),\n        proxy_repository=get_proxy_repository(),\n    )"
  },
  {
    "path": "admin/backend/dependencies/services/story_to_publish.py",
    "content": "from shared.dependencies.repositories.story_to_publish import get_story_to_publish_repository\n\nfrom abstractions.services.story_to_publish import StoryToPublishServiceInterface\nfrom services.story_to_publish import StoryToPublishService\n\n\ndef get_story_to_publish_service() -> StoryToPublishServiceInterface:\n    return StoryToPublishService(\n        story_to_publish_repository=get_story_to_publish_repository()\n    )\n\n"
  },
  {
    "path": "admin/backend/dependencies/services/upload.py",
    "content": "from shared.abstractions.services import UploadServiceInterface\nfrom shared.dependencies.services import get_upload_service as get_base_upload_service\nfrom settings import settings\n\n\ndef get_upload_service() -> UploadServiceInterface:\n    return get_base_upload_service(\n        public_backend_base_url=settings.environment.host,\n    )\n"
  },
  {
    "path": "admin/backend/dependencies/services/telegram.py",
    "content": "from abstractions.services.telegram import TelegramServiceInterface\nfrom services.telegram import TelegramService\nfrom settings import settings\n\n\ndef get_telegram_service() -> TelegramServiceInterface:\n    return TelegramService(\n        api_id=settings.service_account.api_id,\n        api_hash=settings.service_account.api_hash,\n        service_session_string=settings.service_account.session_string.get_secret_value(),\n        proxy=settings.service_account.proxy,\n        service_bot_token=settings.service_account.service_bot_token.get_secret_value(),\n        use_bot_for_service=settings.service_account.use_bot_for_service,\n    )\n"
  },
  {
    "path": "admin/backend/dependencies/services/post_to_publish.py",
    "content": "from shared.dependencies.repositories.post_to_publish import get_post_to_publish_repository\n\nfrom abstractions.services.post_to_publish import PostToPublishServiceInterface\nfrom dependencies.services.upload import get_upload_service\nfrom services.post_to_publish import PostToPublishService\n\n\ndef get_post_to_publish_service() -> PostToPublishServiceInterface:\n    return PostToPublishService(\n        post_to_publish_repository=get_post_to_publish_repository(),\n        upload_service=get_upload_service(),\n    )\n\n"
  },
  {
    "path": "admin/backend/dependencies/services/__init__.py",
    "content": ""
  },
  {
    "path": "admin/backend/dependencies/services/chat.py",
    "content": "from shared.dependencies.repositories import get_chat_repository\n\nfrom abstractions.services.chat import ChatServiceInterface\nfrom dependencies.services.telegram import get_telegram_service\nfrom services.chat import ChatService\n\n\ndef get_chat_service() -> ChatServiceInterface:\n    return ChatService(\n        chats_repository=get_chat_repository(),\n        telegram_service=get_telegram_service(),\n    )\n"
  },
  {
    "path": "admin/backend/dependencies/services/auth/service.py",
    "content": "from abstractions.services.auth.service import AuthServiceInterface\nfrom dependencies.services.auth.token import get_token_service\nfrom dependencies.services.user import get_user_service\nfrom services.auth.service import AuthService\nfrom settings import settings\n\n\ndef get_auth_service() -> AuthServiceInterface:\n    return AuthService(\n        bot_token=settings.bot.token.get_secret_value(),\n        token_service=get_token_service(),\n        user_service=get_user_service()\n    )\n"
  },
  {
    "path": "admin/backend/dependencies/services/auth/token.py",
    "content": "from abstractions.services.auth.tokens import TokenServiceInterface\nfrom services.auth.tokens import TokenService\nfrom settings import settings\n\n\ndef get_token_service() -> TokenServiceInterface:\n    return TokenService(\n        jwt_settings=settings.jwt\n    )\n"
  },
  {
    "path": "admin/backend/dependencies/services/auth/__init__.py",
    "content": "from .service import get_auth_service\n"
  },
  {
    "path": "admin/backend/abstractions/__init__.py",
    "content": ""
  },
  {
    "path": "admin/backend/abstractions/services/post.py",
    "content": "from abc import ABC, abstractmethod\nfrom typing import List\nfrom uuid import UUID\n\nfrom shared.domain.dto import CreatePostDTO, UpdatePostDTO\nfrom shared.domain.models import post\n\n\nclass PostServiceInterface(ABC):\n\n    @abstractmethod\n    async def get_all_posts(self) -> List[post]:\n        ...\n\n    @abstractmethod\n    async def create_post(self, post: CreatePostDTO) -> UUID:\n        ...\n\n    @abstractmethod\n    async def get_post(self, post_id: UUID) -> post:\n        ...\n\n    @abstractmethod\n    async def update_post(self, post_id: UUID, post: UpdatePostDTO) -> None:\n        ...\n\n    @abstractmethod\n    async def delete_post(self, post_id: UUID) -> None:\n        ...\n"
  },
  {
    "path": "admin/backend/abstractions/services/story.py",
    "content": "from abc import ABC, abstractmethod\nfrom typing import List\nfrom uuid import UUID\n\nfrom shared.domain.dto.story import CreateStoryDTO, UpdateStoryDTO\nfrom shared.domain.models.story import Story\n\n\nclass StoryServiceInterface(ABC):\n\n    @abstractmethod\n    async def get_all_stories(self) -> List[Story]:\n        ...\n\n    @abstractmethod\n    async def create_story(self, story: CreateStoryDTO) -> UUID:\n        ...\n\n    @abstractmethod\n    async def get_story(self, story_id: UUID) -> Story:\n        ...\n\n    @abstractmethod\n    async def update_story(self, story_id: UUID, story: UpdateStoryDTO) -> None:\n        ...\n\n    @abstractmethod\n    async def delete_story(self, story_id: UUID) -> None:\n        ...\n\n"
  },
  {
    "path": "admin/backend/abstractions/services/user.py",
    "content": "from abc import ABC, abstractmethod\nfrom typing import List, Optional\nfrom uuid import UUID\n\nfrom shared.domain.dto import CreateUserDTO, UpdateUserDTO\nfrom shared.domain.models import User\n\n\nclass UserServiceInterface(ABC):\n    @abstractmethod\n    async def get_all_users(self) -> List[User]:\n        ...\n\n    @abstractmethod\n    async def create_user(self, user: CreateUserDTO) -> UUID:\n        ...\n\n    @abstractmethod\n    async def get_user(self, user_id: UUID) -> User:\n        ...\n\n    @abstractmethod\n    async def get_user_by_telegram_id(self, telegram_id: int) -> User:\n        ...\n\n    @abstractmethod\n    async def update_user(self, user_id: UUID, user: UpdateUserDTO) -> None:\n        ...\n\n    @abstractmethod\n    async def delete_user(self, user_id: UUID) -> None:\n        ...\n\n    @abstractmethod\n    async def ensure_user(self, dto: CreateUserDTO) -> User:\n        ...\n\n    @abstractmethod\n    async def send_auth_code(self, user_id: UUID, phone: str) -> None:\n        ...\n\n    @abstractmethod\n    async def get_session_string_for_user(\n            self,\n            phone: str,\n            code: str,\n            user_id: UUID,\n            password: Optional[str] = None,\n    ) -> None:\n        ...\n"
  },
  {
    "path": "admin/backend/abstractions/services/story_to_publish.py",
    "content": "from abc import ABC, abstractmethod\nfrom typing import List\nfrom uuid import UUID\n\nfrom shared.domain.dto.story_to_publish import CreateStoryToPublishDTO, UpdateStoryToPublishDTO\nfrom shared.domain.models.story import Story\n\n\nclass StoryToPublishServiceInterface(ABC):\n\n    @abstractmethod\n    async def get_all_stories_to_publish(self) -> List[Story]:\n        ...\n\n    @abstractmethod\n    async def create_story_to_publish(self, story_to_publish: CreateStoryToPublishDTO) -> UUID:\n        ...\n\n    @abstractmethod\n    async def get_story_to_publish(self, story_to_publish_id: UUID) -> Story:\n        ...\n\n    @abstractmethod\n    async def update_story_to_publish(self, story_to_publish_id: UUID, story_to_publish: UpdateStoryToPublishDTO) -> None:\n        ...\n\n    @abstractmethod\n    async def delete_story_to_publish(self, story_to_publish_id: UUID) -> None:\n        ...\n\n"
  },
  {
    "path": "admin/backend/abstractions/services/telegram.py",
    "content": "from abc import ABC, abstractmethod\nfrom typing import Optional\n\nfrom domain.models.chat import TelegramChatInfo\n\n\nclass TelegramServiceInterface(ABC):\n    @abstractmethod\n    async def get_chat_info(self, invite_link: str) -> TelegramChatInfo:\n        ...\n\n    @abstractmethod\n    async def send_auth_code(self, phone: str, proxy: Optional[str] = None) -> None:\n        ...\n\n    @abstractmethod\n    async def get_session_string(\n            self,\n            phone: str,\n            code: str,\n            proxy: Optional[str] = None,\n            password: Optional[str] = None,\n    ) -> str:\n        ...\n"
  },
  {
    "path": "admin/backend/abstractions/services/post_to_publish.py",
    "content": "from abc import ABC, abstractmethod\nfrom typing import List\nfrom uuid import UUID\n\nfrom shared.domain.dto.post_to_publish import CreatePostToPublishDTO, UpdatePostToPublishDTO\nfrom shared.domain.models.post_to_publish import PostToPublish\n\n\nclass PostToPublishServiceInterface(ABC):\n\n    @abstractmethod\n    async def get_all_posts_to_publish(self) -> List[PostToPublish]:\n        ...\n\n    @abstractmethod\n    async def create_post_to_publish(self, post_to_publish: CreatePostToPublishDTO) -> UUID:\n        ...\n\n    @abstractmethod\n    async def get_post_to_publish(self, post_to_publish_id: UUID) -> PostToPublish:\n        ...\n\n    @abstractmethod\n    async def update_post_to_publish(self, post_to_publish_id: UUID, post_to_publish: UpdatePostToPublishDTO) -> None:\n        ...\n\n    @abstractmethod\n    async def delete_post_to_publish(self, post_to_publish_id: UUID) -> None:\n        ..."
  },
  {
    "path": "admin/backend/abstractions/services/__init__.py",
    "content": ""
  },
  {
    "path": "admin/backend/abstractions/services/chat.py",
    "content": "from abc import ABC, abstractmethod\n\nfrom shared.domain.models import Chat\n\n\nclass ChatServiceInterface(ABC):\n    @abstractmethod\n    async def get_chats(self) -> list[Chat]:\n        ...\n\n    @abstractmethod\n    async def create_chat_by_link(self, invite_link: str) -> Chat:\n        ...\n"
  },
  {
    "path": "admin/backend/abstractions/services/exceptions.py",
    "content": "class WrongCredentialsException(Exception):\n    ...\n\n\nclass InvalidTokensException(Exception):\n    ..."
  },
  {
    "path": "admin/backend/abstractions/services/analytics.py",
    "content": "from abc import ABC\nfrom typing import List, Optional\nfrom uuid import UUID\n\nfrom shared.domain.models.analytics_service import Service\n\n\nclass AnalyticsServiceServiceInterface(ABC):\n\n    async def get_all_services(self) -> List[Service]:\n        ...\n\n    async def get_available_services(self) -> Optional[List[Service]]:\n        ...\n\n    async def update_service_active_status(self, svc_id: UUID, new_status: bool) -> None:\n        ...\n"
  },
  {
    "path": "admin/backend/abstractions/services/gpt.py",
    "content": "from abc import ABC\nfrom uuid import UUID\n\n\nclass GPTServiceInterface(ABC):\n    openai_api_key: str\n\n    async def start_gpt_conversation(self, user_id: int):\n        ...\n\n    async def get_gpt_response(self, user_id: UUID, user_input: str):\n        ...\n\n    async def end_conversation(self, user_id: int):\n        ...\n\n    async def ask(self, instructions: str, input: str) -> str:\n        ...\n"
  },
  {
    "path": "admin/backend/abstractions/services/auth/service.py",
    "content": "from abc import ABC, abstractmethod\nfrom typing import Optional\nfrom uuid import UUID\n\nfrom domain.responses.auth import AuthTokens\n\n\nclass AuthServiceInterface(ABC):\n    @abstractmethod\n    async def get_user_id_from_jwt(self, token: str) -> UUID:\n        ...\n\n    @abstractmethod\n    async def create_token(self, init_data: str) -> AuthTokens:\n        ...\n\n    @abstractmethod\n    async def refresh_token(self, refresh_token: str) -> AuthTokens:\n        ...\n"
  },
  {
    "path": "admin/backend/abstractions/services/auth/__init__.py",
    "content": ""
  },
  {
    "path": "admin/backend/abstractions/services/auth/tokens.py",
    "content": "import logging\nfrom abc import ABC, abstractmethod\n\nfrom domain.responses.auth import AuthTokens\n\nlogger = logging.getLogger(__name__)\n\n\nclass TokenServiceInterface(ABC):\n    @abstractmethod\n    def get_token_payload(self, token: str) -> dict:\n        ...\n\n    @abstractmethod\n    def create_auth_token(self, user_id: str) -> AuthTokens:\n        ...\n"
  },
  {
    "path": "admin/backend/domain/__init__.py",
    "content": ""
  },
  {
    "path": "admin/backend/domain/dto/auth.py",
    "content": "from pydantic import BaseModel, SecretStr, field_serializer, Field\n\n\nclass Credentials(BaseModel):\n    username: str\n    password: str\n\n\nclass AuthTokens(BaseModel):\n    access_token: SecretStr = Field(..., serialization_alias='accessToken')\n    refresh_token: SecretStr = Field(..., serialization_alias='refreshToken')\n\n    @field_serializer('access_token', 'refresh_token')\n    def dump_secret(self, v):\n        return v.get_secret_value()\n"
  },
  {
    "path": "admin/backend/domain/dto/__init__.py",
    "content": ""
  },
  {
    "path": "admin/backend/domain/dto/сhat.py",
    "content": "from pydantic import BaseModel\n\n\nclass CreateChatRequest(BaseModel):\n    invite_link: str"
  },
  {
    "path": "admin/backend/domain/dto/base.py",
    "content": "from datetime import datetime\nfrom typing import Optional\nfrom uuid import UUID, uuid4\n\nfrom pydantic import BaseModel, Field\n\n\nclass CreateDTO(BaseModel):\n    id: UUID = Field(default_factory=uuid4)\n    created_at: datetime = Field(default_factory=datetime.now)\n    updated_at: datetime = Field(default_factory=datetime.now)\n\nclass UpdateDTO(BaseModel):\n    updated_at: Optional[datetime] = Field(default_factory=datetime.now)"
  },
  {
    "path": "admin/backend/domain/responses/auth.py",
    "content": "from pydantic import BaseModel, Field\n\n\nclass AuthTokens(BaseModel):\n    access_token: str\n    refresh_token: str\n"
  },
  {
    "path": "admin/backend/domain/models/abstract.py",
    "content": "from datetime import datetime\nfrom uuid import UUID\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    id: UUID\n    created_at: datetime\n    updated_at: datetime\n"
  },
  {
    "path": "admin/backend/domain/models/__init__.py",
    "content": ""
  },
  {
    "path": "admin/backend/domain/models/chat.py",
    "content": "from pydantic import BaseModel\n\n\nclass TelegramChatInfo(BaseModel):\n    id: int\n    title: str\n    members_count: int\n"
  },
  {
    "path": "admin/backend/domain/schemas/auth.py",
    "content": "from pydantic import BaseModel\n\n\nclass Credentials(BaseModel):\n    auth_code: str\n\nclass Tokens(BaseModel):\n    access_token: str\n"
  },
  {
    "path": "admin/backend/routes/__init__.py",
    "content": "from .api import router as api_router\n"
  },
  {
    "path": "admin/backend/routes/utils/__init__.py",
    "content": "from typing import Optional\nfrom uuid import UUID\n\nfrom fastapi import Request\n\n\ndef get_user_id_from_request(request: Request) -> Optional[UUID]:\n    return request.scope.get('x_user_id', None)\n"
  },
  {
    "path": "admin/backend/routes/requests/auth.py",
    "content": "from typing import Optional\nfrom uuid import UUID\n\nfrom pydantic import BaseModel\n\n\nclass TelegramAuthRequest(BaseModel):\n    initData: str\n    ref: Optional[UUID] = None\n"
  },
  {
    "path": "admin/backend/routes/requests/user.py",
    "content": "from pydantic import BaseModel\n\n\nclass VerifyAuthCodeRequest(BaseModel):\n    phone: str\n    code: str\n    password: str\n"
  },
  {
    "path": "admin/backend/routes/api/post.py",
    "content": "import json\nimport logging\nfrom typing import Optional, Annotated\nfrom uuid import UUID\n\nfrom fastapi import APIRouter, Form, UploadFile, File, Depends, HTTPException\nfrom shared.abstractions.services import UploadServiceInterface\nfrom shared.domain.dto import UpdatePostDTO, CreatePostDTO\nfrom shared.domain.dto.post_to_publish import MessageEntityDTO\n\nfrom dependencies.services.post import get_post_service\nfrom dependencies.services.upload import get_upload_service\nfrom forms.update_post_form import UpdatePostForm\n\nrouter = APIRouter(\n    prefix=\"/post\",\n    tags=[\"post\"],\n)\n\nlogger = logging.getLogger(__name__)\n\n\n@router.post('')\nasync def create_post(\n        name: str = Form(...),\n        text: str = Form(...),\n        html: str = Form(...),\n        entities: str = Form(...),\n        image: Optional[UploadFile] = File(None),\n        upload_service: UploadServiceInterface = Depends(get_upload_service),\n) -> UUID:\n    post_service = get_post_service()\n    image_path = None\n    if image is not None:\n        try:\n            extension = upload_service.get_extension(image.filename)\n            image_path = await upload_service.upload(image.file.read(), extension)\n        except Exception as e:\n            raise HTTPException(\n                status_code=500,\n                detail=\"Не удалось сохранить файл\"\n            ) from e\n    else:\n        logger.error(\"ATTENTION!!! IMAGE IS NONE\")\n\n    entities = [MessageEntityDTO.model_validate(e) for e in json.loads(entities)]\n\n    post = CreatePostDTO(\n        name=name,\n        text=text,\n        image_path=image_path,\n        html=html,\n        entities=entities,\n    )\n    return await post_service.create_post(post=post)\n\n\n@router.get('/all')\nasync def get_post():\n    post_service = get_post_service()\n    return await post_service.get_all_posts()\n\n\n@router.get('')\nasync def get_post(post_id: UUID):\n    post_service = get_post_service()\n    return await post_service.get_post(post_id=post_id)\n\n\n@router.patch('/{post_id}')\nasync def update_post(\n        post_id: UUID,\n        data: Annotated[UpdatePostForm, Form()],\n        upload_service: UploadServiceInterface = Depends(get_upload_service),\n):\n    post_service = get_post_service()\n\n    data_dump = data.model_dump(exclude_unset=True)\n\n    if data.image:\n        extension = upload_service.get_extension(data.image.filename)\n        image_path = await upload_service.upload(data.image.file.read(), extension)\n        data_dump[\"image_path\"] = image_path\n\n    if data.entities:\n        entities = [MessageEntityDTO.model_validate(e) for e in json.loads(data.entities)]\n        data_dump[\"entities\"] = entities\n\n    post_dto = UpdatePostDTO.model_validate(data_dump)\n\n    return await post_service.update_post(post_id=post_id, post=post_dto)\n\n\n@router.delete('/')\nasync def delete_post(post_id: UUID):\n    post_service = get_post_service()\n    return await post_service.delete_post(post_id=post_id)\n"
  },
  {
    "path": "admin/backend/routes/api/story.py",
    "content": "import logging\nfrom typing import Optional\nfrom uuid import UUID\n\nfrom fastapi import APIRouter, Form, UploadFile, File, Depends, HTTPException\nfrom shared.abstractions.services import UploadServiceInterface\nfrom shared.domain.dto.story import CreateStoryDTO, UpdateStoryDTO\n\nfrom dependencies.services.story import get_story_service\nfrom dependencies.services.upload import get_upload_service\n\nrouter = APIRouter(\n    prefix=\"/story\",\n    tags=[\"story\"],\n)\n\nlogger = logging.getLogger(__name__)\n\n\n@router.post('')\nasync def create_story(\n        name: str = Form(...),\n        text: str = Form(...),\n        image: Optional[UploadFile] = File(None),\n        upload_service: UploadServiceInterface = Depends(get_upload_service),\n) -> UUID:\n    story_service = get_story_service()\n    image_path = None\n    if image is not None:\n        try:\n            extension = upload_service.get_extension(image.filename)\n            image_path = await upload_service.upload(image.file.read(), extension)\n        except Exception as e:\n            raise HTTPException(\n                status_code=500,\n                detail=\"Не удалось сохранить файл\"\n            ) from e\n    else:\n        logger.error(\"ATTENTION!!! IMAGE IS NONE\")\n\n    story = CreateStoryDTO(\n        name=name,\n        text=text,\n        file_path=image_path,\n    )\n    return await story_service.create_story(story=story)\n\n\n@router.get('/all')\nasync def get_stories():\n    story_service = get_story_service()\n    return await story_service.get_all_stories()\n\n\n@router.get('')\nasync def get_story(story_id: UUID):\n    story_service = get_story_service()\n    return await story_service.get_story(story_id=story_id)\n\n\n@router.patch('')\nasync def update_story(story: UpdateStoryDTO, story_id: UUID):\n    story_service = get_story_service()\n    return await story_service.update_story(story_id=story_id, story=story)\n\n\n@router.delete('/')\nasync def delete_story(story_id: UUID):\n    story_service = get_story_service()\n    return await story_service.delete_story(story_id=story_id)\n"
  },
  {
    "path": "admin/backend/routes/api/user.py",
    "content": "import logging\nfrom uuid import UUID\n\nfrom fastapi import APIRouter, Request, HTTPException\nfrom shared.domain.dto import CreateUserDTO, UpdateUserDTO\nfrom shared.domain.models import User\nfrom shared.infrastructure.main_db import NoFreeProxiesException\n\nfrom dependencies.services.user import get_user_service\nfrom routes.requests.user import VerifyAuthCodeRequest\nfrom routes.utils import get_user_id_from_request\nfrom services.exceptions import UserHasNoProxyException\n\nrouter = APIRouter(\n    prefix=\"/users\",\n    tags=[\"users\"],\n)\n\nlogger = logging.getLogger(__name__)\n\n\n@router.post('')\nasync def create_user(user: CreateUserDTO) -> UUID:\n    user_service = get_user_service()\n    return await user_service.create_user(user=user)\n\n\n@router.get('/all')\nasync def get_users():\n    user_service = get_user_service()\n    return await user_service.get_all_users()\n\n\n@router.get('')\nasync def get_user(user_id: UUID):\n    user_service = get_user_service()\n    return await user_service.get_user(user_id=user_id)\n\n\n@router.patch('')\nasync def update_user(user: UpdateUserDTO, user_id: UUID):\n    user_service = get_user_service()\n    return await user_service.update_user(user_id=user_id, user=user)\n\n\n@router.delete('')\nasync def delete_user(user_id: UUID):\n    user_service = get_user_service()\n    return await user_service.delete_user(user_id=user_id)\n\n\n@router.get('/me')\nasync def get_me(\n        request: Request,\n) -> User:\n    user_service = get_user_service()\n    user_id = get_user_id_from_request(request)\n    return await user_service.get_user(user_id=user_id)\n\n\n@router.get(\"/code\")\nasync def send_auth_code(\n        phone: str,\n        request: Request,\n) -> None:\n    user_service = get_user_service()\n    user_id = get_user_id_from_request(request)\n\n    try:\n        await user_service.send_auth_code(phone=phone, user_id=user_id)\n    except NoFreeProxiesException:\n        raise HTTPException(\n            status_code=503,\n            detail=\"No free proxies found\",\n        )\n\n\n@router.post(\"/code\")\nasync def check_auth_code(\n        request: Request,\n        verify_request: VerifyAuthCodeRequest,\n) -> None:\n    user_service = get_user_service()\n    user_id = get_user_id_from_request(request)\n    try:\n        await user_service.get_session_string_for_user(\n            phone=verify_request.phone,\n            code=verify_request.code,\n            password=verify_request.password,\n            user_id=user_id,\n        )\n    except UserHasNoProxyException:\n        raise HTTPException(\n            status_code=409,\n            detail='User has no connected proxy',\n        )\n"
  },
  {
    "path": "admin/backend/routes/api/story_to_publish.py",
    "content": "from uuid import UUID\n\nfrom fastapi import APIRouter\nfrom shared.domain.dto.story_to_publish import CreateStoryToPublishDTO, UpdateStoryToPublishDTO\n\nfrom dependencies.services.story_to_publish import get_story_to_publish_service\n\nrouter = APIRouter(\n    prefix=\"/story-to-publish\",\n    tags=[\"story-to-publish\"],\n)\n#\n#\n# @router.post('')\n# async def create_story_to_publish(story_to_publish: CreateStoryToPublishDTO) -> UUID:\n#     story_to_publish_service = get_story_to_publish_service()\n#     return await story_to_publish_service.create_story_to_publish(story_to_publish=story_to_publish)\n#\n#\n# @router.get('/all')\n# async def get_story_to_publishs():\n#     story_to_publish_service = get_story_to_publish_service()\n#     return await story_to_publish_service.get_all_stories_to_publish()\n#\n#\n# @router.get('')\n# async def get_story_to_publish(story_to_publish_id: UUID):\n#     story_to_publish_service = get_story_to_publish_service()\n#     return await story_to_publish_service.get_story_to_publish(story_to_publish_id=story_to_publish_id)\n#\n#\n# @router.patch('')\n# async def update_story_to_publish(story_to_publish: UpdateStoryToPublishDTO, story_to_publish_id: UUID):\n#     story_to_publish_service = get_story_to_publish_service()\n#     return await story_to_publish_service.update_story_to_publish(story_to_publish_id=story_to_publish_id,\n#                                                                   story_to_publish=story_to_publish)\n#\n#\n# @router.delete('/')\n# async def delete_story_to_publish(story_to_publish_id: UUID):\n#     story_to_publish_service = get_story_to_publish_service()\n#     return await story_to_publish_service.delete_story_to_publish(story_to_publish_id=story_to_publish_id)\n"
  },
  {
    "path": "admin/backend/routes/api/upload.py",
    "content": "import logging\n\nfrom fastapi import APIRouter\nfrom starlette.responses import FileResponse\n\nfrom dependencies.services.upload import get_upload_service\n\nrouter = APIRouter(\n    prefix=\"/upload\",\n    tags=[\"upload\"],\n)\n\nlogger = logging.getLogger(__name__)\n\n\n@router.get('/{filename}')\nasync def get_file(\n        filename: str,\n) -> FileResponse:\n    upload_service = get_upload_service()\n\n    file_path = upload_service.get_file_path(filename)\n\n    return FileResponse(file_path)\n"
  },
  {
    "path": "admin/backend/routes/api/emoji.py",
    "content": "from typing import List\n\nfrom fastapi import APIRouter\nfrom shared.dependencies.services.emoji import get_emoji_service\nfrom shared.domain.models.emoji import Emoji\n\nrouter = APIRouter(\n    prefix=\"/emoji\",\n    tags=[\"emoji\"]\n)\n\n\n@router.get(\"\")\nasync def list_emojis() -> List[Emoji]:\n    emoji_service = get_emoji_service()\n    return await emoji_service.get_all_emojis()\n"
  },
  {
    "path": "admin/backend/routes/api/post_to_publish.py",
    "content": "from uuid import UUID\n\nfrom fastapi import APIRouter\nfrom shared.domain.dto.post_to_publish import CreatePostToPublishDTO, UpdatePostToPublishDTO\n\nfrom dependencies.services.post_to_publish import get_post_to_publish_service\n\nfrom shared.domain.models import PostToPublish\n\nrouter = APIRouter(\n    prefix=\"/post-to-publish\",\n    tags=[\"post-to-publish\"],\n)\n\n\n@router.post('')\nasync def create_post_to_publish(post_to_publish: CreatePostToPublishDTO) -> UUID:\n    post_to_publish_service = get_post_to_publish_service()\n    return await post_to_publish_service.create_post_to_publish(post_to_publish=post_to_publish)\n\n\n@router.get('/all')\nasync def get_posts_to_publish() -> list[PostToPublish]:\n    post_to_publish_service = get_post_to_publish_service()\n    return await post_to_publish_service.get_all_posts_to_publish()\n\n\n@router.get('')\nasync def get_post_to_publish(\n        post_to_publish_id: UUID,\n) -> PostToPublish:\n    post_to_publish_service = get_post_to_publish_service()\n    return await post_to_publish_service.get_post_to_publish(post_to_publish_id=post_to_publish_id)\n\n\n@router.patch('/{post_to_publish_id}')\nasync def update_post_to_publish(post_to_publish: UpdatePostToPublishDTO, post_to_publish_id: UUID):\n    post_to_publish_service = get_post_to_publish_service()\n    return await post_to_publish_service.update_post_to_publish(post_to_publish_id=post_to_publish_id,\n                                                                post_to_publish=post_to_publish)\n\n@router.delete('')\nasync def delete_post_to_publish(post_to_publish_id: UUID):\n    post_to_publish_service = get_post_to_publish_service()\n    return await post_to_publish_service.delete_post_to_publish(post_to_publish_id=post_to_publish_id)\n"
  },
  {
    "path": "admin/backend/routes/api/__init__.py",
    "content": "from fastapi import APIRouter\n\nfrom .user import router as user_router\nfrom .post import router as post_router\nfrom .story import router as story_router\nfrom .story_to_publish import router as story_to_publish_router\nfrom .post_to_publish import router as post_to_publish_router\nfrom .auth import router as auth_router\nfrom .chat import router as chat_router\nfrom .emoji import router as emoji_router\nfrom .upload import router as upload_router\n\nrouter = APIRouter(\n    prefix=\"/api\",\n)\n\nrouter.include_router(user_router)\nrouter.include_router(post_router)\nrouter.include_router(story_router)\nrouter.include_router(story_to_publish_router)\nrouter.include_router(post_to_publish_router)\nrouter.include_router(auth_router)\nrouter.include_router(chat_router)\nrouter.include_router(emoji_router)\nrouter.include_router(upload_router)\n"
  },
  {
    "path": "admin/backend/routes/api/chat.py",
    "content": "import logging\n\nfrom fastapi import APIRouter, HTTPException, status\nfrom shared.domain.models import Chat\nfrom shared.domain.requests.chat import CreateChatRequest\n\nfrom dependencies.services.chat import get_chat_service\nfrom services.exceptions import ChatAlreadyExistsError, InvalidInviteLinkError\n\nrouter = APIRouter(\n    prefix=\"/chat\",\n    tags=[\"chat\"],\n)\n\nlogger = logging.getLogger(__name__)\n\n\n@router.get('')\nasync def get_chats() -> list[Chat]:\n    chat_service = get_chat_service()\n    return await chat_service.get_chats()\n\n\n@router.post(\"\")\nasync def create_chat(request: CreateChatRequest) -> Chat:\n    \"\"\"\n    Создаёт новую запись чата по invite_link.\n    \"\"\"\n    chat_service = get_chat_service()\n    try:\n        new_chat_id = await chat_service.create_chat_by_link(request.invite_link)\n        return new_chat_id\n    except ChatAlreadyExistsError:\n        # если чат с таким invite_link уже есть\n        raise HTTPException(\n            status_code=status.HTTP_409_CONFLICT,\n            detail=\"Chat with this invite_link already exists\"\n        )\n    except InvalidInviteLinkError:\n        # если ссылка неверная\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Invalid invite link\"\n        )\n    except Exception as e:\n        # общий catch-all на всякий случай\n        logger.exception(\"Error creating chat\")\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Internal server error\"\n        )\n"
  },
  {
    "path": "admin/backend/routes/api/auth/__init__.py",
    "content": "from domain.schemas.auth import Credentials\nfrom fastapi import APIRouter, Depends\nfrom forms.auth_code_form import auth_code_form\nfrom starlette.responses import JSONResponse\n\nfrom abstractions.services.auth.service import AuthServiceInterface\nfrom abstractions.services.exceptions import WrongCredentialsException\nfrom dependencies.services.auth import get_auth_service\nfrom routes.requests.auth import TelegramAuthRequest\n\nrouter = APIRouter(\n    prefix=\"/auth\",\n    tags=[\"Auth\"],\n)\n\n# templates = Jinja2Templates(directory='templates')\n\n@router.post(\"/telegram\")\nasync def telegram_auth(payload: TelegramAuthRequest):\n    auth_service = get_auth_service()\n\n    tokens = await auth_service.create_token(init_data=payload.initData)\n\n    return tokens\n\n\n@router.post(\"\")\nasync def validate_auth_code_backend(\n        credentials: Credentials = Depends(auth_code_form),\n        auth_service: AuthServiceInterface = Depends(get_auth_service),\n) -> JSONResponse:\n    try:\n        tokens = await auth_service.create_token(credentials)\n        response = JSONResponse(content={\"status\": \"ok\"}, status_code=200)\n        response.set_cookie(key=\"access_token\", value=tokens.access_token)\n        # response.set_cookie(key=\"refresh_token\", value=tokens.refresh_token)\n        return response\n    except WrongCredentialsException:\n        return JSONResponse(content={\"status\": \"error\", \"message\": \"Wrong credentials\"}, status_code=400)\n"
  },
  {
    "path": "admin/backend/services/post.py",
    "content": "from dataclasses import dataclass\nfrom typing import List\nfrom uuid import UUID\n\nfrom shared.abstractions.repositories import PostRepositoryInterface\nfrom shared.domain.dto import CreatePostDTO, UpdatePostDTO\nfrom shared.domain.models import Post\n\nfrom abstractions.services.post import PostServiceInterface\nfrom shared.abstractions.services import UploadServiceInterface\n\n\n@dataclass\nclass PostService(PostServiceInterface):\n    post_repository: PostRepositoryInterface\n    upload_service: UploadServiceInterface\n\n    async def get_all_posts(self) -> List[Post]:\n        return await self.post_repository.get_all()\n\n    async def create_post(self, post: CreatePostDTO) -> UUID:\n        return await self.post_repository.create(post)\n\n    async def get_post(self, post_id: UUID) -> Post:\n        post = await self.post_repository.get(post_id)\n\n        file_path = self.upload_service.get_file_url(post.image_path)\n\n        post.image_path = file_path\n        return post\n\n    async def update_post(self, post_id: UUID, post: UpdatePostDTO) -> None:\n        return await self.post_repository.update(post_id, post)\n\n    async def delete_post(self, post_id: UUID) -> None:\n        return await self.post_repository.delete(post_id)\n"
  },
  {
    "path": "admin/backend/services/story.py",
    "content": "from dataclasses import dataclass\nfrom typing import List\nfrom uuid import UUID\n\nfrom shared.abstractions.repositories.story import StoryRepositoryInterface\nfrom shared.domain.dto.story import CreateStoryDTO, UpdateStoryDTO\nfrom shared.domain.models.story import Story\n\nfrom abstractions.services.story import StoryServiceInterface\n\n\n@dataclass\nclass StoryService(StoryServiceInterface):\n    story_repository: StoryRepositoryInterface\n\n    async def get_all_stories(self) -> List[Story]:\n        return await self.story_repository.get_all()\n\n    async def create_story(self, story: CreateStoryDTO) -> UUID:\n        return await self.story_repository.create(story)\n\n    async def get_story(self, story_id: UUID) -> Story:   # todo: image path\n        return await self.story_repository.get(story_id)\n\n    async def update_story(self, story_id: UUID, story: UpdateStoryDTO) -> None:\n        return await self.story_repository.update(story_id, story)\n\n    async def delete_story(self, story_id: UUID) -> None:\n        return await self.story_repository.delete(story_id)\n"
  },
  {
    "path": "admin/backend/services/user.py",
    "content": "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom uuid import UUID\n\nfrom shared.abstractions.repositories import UserRepositoryInterface, ProxyRepositoryInterface\nfrom shared.domain.dto import CreateUserDTO, UpdateUserDTO\nfrom shared.domain.models import User\nfrom shared.infrastructure.main_db import NoFreeProxiesException\n\nfrom abstractions.services.telegram import TelegramServiceInterface\nfrom abstractions.services.user import UserServiceInterface\nfrom services.exceptions import UserHasNoProxyException\n\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass UserService(UserServiceInterface):\n    user_repository: UserRepositoryInterface\n    telegram_service: TelegramServiceInterface\n    proxy_repository: ProxyRepositoryInterface\n\n\n    async def get_all_users(self) -> List[User]:\n        return await self.user_repository.get_all()\n\n    async def create_user(self, user: CreateUserDTO) -> UUID:\n        return await self.user_repository.create(user)\n\n    async def get_user(self, user_id: UUID) -> User:\n        return await self.user_repository.get(user_id)\n\n    async def get_user_by_telegram_id(self, telegram_id: int) -> User:\n        return await self.user_repository.get_by_telegram_id(telegram_id)\n\n    async def update_user(self, user_id: UUID, user: UpdateUserDTO) -> None:\n        return await self.user_repository.update(user_id, user)\n\n    async def delete_user(self, user_id: UUID) -> None:\n        return await self.user_repository.delete(user_id)\n\n    async def ensure_user(self, dto: CreateUserDTO) -> User:\n        logger.info(f\"Ensuring user {dto.telegram_id}\")\n        user = await self.user_repository.get_by_telegram_id(dto.telegram_id)\n        logger.info(f\"User {dto.telegram_id} is {user}\")\n        if not user:\n            user_id = await self.create_user(dto)\n            user = await self.user_repository.get(user_id)\n            logger.info(f\"User {dto.telegram_id} was created just now\")\n\n        return user\n\n    async def send_auth_code(self, user_id: UUID, phone: str) -> None:\n        try:\n            proxy = await self.proxy_repository.get_available_proxy()\n        except NoFreeProxiesException:\n            logger.error(f\"No free proxies available\")\n            raise NoFreeProxiesException\n\n        await self.user_repository.set_proxy(user_id, proxy.id)\n        await self.telegram_service.send_auth_code(phone, proxy=proxy.proxy_string)\n\n    async def get_session_string_for_user(\n            self,\n            phone: str,\n            code: str,\n            user_id: UUID,\n            password: Optional[str] = None,\n    ) -> None:\n        user = await self.user_repository.get(user_id)\n        if not user.proxy:\n            raise UserHasNoProxyException(f\"User {user_id} has no connected proxy\")\n\n        session_string = await self.telegram_service.get_session_string(\n            phone=phone,\n            code=code,\n            proxy=user.proxy.proxy_string,\n            password=password,\n        )\n        update_dto = UpdateUserDTO(\n            session_string=session_string,\n        )\n\n        await self.update_user(user_id, update_dto)\n\n"
  },
  {
    "path": "admin/backend/services/story_to_publish.py",
    "content": "from dataclasses import dataclass\nfrom typing import List\nfrom uuid import UUID\n\nfrom shared.abstractions.repositories.story_to_publish import StoryToPublishRepositoryInterface\nfrom shared.domain.dto.story_to_publish import CreateStoryToPublishDTO, UpdateStoryToPublishDTO\nfrom shared.domain.models.story import Story\nfrom shared.infrastructure.main_db.repositories.story_to_publish import StoryToPublishRepository\n\nfrom abstractions.services.story_to_publish import StoryToPublishServiceInterface\n\nfrom shared.domain.models import StoryToPublish\n\n\n@dataclass\nclass StoryToPublishService(StoryToPublishServiceInterface):\n    story_to_publish_repository: StoryToPublishRepositoryInterface\n\n    async def get_all_stories_to_publish(self) -> List[Story]:\n        return await self.story_to_publish_repository.get_all()\n\n    async def create_story_to_publish(self, story_to_publish: CreateStoryToPublishDTO) -> UUID:\n        return await self.story_to_publish_repository.create(story_to_publish)\n\n    async def get_story_to_publish(self, story_to_publish_id: UUID) -> StoryToPublish:   # todo: image path\n        return await self.story_to_publish_repository.get(story_to_publish_id)\n\n    async def update_story_to_publish(self, story_to_publish_id: UUID,\n                                      story_to_publish: UpdateStoryToPublishDTO) -> None:\n        return await self.story_to_publish_repository.update(story_to_publish_id, story_to_publish)\n\n    async def delete_story_to_publish(self, story_to_publish_id: UUID) -> None:\n        return await self.story_to_publish_repository.delete(story_to_publish_id)"
  },
  {
    "path": "admin/backend/services/telegram.py",
    "content": "import logging\nimport re\nfrom contextlib import asynccontextmanager\nfrom dataclasses import dataclass, field\nfrom datetime import datetime\nfrom typing import AsyncGenerator, Optional, Annotated\nfrom urllib.request import proxy_bypass\n\nfrom shared.abstractions.singleton import Singleton\nfrom telethon import TelegramClient, types\nfrom telethon.errors import SessionPasswordNeededError\nfrom telethon.sessions import StringSession\nfrom telethon.utils import get_peer_id\n\nfrom abstractions.services.telegram import TelegramServiceInterface\nfrom domain.models.chat import TelegramChatInfo\nfrom services.exceptions import UnableToGetChatException, PasswordNeededException\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass TelegramService(\n    TelegramServiceInterface,\n    Singleton,\n):\n    api_id: int\n    api_hash: str\n    service_session_string: str\n    proxy: str\n    service_bot_token: str\n    use_bot_for_service: bool = False\n\n    phone_code_hashes: dict[  # todo: possible memory leak, needs interval cleaning\n        Annotated[str, 'phone'],\n        tuple[\n            Annotated[str, 'phone code hash'],\n            Annotated[datetime, 'requested at'],\n        ]\n    ] = field(default_factory=dict)\n\n    # async def get_chat_info(self, invite_link: str) -> TelegramChatInfo:\n    #     try:\n    #         async with self.get_service_client() as client:\n    #             chat: types.Chat = await client.get_entity(invite_link)\n    #             chat_id = get_peer_id(chat)\n    #             return TelegramChatInfo(\n    #                 id=chat_id,\n    #                 title=chat.title,\n    #                 members_count=chat.participants_count,\n    #             )\n    #\n    #     except Exception as e:\n    #         logger.error(\"Не удалось получить title для %s: %s\", invite_link, e, exc_info=True)\n    #         raise UnableToGetChatException\n\n    async def get_chat_info(self, invite_link: str) -> TelegramChatInfo:\n        try:\n            async with self.get_service_client() as client:\n                # Получаем любой Peer (Chat, Channel или User)\n                entity = await client.get_entity(invite_link)\n                chat_id = get_peer_id(entity)\n\n                # Title: для чата/канала — .title, для юзера — .username\n                if isinstance(entity, (types.Channel, types.Chat)):\n                    title = entity.title or \"\"\n                else:\n                    title = getattr(entity, \"username\", \"\") or \"\"\n\n                # Попытка взять participants_count, и если он None, сделать fallback\n                members = getattr(entity, \"participants_count\", None)\n                if members is None:\n                    try:\n                        # получаем реальный список участников (работает только для публичных чатов/каналов)\n                        participants = await client.get_participants(entity)\n                        members = len(participants)\n                    except Exception:\n                        members = 0\n\n                return TelegramChatInfo(\n                    id=chat_id,\n                    title=title,\n                    members_count=members,\n                )\n\n        except Exception as e:\n            logger.error(\"Не удалось получить информацию по %s: %s\", invite_link, e, exc_info=True)\n            raise UnableToGetChatException\n\n    async def send_auth_code(self, phone: str, proxy: Optional[str] = None) -> None:\n        client = TelegramClient(\n            phone,\n            self.api_id,\n            self.api_hash,\n            proxy=self.parse_proxy(proxy) if proxy else None,\n        )\n        await client.connect()\n\n        request = await client.send_code_request(phone)\n        self.phone_code_hashes[phone] = (request.phone_code_hash, datetime.now())\n        logger.info(self.phone_code_hashes)\n\n    async def get_session_string(\n            self,\n            phone: str,\n            code: str,\n            proxy: Optional[str] = None,\n            password: Optional[str] = None,\n    ) -> str:\n        logger.info(self.phone_code_hashes)\n        client = TelegramClient(\n            session=phone,\n            api_id=self.api_id,\n            api_hash=self.api_hash,\n            proxy=self.parse_proxy(proxy) if proxy else None,\n        )\n        await client.connect()\n\n        phone_code_hash = self.phone_code_hashes[phone][0]\n        try:\n            try:\n                await client.sign_in(phone, code, phone_code_hash=phone_code_hash)\n            except SessionPasswordNeededError:\n                await client.sign_in(password=password)\n\n            del self.phone_code_hashes[phone]\n        except SessionPasswordNeededError:\n            del self.phone_code_hashes[phone]\n            raise PasswordNeededException\n\n        string = StringSession.save(client.session)\n        return string\n\n    # @asynccontextmanager\n    # async def get_service_client(self) -> AsyncGenerator[TelegramClient, None]:\n    #     if self.use_bot_for_service:\n    #         client = TelegramClient('bot', self.api_id, self.api_hash)\n    #         await client.connect()\n    #         logger.info(\"self.service_bot_token\")\n    #         logger.info(self.service_bot_token)\n    #         await client.start(bot_token=self.service_bot_token) # noqa\n    #         logger.info(await client.get_me())\n    #         # logger.info(await client.get_dialogs())\n    #\n    #         yield client\n    #\n    #         await client.disconnect()\n    #         return\n    #\n    #     session = StringSession(self.service_session_string)\n    #     async with TelegramClient(session, self.api_id, self.api_hash, proxy=self.parse_proxy(self.proxy)) as client:\n    #         await client.start()\n    #\n    #         yield client\n\n    @asynccontextmanager\n    async def get_service_client(self) -> AsyncGenerator[TelegramClient, None]:\n        if self.use_bot_for_service:\n            # In-memory session, чтобы не создавать sqlite-файл и не блокировать БД\n            bot_session = StringSession()\n            client = TelegramClient(\n                bot_session,\n                self.api_id,\n                self.api_hash,\n                proxy=self.parse_proxy(self.proxy) if self.proxy else None\n            )\n\n            # start() сам подключится и залогинится как бот\n            await client.start(bot_token=self.service_bot_token) #noqa\n            logger.info(await client.get_me())\n\n            yield client\n\n            await client.disconnect()\n            return\n\n        # Обычный пользовательский режим через сохранённую строку сессии\n        user_session = StringSession(self.service_session_string)\n        async with TelegramClient(\n            user_session,\n            self.api_id,\n            self.api_hash,\n            proxy=self.parse_proxy(self.proxy) if self.proxy else None\n        ) as client:\n            await client.start()\n            yield client\n    @staticmethod\n    def parse_proxy(proxy_string: Optional[str] = None) -> Optional[tuple]:\n        if not proxy_string:\n            return\n\n        # Regex to parse the proxy string\n        pattern = re.compile(\n            r\"^(?P<protocol>http|socks5|socks4)://(?P<username>.+?):(?P<password>.+?)@(?P<host>.+?):(?P<port>\\d+)$\"\n        )\n        match = pattern.match(proxy_string)\n        if not match:\n            raise ValueError(\"Invalid proxy format\")\n\n        # Extracting components\n        components = match.groupdict()\n        protocol = components[\"protocol\"]\n        username = components[\"username\"]\n        password = components[\"password\"]\n        host = components[\"host\"]\n        port = int(components[\"port\"])\n\n        # Map protocol to PySocks format\n        proxy_type = {\n            \"http\": \"HTTP\",\n            \"socks5\": \"SOCKS5\",\n            \"socks4\": \"SOCKS4\"\n        }.get(protocol, None)\n\n        if not proxy_type:\n            raise ValueError(\"Unsupported proxy protocol\")\n\n        # PySocks/Telethon-compatible format\n        proxy = (proxy_type, host, port, True, username, password)\n        print(proxy)\n        return proxy\n"
  },
  {
    "path": "admin/backend/services/post_to_publish.py",
    "content": "from dataclasses import dataclass\nfrom typing import List\nfrom uuid import UUID\n\nfrom shared.abstractions.repositories.post_to_publish import PostToPublishRepositoryInterface\nfrom shared.domain.dto.post_to_publish import CreatePostToPublishDTO, UpdatePostToPublishDTO\nfrom shared.domain.models.post_to_publish import PostToPublish\n\nfrom abstractions.services.post_to_publish import PostToPublishServiceInterface\nfrom shared.abstractions.services import UploadServiceInterface\n\n\n@dataclass\nclass PostToPublishService(PostToPublishServiceInterface):\n    post_to_publish_repository: PostToPublishRepositoryInterface\n    upload_service: UploadServiceInterface\n\n    async def get_all_posts_to_publish(self) -> List[PostToPublish]:\n        return await self.post_to_publish_repository.get_all()\n\n    async def create_post_to_publish(self, post_to_publish: CreatePostToPublishDTO) -> UUID:\n        return await self.post_to_publish_repository.create(post_to_publish)\n\n    async def get_post_to_publish(self, post_to_publish_id: UUID) -> PostToPublish:\n        post = await self.post_to_publish_repository.get(post_to_publish_id)\n        file_path = self.upload_service.get_file_url(post.post.image_path)\n\n        post.post.image_path = file_path\n        return post\n\n    async def update_post_to_publish(self, post_to_publish_id: UUID, post_to_publish: UpdatePostToPublishDTO) -> None:\n        return await self.post_to_publish_repository.update(post_to_publish_id, post_to_publish)\n\n    async def delete_post_to_publish(self, post_to_publish_id: UUID) -> None:\n        return await self.post_to_publish_repository.delete(post_to_publish_id)\n"
  },
  {
    "path": "admin/backend/services/__init__.py",
    "content": ""
  },
  {
    "path": "admin/backend/services/chat.py",
    "content": "import logging\nimport re\nfrom dataclasses import dataclass\nfrom uuid import UUID\n\nfrom shared.abstractions.repositories import ChatRepositoryInterface\nfrom shared.domain.dto import CreateChatDTO\nfrom shared.domain.models import Chat\n\nfrom abstractions.services.chat import ChatServiceInterface\nfrom abstractions.services.telegram import TelegramServiceInterface\nfrom services.exceptions import InvalidInviteLinkError, ChatAlreadyExistsError\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass ChatService(ChatServiceInterface):\n    chats_repository: ChatRepositoryInterface\n    telegram_service: TelegramServiceInterface\n\n    async def get_chats(self) -> list[Chat]:\n        return await self.chats_repository.get_all()\n\n    async def create_chat_by_link(self, invite_link: str) -> Chat:\n        \"\"\"\n        Проверяет invite_link, запрашивает у репозитория дубликаты,\n        резолвит информацию о чате и сохраняет новую запись.\n        \"\"\"\n        link = invite_link.strip()\n\n        # 1. Базовая валидация формата ссылки\n        pattern = r\"^(https?://)?t\\.me/[\\w\\-\\+]+$\"\n        if not re.match(pattern, link):\n            raise InvalidInviteLinkError(f\"Неверный формат invite_link: {link}\")\n\n        # 2. Проверяем, что такого чата ещё нет\n        existing = await self.chats_repository.get_by_invite_link(link)\n        if existing:\n            raise ChatAlreadyExistsError(f\"Чат уже зарегистрирован: {link}\")\n\n        # 3. Получаем информацию о чате из тг\n        chat_info = await self.telegram_service.get_chat_info(invite_link)\n\n        # 4. Собираем доменную модель и сохраняем\n        new_chat = CreateChatDTO(\n            name=chat_info.title,\n            chat_id=int(chat_info.id),\n            invite_link=link\n        )\n        new_chat_id = await self.chats_repository.create(new_chat)\n        return await self.chats_repository.get(new_chat_id)\n"
  },
  {
    "path": "admin/backend/services/exceptions.py",
    "content": "class InvalidBookingException(Exception):\n    ...\n\n\nclass PermissionException(Exception):\n    ...\n\n\nclass BannedUserException(Exception):\n    ...\n\n\nclass ChatAlreadyExistsError(Exception):\n    \"\"\"Выбрасывается, если чат с таким invite_link уже существует.\"\"\"\n    pass\n\n\nclass InvalidInviteLinkError(Exception):\n    \"\"\"Выбрасывается, если строка invite_link не соответствует ожидаемому формату.\"\"\"\n    pass\n\n\nclass UnableToGetChatException(Exception):\n    ...\n\n\nclass PasswordNeededException(Exception):\n    ...\n\n\nclass UserHasNoProxyException(Exception):\n    ...\n"
  },
  {
    "path": "admin/backend/services/auth/service.py",
    "content": "import hashlib\nimport hmac\nimport logging\nimport time\nimport json\nfrom typing import Optional\nfrom urllib.parse import parse_qs\nfrom dataclasses import dataclass\nfrom uuid import UUID\n\nfrom shared.domain.dto import CreateUserDTO\nfrom shared.domain.enums import UserRole\nfrom shared.infrastructure.sqlalchemy import NotFoundException\n\nfrom abstractions.services.auth.service import AuthServiceInterface\nfrom abstractions.services.auth.tokens import TokenServiceInterface\nfrom abstractions.services.user import UserServiceInterface\nfrom domain.responses.auth import AuthTokens\nfrom services.auth.exceptions import ExpiredDataException, InvalidTokenException\nfrom services.exceptions import BannedUserException\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass AuthService(AuthServiceInterface):\n    bot_token: str\n    token_service: TokenServiceInterface\n    user_service: UserServiceInterface\n\n    async def get_user_id_from_jwt(self, token: str) -> UUID:\n        try:\n            payload = self.token_service.get_token_payload(token=token)\n            user_id: str | None = payload.get('sub', None)\n            if not user_id:\n                raise InvalidTokenException()\n\n            user = await self.user_service.get_user(UUID(user_id))  # todo: pk type\n\n            return user.id\n        except (InvalidTokenException, NotFoundException):\n            raise\n\n    async def create_token(self, init_data: str) -> AuthTokens:\n        \"\"\"Verifies Telegram Mini App auth data properly.\"\"\"\n        # Parse initData properly (decode URL params)\n        data_dict = {k: v[0] for k, v in parse_qs(init_data).items()}\n\n        # Extract hash separately\n        received_hash = data_dict.pop(\"hash\", None)\n        if not received_hash:\n            raise InvalidTokenException(\"Missing hash in init data\")\n\n        # Check expiration\n        auth_date = int(data_dict.get(\"auth_date\", \"0\"))\n        if time.time() - auth_date > 86400:  # Expire after 1 day\n            raise ExpiredDataException()\n\n        # Step 1: Sort the key-value pairs in alphabetical order\n        sorted_data_string = \"\\n\".join(f\"{k}={v}\" for k, v in sorted(data_dict.items()))\n\n        # Step 2: Create HMAC-SHA256 signature of the bot token using 'WebAppData' as key\n        secret_key = hmac.new(b\"WebAppData\", self.bot_token.encode(), hashlib.sha256).digest()\n\n        # Step 3: Create final HMAC-SHA256 signature using the previous step result as the key\n        computed_hash = hmac.new(secret_key, sorted_data_string.encode(), hashlib.sha256).hexdigest()\n\n        logger.info(f\"Computed Hash: {computed_hash}, Received Hash: {received_hash}, InitData: {init_data}\")\n\n        # Step 4: Validate hash\n        if computed_hash != received_hash:\n            raise InvalidTokenException(\"Invalid init data hash\")\n\n        # Extract Telegram User ID\n        user_data = json.loads(data_dict.get(\"user\", \"{}\"))\n        telegram_user_id = int(user_data.get(\"id\", 0))\n        username = user_data.get(\"username\", None)\n        first_name = user_data.get(\"first_name\", None)\n        last_name = user_data.get(\"last_name\", None)\n        language_code = user_data.get(\"language_code\", None)\n\n        # Ensure user exists\n        user_dto = CreateUserDTO(\n            telegram_id=telegram_user_id,\n            telegram_username=username,\n            telegram_first_name=first_name,\n            telegram_last_name=last_name,\n            telegram_language_code=language_code,\n            role=UserRole.MANAGER,\n            assistant_enabled=False,\n        )\n        user = await self.user_service.ensure_user(user_dto)\n\n        # Generate access & refresh tokens\n        return self.token_service.create_auth_token(user_id=str(user.id))\n\n    async def refresh_token(self, refresh_token: str) -> AuthTokens:\n        try:\n            old_claims = self.token_service.get_token_payload(refresh_token)\n            user_id = old_claims['sub']\n            await self.user_service.get_user(user_id)\n\n            return self.token_service.create_auth_token(user_id)\n        except (InvalidTokenException, NotFoundException):\n            raise\n"
  },
  {
    "path": "admin/backend/services/auth/__init__.py",
    "content": ""
  },
  {
    "path": "admin/backend/services/auth/tokens.py",
    "content": "import logging\nfrom dataclasses import dataclass\nfrom datetime import datetime, timedelta, UTC\n\nfrom jwt import (\n    decode, encode,\n    ExpiredSignatureError as ExpiredSignatureJWTError,\n    InvalidTokenError as InvalidTokenJWTError\n)\n\nfrom abstractions.services.auth.tokens import TokenServiceInterface\nfrom domain.responses.auth import AuthTokens\nfrom services.auth.exceptions import InvalidTokenException, ExpiredTokenException\nfrom shared.settings import JwtSettings\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass TokenService(TokenServiceInterface):\n    jwt_settings: JwtSettings\n\n    def create_auth_token(self, user_id: str) -> AuthTokens:\n        access_claims = {\n            'sub': user_id,\n            'exp': datetime.now(tz=UTC) + timedelta(seconds=self.jwt_settings.access_expire),\n        }\n\n        refresh_claims = {\n            'sub': user_id,\n            'exp': datetime.now(tz=UTC) + timedelta(seconds=self.jwt_settings.refresh_expire),\n        }\n\n        return AuthTokens(\n            access_token=self._create_token(**access_claims),\n            refresh_token=self._create_token(**refresh_claims),\n        )\n\n    def _create_token(self, **claims) -> str:\n        if 'iss' not in claims:\n            claims[\"iss\"] = self.jwt_settings.issuer\n\n        if 'aud' not in claims:\n            claims[\"aud\"] = self.jwt_settings.audience\n\n        token = encode(\n            payload=claims,\n            key=self.jwt_settings.secret_key.get_secret_value(),\n            algorithm=\"HS256\"\n        )\n\n        return token\n\n    def get_token_payload(self, token: str) -> dict:\n        try:\n            claims = decode(\n                token,\n                self.jwt_settings.secret_key.get_secret_value(),\n                algorithms=[\"HS256\"],\n                issuer=self.jwt_settings.issuer,\n                audience=self.jwt_settings.audience,\n                options={\n                    \"verify_exp\": True\n                },\n            )\n\n            return claims\n        except ExpiredSignatureJWTError as ex:\n            logger.error(\"Token has expired: %s\", token)\n            raise ExpiredTokenException from ex\n        except InvalidTokenJWTError as ex:\n            logger.error(\"Invalid token: %s. Error: %s\", token, ex)\n            raise InvalidTokenException from ex\n"
  },
  {
    "path": "admin/backend/services/auth/exceptions.py",
    "content": "class ExpiredDataException(Exception):\n    ...\n\n\nclass InvalidTokenException(Exception):\n    ...\n\n\nclass ExpiredTokenException(Exception):\n    ...\n"
  },
  {
    "path": "shared/__init__.py",
    "content": ""
  },
  {
    "path": "shared/src/__init__.py",
    "content": ""
  },
  {
    "path": "shared/src/shared/config.py",
    "content": "MAIN_DB_URL = \"postgresql+asyncpg://postgres:postgres@localhost:5432/postgres\"\n\ndef set_main_db_url(url: str) -> None:\n    global MAIN_DB_URL\n    MAIN_DB_URL = url\n\ndef get_main_db_url() -> str:\n    return MAIN_DB_URL\n"
  },
  {
    "path": "shared/src/shared/__init__.py",
    "content": ""
  },
  {
    "path": "shared/src/shared/settings/abstract.py",
    "content": "from pathlib import Path\nfrom typing import Type\n\nfrom pydantic_settings import (\n    BaseSettings,\n    SettingsConfigDict,\n    PydanticBaseSettingsSource,\n)\n\nfrom .merged_source import MergedSettingsSource\n\n\nclass AbstractSettings(BaseSettings):\n    model_config = SettingsConfigDict(\n        extra=\"ignore\",\n        json_file=Path(__file__).parent.parent / \"settings.json\",\n        json_file_encoding=\"utf-8\",\n    )\n\n    @classmethod\n    def settings_customise_sources(\n            cls,\n            settings_cls: Type[BaseSettings],\n            init_settings: PydanticBaseSettingsSource,\n            env_settings: PydanticBaseSettingsSource,\n            dotenv_settings: PydanticBaseSettingsSource,\n            file_secret_settings: PydanticBaseSettingsSource,\n    ) -> tuple[PydanticBaseSettingsSource, ...]:\n        return (\n            MergedSettingsSource(\n                settings_cls,\n                init_settings,\n                env_settings,\n                dotenv_settings,\n                file_secret_settings,\n            ),\n        )\n"
  },
  {
    "path": "shared/src/shared/settings/worker.py",
    "content": "from shared.domain.models.user import UserWithSessionString\nfrom shared.settings import AbstractSettings\n\n\nclass WorkerSettings(AbstractSettings):\n    user: UserWithSessionString\n    api_id: int\n    api_hash: str\n"
  },
  {
    "path": "shared/src/shared/settings/merged_source.py",
    "content": "import os\nfrom typing import Any, Dict, Type, Tuple\nfrom pydantic_settings import (\n    BaseSettings,\n    PydanticBaseSettingsSource,\n    JsonConfigSettingsSource,\n)\n\nclass MergedSettingsSource(PydanticBaseSettingsSource):\n    \"\"\"\n    A custom settings source that deep merges several sources.\n    It processes both flat keys and nested dictionaries for nested fields.\n    After merging, it converts nested dict keys to their alias names,\n    re-validates the nested model, and then dumps it with aliases.\n    \"\"\"\n\n    def __init__(\n        self,\n        settings_cls: Type[BaseSettings],\n        init_source: PydanticBaseSettingsSource,\n        env_source: PydanticBaseSettingsSource,\n        dotenv_source: PydanticBaseSettingsSource,\n        file_secret_source: PydanticBaseSettingsSource,\n    ) -> None:\n        super().__init__(settings_cls)\n        self.init_source = init_source\n        self.env_source = env_source\n        self.dotenv_source = dotenv_source\n        self.file_secret_source = file_secret_source\n        self._merged: Dict[str, Any] | None = None\n\n    def __call__(self) -> Dict[str, Any]:\n        env = os.environ.copy()\n        sources = [\n            JsonConfigSettingsSource(self.settings_cls)(),\n            self.init_source(),\n            self.dotenv_source(),\n            self.file_secret_source(),\n            env,\n        ]\n        merged: Dict[str, Any] = {}\n        for source in sources:\n            processed = self.nest_flat_keys(source.copy(), self.settings_cls)\n            merged = self.deep_merge(merged, processed)\n\n        merged = self.normalize_nested_fields(merged, self.settings_cls)\n\n        self._merged = merged\n        return merged\n\n    def get_field_value(self, field: Any, field_name: str) -> Tuple[Any, str, bool]:\n        merged = self()\n        if field_name in merged:\n            return merged[field_name], field_name, True\n\n        return None, field_name, False\n\n    @classmethod\n    def deep_merge(cls, a: Dict[str, Any], b: Dict[str, Any]) -> Dict[str, Any]:\n        result = a.copy()\n        for key, value in b.items():\n            if key in result and isinstance(result[key], dict) and isinstance(value, dict):\n                result[key] = cls.deep_merge(result[key], value)\n            else:\n                result[key] = value\n\n        return result\n\n    @classmethod\n    def nest_flat_keys(cls, data: Dict[str, Any], settings_cls: Type[BaseSettings]) -> Dict[str, Any]:\n        for field_name, field in settings_cls.model_fields.items():\n            field_type = field.annotation\n\n            if isinstance(field_type, type) and issubclass(field_type, BaseSettings):\n                nested_from_flat: Dict[str, Any] = {}\n                for subfield_name, subfield in field_type.model_fields.items():\n                    alias = subfield.alias or subfield_name\n                    if alias in data:\n                        nested_from_flat[subfield_name] = data[alias]\n\n                nested_existing: Dict[str, Any] = {}\n                if field_name in data and isinstance(data[field_name], dict):\n                    nested_existing = data.pop(field_name)\n\n                if nested_from_flat or nested_existing:\n                    combined = cls.deep_merge(nested_existing, nested_from_flat)\n                    data[field_name] = combined\n\n        return data\n\n    @classmethod\n    def convert_to_alias(cls, nested: Dict[str, Any], nested_cls: Type[BaseSettings]) -> Dict[str, Any]:\n        \"\"\"\n        Convert keys from field names to alias names for a nested model.\n        Only include keys defined by the model.\n        \"\"\"\n        alias_dict: Dict[str, Any] = {}\n        for field_name, field in nested_cls.model_fields.items():\n            alias = field.alias or field_name\n            if field_name in nested:\n                alias_dict[alias] = nested[field_name]\n\n        return alias_dict\n\n    @classmethod\n    def normalize_nested_fields(cls, data: Dict[str, Any], settings_cls: Type[BaseSettings]) -> Dict[str, Any]:\n        for field_name, field in settings_cls.model_fields.items():\n            field_type = field.annotation\n            if isinstance(field_type, type) and issubclass(field_type, BaseSettings):\n                if field_name in data and isinstance(data[field_name], dict):\n                    # Convert the keys to alias names first.\n                    alias_data = cls.convert_to_alias(data[field_name], field_type)\n                    # Now, construct the nested model.\n                    nested_model = field_type.model_validate(alias_data)\n                    # Dump it with aliases.\n                    data[field_name] = nested_model.model_dump(by_alias=True)\n\n        return data\n"
  },
  {
    "path": "shared/src/shared/settings/db.py",
    "content": "from pydantic import SecretStr\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\nfrom .abstract import AbstractSettings\n\n\nclass DBSettings(AbstractSettings):\n    host: str\n    port: int\n    name: str\n    user: str\n    password: SecretStr\n\n    model_config = SettingsConfigDict(populate_by_name=True, extra=\"forbid\")\n\n    @property\n    def url(self) -> str:\n        return (\n            f\"postgresql+asyncpg://{self.user}:{self.password.get_secret_value()}\"\n            f\"@{self.host}:{self.port}/{self.name}\"\n        )\n"
  },
  {
    "path": "shared/src/shared/settings/__init__.py",
    "content": "from .miniapp import MiniappSettings\nfrom .db import DBSettings\nfrom .jwt import JwtSettings\nfrom .environment import EnvironmentSettings\nfrom .bot import BotSettings\nfrom .abstract import AbstractSettings\nfrom .docker import DockerSettings\nfrom .worker import WorkerSettings\n\n__all__ = [\n    \"MiniappSettings\",\n    \"DBSettings\",\n    \"JwtSettings\",\n    \"EnvironmentSettings\",\n    \"BotSettings\",\n    \"AbstractSettings\",\n    \"DockerSettings\",\n    \"WorkerSettings\",\n]"
  },
  {
    "path": "shared/src/shared/settings/docker.py",
    "content": "from pydantic import Field\nfrom pydantic_settings import BaseSettings\n\n\nclass DockerSettings(BaseSettings):\n    workers_network_name: str\n    app_root_config_path: str\n    host_root_config_path: str = Field(..., alias='HOST_ROOT_CONFIG_PATH')\n    worker_image: str\n"
  },
  {
    "path": "shared/src/shared/settings/miniapp.py",
    "content": "from pydantic import Field\nfrom pydantic_settings import BaseSettings\n\n\nclass MiniappSettings(BaseSettings):\n    url: str = Field(..., alias=\"MINIAPP_URL\")\n"
  },
  {
    "path": "shared/src/shared/settings/bot.py",
    "content": "from pydantic import SecretStr, Field\nfrom pydantic_settings import BaseSettings\n\n\nclass BotSettings(BaseSettings):\n    token: SecretStr = Field(..., alias=\"BOT_TOKEN\")\n"
  },
  {
    "path": "shared/src/shared/settings/environment.py",
    "content": "from pydantic import Field\nfrom pydantic_settings import BaseSettings\n\n\nclass EnvironmentSettings(BaseSettings):\n    env_name: str = Field('local', alias='ENVIRONMENT')\n    host: str = Field('localhost:9090', alias='APP_HOST')\n\n    @property\n    def is_debug(self) -> bool:\n        return self.env_name in ('development', 'local')\n\n    @property\n    def is_safe(self) -> bool:\n        return self.env_name in ('local',)\n"
  },
  {
    "path": "shared/src/shared/settings/scheduler.py",
    "content": "from pydantic import Field\n\nfrom shared.settings import AbstractSettings\n\n\nclass SchedulerSettings(AbstractSettings):\n    job_store_sqlite_path: str = Field(default='/app/jobs.sqlite')\n"
  },
  {
    "path": "shared/src/shared/settings/jwt.py",
    "content": "from pydantic import SecretStr\nfrom pydantic_settings import (\n    BaseSettings,\n)\n\n\nclass JwtSettings(BaseSettings):\n    secret_key: SecretStr\n    issuer: str\n    audience: str\n    access_expire: int = 60 * 15 * 100  # todo\n    refresh_expire: int = 60 * 60 * 24 * 90\n    allowed_origins: list[str]\n"
  },
  {
    "path": "shared/src/shared/dependencies/__init__.py",
    "content": ""
  },
  {
    "path": "shared/src/shared/dependencies/repositories/worker_message.py",
    "content": "from shared.abstractions.repositories.worker_message import WorkerMessageRepositoryInterface\nfrom shared.infrastructure.main_db.repositories.worker_message import WorkerMessageRepository\nfrom .sessionmaker import get_session_maker\n\n\ndef get_worker_message_repository() -> WorkerMessageRepositoryInterface:\n    return WorkerMessageRepository(\n        session_maker=get_session_maker(),\n    )\n"
  },
  {
    "path": "shared/src/shared/dependencies/repositories/post.py",
    "content": "from shared.abstractions.repositories import PostRepositoryInterface\nfrom shared.infrastructure.main_db.repositories import PostRepository\nfrom .sessionmaker import get_session_maker\n\n\ndef get_post_repository() -> PostRepositoryInterface:\n    return PostRepository(\n        session_maker=get_session_maker(),\n    )\n"
  },
  {
    "path": "shared/src/shared/dependencies/repositories/story.py",
    "content": "from shared.abstractions.repositories import StoryRepositoryInterface\nfrom shared.infrastructure.main_db import StoryRepository\nfrom .sessionmaker import get_session_maker\n\n\ndef get_story_repository() -> StoryRepositoryInterface:\n    return StoryRepository(\n        session_maker=get_session_maker(),\n    )\n"
  },
  {
    "path": "shared/src/shared/dependencies/repositories/user.py",
    "content": "from shared.abstractions.repositories import UserRepositoryInterface\nfrom shared.infrastructure.main_db.repositories import UserRepository\nfrom .sessionmaker import get_session_maker\n\n\ndef get_user_repository() -> UserRepositoryInterface:\n    return UserRepository(\n        session_maker=get_session_maker(),\n    )\n"
  },
  {
    "path": "shared/src/shared/dependencies/repositories/story_to_publish.py",
    "content": "from shared.abstractions.repositories import StoryToPublishRepositoryInterface\nfrom shared.infrastructure.main_db.repositories import StoryToPublishRepository\nfrom .sessionmaker import get_session_maker\n\n\ndef get_story_to_publish_repository() -> StoryToPublishRepositoryInterface:\n    return StoryToPublishRepository(\n        session_maker=get_session_maker(),\n    )\n"
  },
  {
    "path": "shared/src/shared/dependencies/repositories/sessionmaker.py",
    "content": "from sqlalchemy.ext.asyncio import async_sessionmaker\n\nfrom shared.infrastructure.main_db import get_sessionmaker\n\n\ndef get_session_maker() -> async_sessionmaker:\n    return get_sessionmaker()\n"
  },
  {
    "path": "shared/src/shared/dependencies/repositories/story_request.py",
    "content": "from shared.abstractions.repositories import PublishStoryRequestRepositoryInterface\nfrom shared.infrastructure.main_db.repositories import PublishStoryRequestRepository\nfrom .sessionmaker import get_session_maker\n\n\ndef get_story_request_repository() -> PublishStoryRequestRepositoryInterface:\n    return PublishStoryRequestRepository(\n        session_maker=get_session_maker(),\n    )\n"
  },
  {
    "path": "shared/src/shared/dependencies/repositories/post_request.py",
    "content": "from shared.abstractions.repositories import SendPostRequestRepositoryInterface\nfrom shared.infrastructure.main_db.repositories import SendPostRequestRepository\nfrom .sessionmaker import get_session_maker\n\n\ndef get_post_request_repository() -> SendPostRequestRepositoryInterface:\n    return SendPostRequestRepository(\n        session_maker=get_session_maker(),\n    )\n"
  },
  {
    "path": "shared/src/shared/dependencies/repositories/emoji.py",
    "content": "from shared.abstractions.repositories.emojis import EmojisRepositoryInterface\nfrom shared.infrastructure.main_db.repositories.emoji import EmojiRepository\nfrom .sessionmaker import get_session_maker\n\n\ndef get_emoji_repository() -> EmojisRepositoryInterface:\n    return EmojiRepository(\n        session_maker=get_session_maker(),\n    )\n"
  },
  {
    "path": "shared/src/shared/dependencies/repositories/proxy.py",
    "content": "from shared.abstractions.repositories import ProxyRepositoryInterface\nfrom shared.infrastructure.main_db.repositories import ProxyRepository\nfrom .sessionmaker import get_session_maker\n\n\ndef get_proxy_repository() -> ProxyRepositoryInterface:\n    return ProxyRepository(\n        session_maker=get_session_maker(),\n    )\n"
  },
  {
    "path": "shared/src/shared/dependencies/repositories/post_to_publish.py",
    "content": "from shared.abstractions.repositories import PostToPublishRepositoryInterface\nfrom shared.infrastructure.main_db.repositories import PostToPublishRepository\nfrom .sessionmaker import get_session_maker\n\n\ndef get_post_to_publish_repository() -> PostToPublishRepositoryInterface:\n    return PostToPublishRepository(\n        session_maker=get_session_maker(),\n    )\n"
  },
  {
    "path": "shared/src/shared/dependencies/repositories/__init__.py",
    "content": "from .chat import get_chat_repository\nfrom .emoji import get_emoji_repository\nfrom .post import get_post_repository\nfrom .post_request import get_post_request_repository\nfrom .post_to_publish import get_post_to_publish_repository\nfrom .proxy import get_proxy_repository\nfrom .story import get_story_repository\nfrom .story_request import get_story_request_repository\nfrom .story_to_publish import get_story_to_publish_repository\nfrom .user import get_user_repository\n\n__all__ = [\n    \"get_post_repository\",\n    \"get_chat_repository\",\n    \"get_user_repository\",\n    \"get_story_repository\",\n    \"get_post_request_repository\",\n    \"get_story_to_publish_repository\",\n    \"get_proxy_repository\",\n    \"get_post_to_publish_repository\",\n    \"get_emoji_repository\",\n    \"get_story_request_repository\",\n]\n"
  },
  {
    "path": "shared/src/shared/dependencies/repositories/chat.py",
    "content": "from shared.abstractions.repositories import ChatRepositoryInterface\nfrom shared.infrastructure.main_db.repositories import ChatRepository\nfrom .sessionmaker import get_session_maker\n\n\ndef get_chat_repository() -> ChatRepositoryInterface:\n    return ChatRepository(\n        session_maker=get_session_maker(),\n    )\n"
  },
  {
    "path": "shared/src/shared/dependencies/services/get_scheduler.py",
    "content": "from pathlib import Path\n\nfrom shared.abstractions.services.scheduler import SchedulerInterface\nfrom shared.services.scheduler import Scheduler\n\n\ndef get_scheduler(sqlite_path: str) -> SchedulerInterface:\n    return Scheduler(\n        job_store_sqlite_path=Path(sqlite_path),\n    )\n"
  },
  {
    "path": "shared/src/shared/dependencies/services/upload.py",
    "content": "from typing import Optional\n\nfrom shared.abstractions.services import UploadServiceInterface\nfrom shared.services import UploadService\n\n\ndef get_upload_service(public_backend_base_url: str, app_upload_dir: Optional[str] = None) -> UploadServiceInterface:\n    if app_upload_dir is None:\n        return UploadService(\n            public_backend_base_url=public_backend_base_url,\n        )\n\n    return UploadService(\n        images_dir=app_upload_dir,\n        public_backend_base_url=public_backend_base_url,\n    )\n"
  },
  {
    "path": "shared/src/shared/dependencies/services/emoji.py",
    "content": "from shared.abstractions.services.emoji import EmojiServiceInterface\nfrom shared.dependencies.repositories.emoji import get_emoji_repository\nfrom shared.services.emoji import EmojiService\n\n\ndef get_emoji_service() -> EmojiServiceInterface:\n    return EmojiService(emoji_repository=get_emoji_repository())"
  },
  {
    "path": "shared/src/shared/dependencies/services/__init__.py",
    "content": "from .upload import get_upload_service\n\n__all__ = [\n    \"get_upload_service\",\n]"
  },
  {
    "path": "shared/src/shared/dependencies/services/watcher_client.py",
    "content": "from shared.abstractions.services.watcher_client import WatcherClientInterface\nfrom shared.services.watcher_client import WatcherClient\n\n\ndef get_watcher_client_from_url(base_url: str) -> WatcherClientInterface:\n    return WatcherClient(\n        base_url=base_url,\n    )\n"
  },
  {
    "path": "shared/src/shared/abstractions/__init__.py",
    "content": ""
  },
  {
    "path": "shared/src/shared/abstractions/singleton.py",
    "content": "from abc import ABCMeta\n\n\nclass SingletonMeta(type):\n    _instances = {}\n\n    def __call__(cls, *args, **kwargs):\n        if cls not in cls._instances:\n            cls._instances[cls] = super().__call__(*args, **kwargs)\n        return cls._instances[cls]\n\n\nclass SingletonABCMeta(SingletonMeta, ABCMeta):\n    pass\n\n\nclass Singleton(metaclass=SingletonABCMeta):\n    pass\n"
  },
  {
    "path": "shared/src/shared/abstractions/repositories/abstract.py",
    "content": "from abc import ABC, abstractmethod\n\nclass CRUDRepositoryInterface[PK_TYPE, Model, CreateDTO, UpdateDTO](ABC):\n    @abstractmethod\n    async def create(self, obj: CreateDTO) -> PK_TYPE:\n        pass\n\n    @abstractmethod\n    async def get(self, obj_id: PK_TYPE) -> Model:\n        pass\n\n    @abstractmethod\n    async def update(self, obj_id: PK_TYPE, obj: UpdateDTO) -> Model:\n        pass\n\n    @abstractmethod\n    async def delete(self, obj_id: PK_TYPE) -> None:\n        pass\n\n    @abstractmethod\n    async def get_all(self, limit: int = 100, offset: int = 0) -> list[Model]:\n        pass\n\n    @abstractmethod\n    async def get_many(self, obj_ids: list[PK_TYPE]) -> list[Model]:\n        ...\n\nclass UOWInterface(ABC):\n    @abstractmethod\n    async def commit(self) -> None:\n        pass\n\n    @abstractmethod\n    async def rollback(self) -> None:\n        pass\n\n    @abstractmethod\n    async def attach(self, *repositories: CRUDRepositoryInterface) -> None:\n        pass\n\n    @abstractmethod\n    async def __aenter__(self):\n        pass\n\n    @abstractmethod\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        pass\n"
  },
  {
    "path": "shared/src/shared/abstractions/repositories/worker_message.py",
    "content": "from abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom typing import Optional\nfrom uuid import UUID\n\nfrom shared.abstractions.repositories.uuid_pk_abstract import UUIDPKRepositoryInterface\nfrom shared.domain.dto import CreateWorkerMessageDTO, UpdateWorkerMessageDTO\nfrom shared.domain.enums import WorkerMessageStatus\nfrom shared.domain.models import WorkerMessage\n\n\nclass WorkerMessageRepositoryInterface(\n    UUIDPKRepositoryInterface[WorkerMessage, CreateWorkerMessageDTO, UpdateWorkerMessageDTO],\n    ABC,\n):\n    @abstractmethod\n    async def get_queued_message(self) -> Optional[WorkerMessage]:\n        ...\n\n    @abstractmethod\n    async def set_message_status(\n            self,\n            message_id: UUID,\n            status: WorkerMessageStatus,\n            sent_at: Optional[datetime] = None\n    ) -> None:\n        ...\n\n    @abstractmethod\n    async def get_messages_from_same_request(self, message_id: UUID) -> list[WorkerMessage]:\n        ...\n"
  },
  {
    "path": "shared/src/shared/abstractions/repositories/post.py",
    "content": "from abc import ABC\n\nfrom .uuid_pk_abstract import UUIDPKRepositoryInterface\nfrom shared.domain.dto import CreatePostDTO, UpdatePostDTO\nfrom shared.domain.models import Post\n\n\nclass PostRepositoryInterface(\n    UUIDPKRepositoryInterface[Post, CreatePostDTO, UpdatePostDTO],\n    ABC,\n):\n    ...\n"
  },
  {
    "path": "shared/src/shared/abstractions/repositories/story.py",
    "content": "from abc import ABC\n\nfrom shared.domain.dto.story import CreateStoryDTO, UpdateStoryDTO\nfrom shared.domain.models import Story\nfrom .uuid_pk_abstract import UUIDPKRepositoryInterface\n\n\nclass StoryRepositoryInterface(\n    UUIDPKRepositoryInterface[Story, CreateStoryDTO, UpdateStoryDTO],\n    ABC,\n):\n    ...\n"
  },
  {
    "path": "shared/src/shared/abstractions/repositories/user.py",
    "content": "from typing import Optional\nfrom abc import ABC, abstractmethod\nfrom uuid import UUID\n\nfrom .uuid_pk_abstract import UUIDPKRepositoryInterface\nfrom shared.domain.dto import CreateUserDTO, UpdateUserDTO\nfrom shared.domain.models import User\n\n\nclass UserRepositoryInterface(\n    UUIDPKRepositoryInterface[User, CreateUserDTO, UpdateUserDTO],\n    ABC,\n):\n    @abstractmethod\n    async def get_by_username(self, username: str) -> User:\n        ...\n\n    @abstractmethod\n    async def get_by_telegram_id(self, telegram_id: int) -> Optional[User]:\n        ...\n\n    @abstractmethod\n    async def set_proxy(self, user_id: UUID, proxy_id: UUID) -> None:\n        ...\n"
  },
  {
    "path": "shared/src/shared/abstractions/repositories/story_to_publish.py",
    "content": "from abc import ABC\n\nfrom shared.domain.dto import CreateStoryToPublishDTO, UpdateStoryToPublishDTO\nfrom shared.domain.models import StoryToPublish\nfrom .uuid_pk_abstract import UUIDPKRepositoryInterface\n\n\nclass StoryToPublishRepositoryInterface(\n    UUIDPKRepositoryInterface[StoryToPublish, CreateStoryToPublishDTO, UpdateStoryToPublishDTO],\n    ABC,\n):\n    ...\n"
  },
  {
    "path": "shared/src/shared/abstractions/repositories/story_request.py",
    "content": "from abc import ABC, abstractmethod\nfrom typing import Optional\n\nfrom .uuid_pk_abstract import UUIDPKRepositoryInterface\nfrom shared.domain.dto import CreatePublishStoryRequestDTO, UpdatePublishStoryRequestDTO\nfrom shared.domain.models import PublishStoryRequest\n\n\nclass PublishStoryRequestRepositoryInterface(\n    UUIDPKRepositoryInterface[PublishStoryRequest, CreatePublishStoryRequestDTO, UpdatePublishStoryRequestDTO],\n    ABC,\n):\n    @abstractmethod\n    async def get_queued_message(self) -> Optional[PublishStoryRequest]:\n        pass\n"
  },
  {
    "path": "shared/src/shared/abstractions/repositories/post_request.py",
    "content": "from abc import ABC, abstractmethod\nfrom typing import Optional\nfrom uuid import UUID\n\nfrom .uuid_pk_abstract import UUIDPKRepositoryInterface\nfrom shared.domain.dto.post_request import CreateSendPostRequestDTO, UpdateSendPostRequestDTO\nfrom shared.domain.models.post_request import SendPostRequest\n\n\nclass SendPostRequestRepositoryInterface(\n    UUIDPKRepositoryInterface[SendPostRequest, CreateSendPostRequestDTO, UpdateSendPostRequestDTO],\n    ABC,\n):\n    @abstractmethod\n    async def get_queued_message(self) -> Optional[SendPostRequest]:\n        pass\n\n    @abstractmethod\n    async def get_requests_from_same_publication(self, request_id: UUID) -> list[SendPostRequest]:\n        ...\n"
  },
  {
    "path": "shared/src/shared/abstractions/repositories/proxy.py",
    "content": "from abc import ABC, abstractmethod\n\nfrom shared.domain.dto import CreateProxyDTO, UpdateProxyDTO\nfrom shared.domain.models import Proxy\nfrom .uuid_pk_abstract import UUIDPKRepositoryInterface\n\n\nclass ProxyRepositoryInterface(\n    UUIDPKRepositoryInterface[Proxy, CreateProxyDTO, UpdateProxyDTO],\n    ABC,\n):\n    @abstractmethod\n    async def get_available_proxies_count(self) -> int:\n        ...\n\n    @abstractmethod\n    async def get_available_proxy(self) -> Proxy:\n        ...\n"
  },
  {
    "path": "shared/src/shared/abstractions/repositories/post_to_publish.py",
    "content": "from abc import ABC, abstractmethod\nfrom typing import Optional\nfrom uuid import UUID\n\nfrom shared.domain.dto import CreatePostToPublishDTO, UpdatePostToPublishDTO\nfrom shared.domain.enums import PublicationStatus\nfrom shared.domain.models import PostToPublish\nfrom .uuid_pk_abstract import UUIDPKRepositoryInterface\n\n\nclass PostToPublishRepositoryInterface(\n    UUIDPKRepositoryInterface[PostToPublish, CreatePostToPublishDTO, UpdatePostToPublishDTO],\n    ABC,\n):\n    @abstractmethod\n    async def get_queued_post(self) -> Optional[PostToPublish]:\n        ...\n\n    @abstractmethod\n    async def set_status(self, post_id: UUID, status: PublicationStatus) -> None:\n        ...\n"
  },
  {
    "path": "shared/src/shared/abstractions/repositories/__init__.py",
    "content": "from .chat import ChatRepositoryInterface\nfrom .post import PostRepositoryInterface\nfrom .post_request import SendPostRequestRepositoryInterface\nfrom .story_request import PublishStoryRequestRepositoryInterface\nfrom .post_to_publish import PostToPublishRepositoryInterface\nfrom .story_to_publish import StoryToPublishRepositoryInterface\nfrom .user import UserRepositoryInterface\nfrom .story import StoryRepositoryInterface\nfrom .worker_message import WorkerMessageRepositoryInterface\nfrom .proxy import ProxyRepositoryInterface\n\n__all__ = [\n    \"UserRepositoryInterface\",\n    \"ChatRepositoryInterface\",\n    \"PostRepositoryInterface\",\n    \"StoryRepositoryInterface\",\n    \"SendPostRequestRepositoryInterface\",\n    \"PublishStoryRequestRepositoryInterface\",\n    \"PostToPublishRepositoryInterface\",\n    \"StoryToPublishRepositoryInterface\",\n    \"WorkerMessageRepositoryInterface\",\n    \"ProxyRepositoryInterface\",\n]\n"
  },
  {
    "path": "shared/src/shared/abstractions/repositories/emojis.py",
    "content": "from abc import ABC\n\nfrom .uuid_pk_abstract import UUIDPKRepositoryInterface\nfrom ...domain.dto.emoji import CreateEmojiDTO, UpdateEmojiDTO\nfrom ...domain.models.emoji import Emoji\n\n\nclass EmojisRepositoryInterface(\n    UUIDPKRepositoryInterface[Emoji, CreateEmojiDTO, UpdateEmojiDTO],\n    ABC,\n):\n    ...\n"
  },
  {
    "path": "shared/src/shared/abstractions/repositories/chat.py",
    "content": "from abc import ABC, abstractmethod\n\nfrom .uuid_pk_abstract import UUIDPKRepositoryInterface\nfrom shared.domain.dto.chat import CreateChatDTO, UpdateChatDTO\nfrom shared.domain.models.chat import Chat\n\n\nclass ChatRepositoryInterface(\n    UUIDPKRepositoryInterface[Chat, CreateChatDTO, UpdateChatDTO],\n    ABC,\n):\n    @abstractmethod\n    async def get_by_telegram_id(self, telegram_id: int) -> Chat:\n        ...\n\n    @abstractmethod\n    async def get_by_invite_link(self, invite_link: str) -> Chat:\n        ...\n"
  },
  {
    "path": "shared/src/shared/abstractions/repositories/uuid_pk_abstract.py",
    "content": "from abc import ABC\nfrom uuid import UUID\n\nfrom .abstract import CRUDRepositoryInterface\n\n\nclass UUIDPKRepositoryInterface[Model, CreateDTO, UpdateDTO](\n    CRUDRepositoryInterface[UUID, Model, CreateDTO, UpdateDTO],\n    ABC,\n):\n    ...\n"
  },
  {
    "path": "shared/src/shared/abstractions/services/upload.py",
    "content": "from abc import ABC, abstractmethod\n\n\nclass UploadServiceInterface(ABC):\n    @abstractmethod\n    async def upload(self, file: bytes, extension: str) -> str:\n        ...\n\n    @abstractmethod\n    def get_file_path(self, filename: str) -> str:\n        ...\n\n    @abstractmethod\n    async def initialize(self) -> None:\n        ...\n\n    @abstractmethod\n    def get_file_url(self, name: str) -> str:\n        ...\n\n    @staticmethod\n    @abstractmethod\n    def get_extension(filename: str) -> str:\n        ...\n"
  },
  {
    "path": "shared/src/shared/abstractions/services/emoji.py",
    "content": "from abc import ABC, abstractmethod\nfrom uuid import UUID\n\nfrom shared.domain.dto.emoji import CreateEmojiDTO\nfrom shared.domain.models.emoji import Emoji\n\n\nclass EmojiServiceInterface(ABC):\n\n    @abstractmethod\n    async def create_emoji(self, emoji: CreateEmojiDTO) -> UUID:\n        ...\n\n    @abstractmethod\n    async def get_all_emojis(self) -> list[Emoji]:\n        ...\n\n"
  },
  {
    "path": "shared/src/shared/abstractions/services/__init__.py",
    "content": "from .upload import UploadServiceInterface\nfrom .consumer import ConsumerInterface\n\n__all__ = [\n    \"UploadServiceInterface\",\n    \"ConsumerInterface\",\n]\n"
  },
  {
    "path": "shared/src/shared/abstractions/services/watcher_client.py",
    "content": "from abc import ABC, abstractmethod\n\nfrom shared.domain.requests import PublicationStartedRequest, RequestProcessingStartedRequest, MessageSentRequest\n\n\nclass WatcherClientInterface(ABC):\n    @abstractmethod\n    async def report_publication_started(self, request: PublicationStartedRequest) -> None:\n        ...\n\n    @abstractmethod\n    async def report_request_processing_started(self, request: RequestProcessingStartedRequest) -> None:\n        ...\n\n    @abstractmethod\n    async def report_message_sent(self, request: MessageSentRequest) -> None:\n        ...\n"
  },
  {
    "path": "shared/src/shared/abstractions/services/consumer.py",
    "content": "from abc import ABC, abstractmethod\nfrom typing import NoReturn, Any\n\n\nclass ConsumerInterface[ExecutableServiceInterface: Any](ABC):\n    @abstractmethod\n    async def execute(self) -> NoReturn:\n        ...\n"
  },
  {
    "path": "shared/src/shared/abstractions/services/scheduler.py",
    "content": "from abc import ABC, abstractmethod\nfrom collections.abc import Callable\nfrom datetime import datetime\nfrom typing import Coroutine, Any\n\n\nclass SchedulerInterface(ABC):\n    @abstractmethod\n    def schedule_once(\n            self,\n            callback: Callable[[Any], Coroutine[Any, Any, None]],\n            runs_on: datetime,\n            args: tuple[Any, ...] = (),\n            job_id: str = None,\n    ) -> None:\n        ...\n\n    @abstractmethod\n    def initialize(self) -> None:\n        ...\n"
  },
  {
    "path": "shared/src/shared/infrastructure/__init__.py",
    "content": ""
  },
  {
    "path": "shared/src/shared/infrastructure/sqlalchemy/__init__.py",
    "content": "from .exceptions import NotFoundException\nfrom .repository import AbstractSQLAlchemyRepository\n\n__all__ = [\n    \"AbstractSQLAlchemyRepository\",\n    \"NotFoundException\",\n]"
  },
  {
    "path": "shared/src/shared/infrastructure/sqlalchemy/exceptions.py",
    "content": "class NotFoundException(Exception):\n    ...\n"
  },
  {
    "path": "shared/src/shared/infrastructure/sqlalchemy/repository.py",
    "content": "import logging\nfrom abc import abstractmethod\nfrom dataclasses import dataclass, field\nfrom typing import Type, Optional\nfrom asyncpg.pgproto.pgproto import UUID as asyncpgUUID\n\nfrom sqlalchemy import select\nfrom sqlalchemy.exc import NoResultFound\nfrom sqlalchemy.ext.asyncio import async_sessionmaker\nfrom sqlalchemy.orm import joinedload, InstrumentedAttribute\n\nfrom shared.abstractions.repositories.abstract import CRUDRepositoryInterface\nfrom shared.infrastructure.sqlalchemy.exceptions import NotFoundException\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass AbstractSQLAlchemyRepository[Entity, Model, CreateDTO, UpdateDTO, PK_TYPE](\n    CRUDRepositoryInterface[PK_TYPE, Model, CreateDTO, UpdateDTO],\n):\n    session_maker: async_sessionmaker\n\n    joined_fields: dict[str, Optional[list[str]]] = field(default_factory=dict)\n    options: list = field(default_factory=list)\n\n    def __post_init__(self):\n        self.entity: Type[Entity] = self.__orig_bases__[0].__args__[0]  # noqa\n        self._set_lazy_fields()\n\n    def _set_lazy_fields(self):\n        if not self.joined_fields:\n            return\n\n        def convert_to_nested_dict(fields):\n            return {field: {} for field in (fields or [])}\n\n        def get_associated_entity_class(attr_field):\n            \"\"\"\n            Extract the associated entity class from an InstrumentedAttribute.\n            \"\"\"\n            if hasattr(attr_field, \"comparator\") and hasattr(attr_field.comparator, \"prop\"):\n                relationship_prop = attr_field.comparator.prop\n                if hasattr(relationship_prop, \"mapper\"):\n                    return relationship_prop.mapper.entity\n            return None\n\n        def build_joinedload(attr_field, subfields, depth=0):\n            \"\"\"\n            Recursively build joinedload options for nested relationships.\n            \"\"\"\n            associated_entity = get_associated_entity_class(attr_field)\n            if not associated_entity:\n                raise ValueError(f\"Cannot determine associated entity class for attribute {attr_field}\")\n\n            loader = joinedload(attr_field)\n            for subfield, nested_subfields in subfields.items():\n                nested_attr_field = getattr(associated_entity, subfield, None)\n                if nested_attr_field is None:\n                    raise ValueError(f\"{subfield} is not a valid attribute of {associated_entity}\")\n\n                subloader = build_joinedload(nested_attr_field, nested_subfields, depth + 1)\n                loader = loader.options(subloader)\n            return loader\n\n        # Convert self.joined_fields to nested dictionaries if not already\n        joined_fields = {}\n        for field in self.joined_fields:\n            joined_fields[field] = convert_to_nested_dict(self.joined_fields[field])\n\n        options_to_add = []\n        for attr, subfields in joined_fields.items():\n            attr_field: InstrumentedAttribute = getattr(self.entity, attr)\n            if attr_field.comparator.prop.uselist:\n                loader = build_joinedload(attr_field, subfields or {})\n                options_to_add.append(loader)\n            else:\n                options_to_add.append(joinedload(attr_field))\n\n        self.options.extend(options_to_add)\n\n    async def create(self, obj: CreateDTO) -> int | asyncpgUUID:\n        async with self.session_maker() as session:\n            async with session.begin():\n                entity = self.create_dto_to_entity(obj)\n                session.add(entity)\n\n            await session.refresh(entity)\n            entity_id = entity.id\n\n        return entity_id\n\n    async def get(self, obj_id: PK_TYPE) -> Model:\n        try:\n            async with self.session_maker() as session:\n                if self.options:\n                    res = await session.execute(\n                        select(self.entity)\n                        .where(self.entity.id == obj_id)\n                        .options(*self.options)\n                    )\n                    obj = res.unique().scalars().one()\n                else:\n                    res = await session.execute(\n                        select(self.entity)\n                        .where(self.entity.id == obj_id)\n                    )\n                    obj = res.scalars().one()\n                return self.entity_to_model(obj)\n        except NoResultFound:\n            raise NotFoundException\n\n    async def update(self, obj_id: PK_TYPE, obj: UpdateDTO) -> Model:\n        async with self.session_maker() as session:\n            async with session.begin():\n                entity = await session.get(self.entity, obj_id, options=self.options)\n                for key, value in obj.model_dump(exclude_unset=True).items():\n                    setattr(entity, key, value)\n\n            await session.refresh(entity)\n\n        return self.entity_to_model(entity)\n\n    async def delete(self, obj_id: PK_TYPE) -> None:\n        async with self.session_maker() as session:\n            async with session.begin():\n                obj = await session.get(self.entity, obj_id)\n                await session.delete(obj)\n\n    async def get_all(self, limit: int = 100, offset: int = 0, joined: bool = True) -> list[Model]:\n        async with self.session_maker() as session:\n            if joined:\n                if self.options:\n                    return [\n                        self.entity_to_model(entity)\n                        for entity in (await session.execute(\n                            select(self.entity)\n                            .limit(limit)\n                            .offset(offset)\n                            .options(*self.options)\n                        )).unique().scalars().all()\n                    ]\n            res = (await session.execute(\n                select(self.entity)\n                .limit(limit)\n                .offset(offset)\n            )).scalars().all()\n            return [\n                self.entity_to_model(entity)\n                for entity in res\n            ]\n\n    async def get_many(self, obj_ids: list[PK_TYPE]) -> list[Model]:\n        if not obj_ids:\n            return []\n\n        try:\n            async with self.session_maker() as session:\n                if self.options:\n                    res = await session.execute(\n                        select(self.entity)\n                        .where(self.entity.id.in_(obj_ids))\n                        .options(*self.options)\n                    )\n                    objects = res.unique().scalars().all()\n                else:\n                    res = await session.execute(\n                        select(self.entity)\n                        .where(self.entity.id.in_(obj_ids))\n                    )\n                    objects = res.scalars().all()\n                return [self.entity_to_model(x) for x in objects]\n        except NoResultFound:\n            raise NotFoundException\n\n    @abstractmethod\n    def entity_to_model(self, entity: Entity) -> Model:\n        ...\n\n    @abstractmethod\n    def create_dto_to_entity(self, dto: CreateDTO) -> Entity:\n        ...\n"
  },
  {
    "path": "shared/src/shared/infrastructure/main_db/__init__.py",
    "content": "from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker\n\nfrom .migrator import apply_migrations\nfrom .repositories import (\n    UserRepository,\n    ChatRepository,\n    PostRepository,\n    StoryRepository,\n    SendPostRequestRepository,\n    StoryToPublishRepository,\n    PostToPublishRepository,\n    PublishStoryRequestRepository,\n    WorkerMessageRepository,\n    ProxyRepository,\n    NoFreeProxiesException,\n)\nfrom .settings import MainDBSettings\n\n__all__ = [\n    \"session_maker\",\n    \"UserRepository\",\n    \"ChatRepository\",\n    \"PostRepository\",\n    \"StoryRepository\",\n    \"SendPostRequestRepository\",\n    \"PublishStoryRequestRepository\",\n    \"StoryToPublishRepository\",\n    \"PostToPublishRepository\",\n    \"WorkerMessageRepository\",\n    \"ProxyRepository\",\n    \"MainDBSettings\",\n    \"apply_migrations\",\n    \"NoFreeProxiesException\",\n]\n\nsession_maker = None\n\n\ndef get_sessionmaker():\n    return session_maker\n\n\ndef init_db(url: str):\n    global session_maker\n\n    engine = create_async_engine(\n        url,\n        echo=False,\n        pool_recycle=1800,\n        pool_timeout=30,\n    )\n\n    session_maker = async_sessionmaker(engine, expire_on_commit=False)\n"
  },
  {
    "path": "shared/src/shared/infrastructure/main_db/settings.py",
    "content": "from pathlib import Path\nfrom typing import ClassVar\n\nfrom pydantic import SecretStr, Field\nfrom pydantic_settings import SettingsConfigDict\n\nfrom shared.settings import DBSettings\n\n\nclass MainDBSettings(DBSettings):\n    host: str = Field(..., alias='MAIN_DB_HOST')\n    port: int = Field(..., alias='MAIN_DB_PORT')\n    name: str = Field(..., alias='MAIN_DB_NAME')\n    user: str = Field(..., alias='MAIN_DB_USER')\n    password: SecretStr = Field(..., alias='MAIN_DB_PASSWORD')\n\n    model_config = SettingsConfigDict(\n        extra=\"ignore\",\n        json_file=Path(__file__).parent.parent.parent / \"settings.json\",\n        json_file_encoding=\"utf-8\",\n        populate_by_name=True,\n    )\n"
  },
  {
    "path": "shared/src/shared/infrastructure/main_db/entities.py",
    "content": "from datetime import datetime, time, date\nfrom typing import Optional\nfrom uuid import UUID as pyUUID\n\nfrom sqlalchemy import ForeignKey, UUID, Enum, func, BigInteger, Table, Column\nfrom sqlalchemy.dialects.postgresql import TIMESTAMP, JSONB\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\n\nfrom shared.domain.enums import (\n    UserRole,\n    SendPostRequestStatus,\n    PublishStoryRequestStatus,\n    WorkerMessageType,\n    WorkerMessageStatus, ScheduledType, PublicationStatus,\n)\n\nBase = declarative_base()\n\n\nclass AbstractBase(Base):\n    __abstract__ = True\n\n    id: Mapped[pyUUID] = mapped_column(UUID(as_uuid=True), primary_key=True)\n    created_at: Mapped[datetime] = mapped_column(\n        TIMESTAMP,\n        server_default=func.now(),\n    )\n    updated_at: Mapped[datetime] = mapped_column(\n        TIMESTAMP,\n        server_default=func.now(),\n        onupdate=func.current_timestamp(),\n    )\n\n\nclass User(AbstractBase):\n    __tablename__ = \"users\"\n\n    telegram_id: Mapped[int] = mapped_column(BigInteger, unique=True)\n    telegram_username: Mapped[Optional[str]]\n    telegram_first_name: Mapped[Optional[str]]\n    telegram_last_name: Mapped[Optional[str]]\n    telegram_language_code: Mapped[Optional[str]]\n\n    role: Mapped[UserRole] = mapped_column(Enum(UserRole))\n\n    session_string: Mapped[Optional[str]]\n    proxy_id: Mapped[Optional[UUID]] = mapped_column(ForeignKey('proxies.id'), unique=True)\n\n    assistant_enabled: Mapped[bool] = mapped_column(default=False)\n\n    proxy: Mapped[Optional['Proxy']] = relationship('Proxy')\n\n\nclass Proxy(AbstractBase):\n    __tablename__ = \"proxies\"\n\n    proxy_string: Mapped[str] = mapped_column(unique=True)\n    is_free: Mapped[bool] = mapped_column(default=True)\n    is_deprecated: Mapped[bool] = mapped_column(default=False)\n\n    user: Mapped[User] = relationship('User')\n\n\nclass Chat(AbstractBase):\n    __tablename__ = \"chats\"\n\n    name: Mapped[str]\n    invite_link: Mapped[Optional[str]]\n    chat_id: Mapped[int] = mapped_column(BigInteger, unique=True)\n\n\nclass Post(AbstractBase):\n    __tablename__ = \"posts\"\n\n    name: Mapped[str]\n    text: Mapped[str]\n    image_path: Mapped[Optional[str]]\n\n    html: Mapped[Optional[str]]\n    entities: Mapped[Optional[list[dict]]] = mapped_column(JSONB)\n\n\npost_to_publish_chat_association = Table(\n    \"post_to_publish_chat_association\",\n    AbstractBase.metadata,\n    Column(\"post_to_publish_id\", ForeignKey(\"posts_to_publish.id\"), primary_key=True),\n    Column(\"chat_id\", ForeignKey(\"chats.id\"), primary_key=True),\n)\n\n\nclass PostToPublish(AbstractBase):\n    __tablename__ = \"posts_to_publish\"\n\n    post_id: Mapped[pyUUID] = mapped_column(ForeignKey(\"posts.id\"))\n    manager_id: Mapped[pyUUID] = mapped_column(ForeignKey(\"users.id\", ondelete=\"SET NULL\"),\n    nullable=True)\n    scheduled_type: Mapped[ScheduledType]\n    scheduled_date: Mapped[Optional[date]]\n    scheduled_time: Mapped[time]\n    status: Mapped[PublicationStatus]\n\n    manager: Mapped[User] = relationship(\"User\", passive_deletes=\"all\")\n    post: Mapped[Post] = relationship(\"Post\")\n    chats: Mapped[list[Chat]] = relationship(\"Chat\", secondary=post_to_publish_chat_association)\n\n\nclass SendPostRequest(AbstractBase):\n    __tablename__ = \"send_post_requests\"\n\n    post_id: Mapped[pyUUID] = mapped_column(ForeignKey(\"posts.id\"))\n    chat_id: Mapped[pyUUID] = mapped_column(ForeignKey(\"chats.id\"))\n    user_id: Mapped[pyUUID] = mapped_column(ForeignKey(\"users.id\", ondelete=\"SET NULL\"),\n    nullable=True)\n    scheduled_at: Mapped[Optional[datetime]]\n\n    publication_id: Mapped[pyUUID] = mapped_column(ForeignKey(\"posts_to_publish.id\"))\n\n    status: Mapped[SendPostRequestStatus] = mapped_column(Enum(SendPostRequestStatus))\n    sent_at: Mapped[Optional[datetime]]\n\n    user: Mapped[\"User\"] = relationship(\"User\", passive_deletes=\"all\")\n    chat: Mapped[\"Chat\"] = relationship(\"Chat\")\n    post: Mapped[\"Post\"] = relationship(\"Post\")\n\n\nclass Story(AbstractBase):\n    __tablename__ = 'stories'\n\n    name: Mapped[str]\n    file_path: Mapped[str]\n    text: Mapped[Optional[str]]\n\n\nclass StoryToPublish(AbstractBase):\n    __tablename__ = 'stories_to_publish'\n\n    story_id: Mapped[pyUUID] = mapped_column(ForeignKey(\"stories.id\"))\n    manager_id: Mapped[pyUUID] = mapped_column(ForeignKey(\"users.id\", ondelete=\"SET NULL\"))\n    scheduled_type: Mapped[ScheduledType]\n    scheduled_date: Mapped[date]\n    scheduled_time: Mapped[time]\n    status: Mapped[PublicationStatus]\n\n    manager: Mapped[\"User\"] = relationship(\"User\", passive_deletes=\"all\")\n    story: Mapped[\"Story\"] = relationship(\"Story\")\n\n\nclass PublishStoryRequest(AbstractBase):\n    __tablename__ = \"publish_story_requests\"\n\n    story_id: Mapped[pyUUID] = mapped_column(ForeignKey(\"stories.id\"))\n    user_id: Mapped[pyUUID] = mapped_column(ForeignKey(\"users.id\", ondelete=\"SET NULL\"))\n    scheduled_at: Mapped[Optional[datetime]]\n\n    publication_id: Mapped[pyUUID] = mapped_column(ForeignKey(\"stories_to_publish.id\"))\n\n    status: Mapped[PublishStoryRequestStatus] = mapped_column(Enum(PublishStoryRequestStatus))\n    published_at: Mapped[Optional[datetime]]\n\n    user: Mapped[\"User\"] = relationship(\"User\", passive_deletes=\"all\")\n    story: Mapped[\"Story\"] = relationship(\"Story\")\n\n\nclass Emoji(AbstractBase):\n    __tablename__ = \"emojis\"\n\n    name: Mapped[str]\n    custom_emoji_id: Mapped[str]\n    img_url: Mapped[str]\n\n\n# internal workers data\nclass WorkerMessage(AbstractBase):\n    __tablename__ = \"worker_messages\"\n\n    user_id: Mapped[Optional[pyUUID]] = mapped_column(ForeignKey(\"users.id\", ondelete=\"SET NULL\"), nullable=True)\n    chat_id: Mapped[int] = mapped_column(BigInteger)\n    type: Mapped[WorkerMessageType] = mapped_column(Enum(WorkerMessageType))\n    text: Mapped[Optional[str]]\n    entities: Mapped[Optional[list[dict]]] = mapped_column(JSONB)\n    media_path: Mapped[Optional[str]]\n\n    request_id: Mapped[Optional[pyUUID]] = mapped_column(UUID(as_uuid=True))\n\n    status: Mapped[WorkerMessageStatus] = mapped_column(Enum(WorkerMessageStatus))\n    sent_at: Mapped[Optional[datetime]]\n\n    user: Mapped[\"User\"] = relationship(\"User\", passive_deletes=\"all\")\n"
  },
  {
    "path": "shared/src/shared/infrastructure/main_db/migrator.py",
    "content": "import logging\nimport subprocess\n\nlogger = logging.getLogger(__name__)\n\nasync def apply_migrations(url: str) -> None:\n    migrations_is_ok = subprocess.call([\"alembic\", \"-x\", f\"db_url={url}\", \"upgrade\", \"head\"]) == 0\n    if not migrations_is_ok:\n        logger.error(\"There is an error while upgrading database\")\n        exit(1)\n"
  },
  {
    "path": "shared/src/shared/infrastructure/main_db/repositories/abstract.py",
    "content": "from abc import ABC\nfrom uuid import UUID\nfrom sqlalchemy import select\nfrom shared.infrastructure.sqlalchemy.repository import AbstractSQLAlchemyRepository\n\n\nclass AbstractMainDBRepository[Entity, Model, CreateDTO, UpdateDTO](\n    AbstractSQLAlchemyRepository[Entity, Model, CreateDTO, UpdateDTO, UUID],\n    ABC,\n):\n    async def create(self, obj: CreateDTO) -> UUID:\n        return UUID(str(await super().create(obj)))\n\n    async def get_all(self, limit: int = 100, offset: int = 0, joined: bool = True) -> list[Model]:\n        async with self.session_maker() as session:\n            if joined:\n                if self.options:\n                    return [\n                        self.entity_to_model(entity)\n                        for entity in (await session.execute(\n                            select(self.entity)\n                            .order_by(self.entity.created_at.desc())\n                            .limit(limit)\n                            .offset(offset)\n                            .options(*self.options)\n                        )).unique().scalars().all()\n                    ]\n            res = (await session.execute(\n                select(self.entity)\n                .limit(limit)\n                .offset(offset)\n            )).scalars().all()\n            return [\n                self.entity_to_model(entity)\n                for entity in res\n            ]\n"
  },
  {
    "path": "shared/src/shared/infrastructure/main_db/repositories/worker_message.py",
    "content": "from dataclasses import dataclass, field\nfrom datetime import datetime\nfrom typing import Optional\nfrom uuid import UUID\n\nfrom sqlalchemy import select\n\nfrom shared.abstractions.repositories.worker_message import WorkerMessageRepositoryInterface\nfrom shared.domain.dto import CreateWorkerMessageDTO, UpdateWorkerMessageDTO\nfrom shared.domain.dto.post_to_publish import MessageEntityDTO\nfrom shared.domain.enums import WorkerMessageStatus\nfrom shared.domain.models import (\n    User as UserModel,\n)\nfrom shared.domain.models import WorkerMessage as WorkerMessageModel\nfrom shared.infrastructure.main_db.entities import User, WorkerMessage\nfrom .abstract import AbstractMainDBRepository\n\n\n@dataclass\nclass WorkerMessageRepository(\n    AbstractMainDBRepository[WorkerMessage, WorkerMessageModel, CreateWorkerMessageDTO, UpdateWorkerMessageDTO],\n    WorkerMessageRepositoryInterface,\n):\n    joined_fields: dict[str, Optional[list[str]]] = field(default_factory=lambda: {\n        \"user\": None,\n    })\n\n    async def get_messages_from_same_request(self, message_id: UUID) -> list[WorkerMessage]:\n        async with self.session_maker() as session:\n            message = await session.get(self.entity, message_id)\n            messages_result = await session.execute(\n                select(self.entity)\n                .where(self.entity.request_id == message.request_id)\n                .order_by(self.entity.created_at)\n                .options(*self.options)\n            )\n            messages = messages_result.unique().scalars().all()\n\n        return [self.entity_to_model(message) for message in messages]\n\n    async def get_queued_message(self) -> Optional[WorkerMessageModel]:\n        async with self.session_maker() as session:\n            result = await session.execute(\n                select(self.entity)\n                .where(self.entity.status == WorkerMessageStatus.PENDING)\n                .order_by(self.entity.created_at)\n                .options(*self.options)\n                .limit(1)\n            )  # todo: batching?\n\n            message = result.unique().scalars().one_or_none()\n\n        return self.entity_to_model(message) if message else None\n\n    async def set_message_status(\n            self,\n            message_id: UUID,\n            status: WorkerMessageStatus,\n            sent_at: Optional[datetime] = None\n    ) -> None:\n        async with self.session_maker() as session:\n            async with session.begin():\n                message = await session.get(self.entity, message_id)\n                message.status = status\n                if sent_at:\n                    message.sent_at = sent_at\n\n    def entity_to_model(self, entity: WorkerMessage) -> WorkerMessageModel:\n        def _map_user(user: User) -> UserModel:\n            return UserModel(\n                id=user.id,\n                telegram_id=user.telegram_id,\n                telegram_username=user.telegram_username,\n                telegram_last_name=user.telegram_last_name,\n                telegram_first_name=user.telegram_first_name,\n                telegram_language_code=user.telegram_language_code,\n                role=user.role,\n                assistant_enabled=user.assistant_enabled,\n                created_at=user.created_at,\n                updated_at=user.updated_at,\n            )\n\n        return WorkerMessageModel(\n            id=entity.id,\n            user_id=entity.user_id,\n            type=entity.type,\n            text=entity.text,\n            entities=[MessageEntityDTO.model_validate(x) for x in entity.entities] if entity.entities else None,\n            media_path=entity.media_path,\n            status=entity.status,\n            sent_at=entity.sent_at,\n            request_id=entity.request_id,\n            chat_id=entity.chat_id,\n            user=_map_user(entity.user),\n            created_at=entity.created_at,\n            updated_at=entity.updated_at,\n        )\n\n    def create_dto_to_entity(self, dto: CreateWorkerMessageDTO) -> WorkerMessage:\n        return WorkerMessage(\n            id=dto.id,\n            user_id=dto.user_id,\n            chat_id=dto.chat_id,\n            type=dto.type,\n            text=dto.text,\n            entities=[x.model_dump(mode='json') for x in dto.entities] if dto.entities else None,\n            media_path=dto.media_path,\n            status=dto.status,\n            sent_at=dto.sent_at,\n            request_id=dto.request_id,\n            created_at=dto.created_at,\n            updated_at=dto.updated_at,\n        )\n"
  },
  {
    "path": "shared/src/shared/infrastructure/main_db/repositories/post.py",
    "content": "from dataclasses import dataclass\nfrom uuid import UUID\n\nfrom shared.abstractions.repositories import PostRepositoryInterface\nfrom shared.domain.dto import CreatePostDTO, UpdatePostDTO\nfrom shared.domain.dto.post_to_publish import MessageEntityDTO\nfrom shared.domain.models import Post as PostModel\nfrom shared.infrastructure.main_db.entities import Post\nfrom .abstract import AbstractMainDBRepository\n\n\n@dataclass\nclass PostRepository(\n    AbstractMainDBRepository[Post, PostModel, CreatePostDTO, UpdatePostDTO],\n    PostRepositoryInterface,\n):\n    async def update(self, obj_id: UUID, obj: UpdatePostDTO) -> PostModel:\n        async with self.session_maker() as session:\n            async with session.begin():\n                entity = await session.get(self.entity, obj_id, options=self.options)\n                for key, value in obj.model_dump(exclude_unset=True).items():\n                    if key == 'entities' and value is not None:\n                        value = [x.model_dump(mode='json') for x in value]\n\n                    setattr(entity, key, value)\n\n            await session.refresh(entity)\n\n        return self.entity_to_model(entity)\n\n    def create_dto_to_entity(self, dto: CreatePostDTO) -> Post:\n        return Post(\n            id=dto.id,\n            text=dto.text,\n            name=dto.name,\n            image_path=dto.image_path,\n            html=dto.html,\n            entities=[x.model_dump(mode='json') for x in dto.entities] if dto.entities else None,\n            created_at=dto.created_at,\n            updated_at=dto.updated_at,\n        )\n\n    def entity_to_model(self, entity: Post) -> Post:\n        return PostModel(\n            id=entity.id,\n            text=entity.text,\n            name=entity.name,\n            image_path=entity.image_path,\n            html=entity.html,\n            entities=[MessageEntityDTO.model_validate(x) for x in entity.entities] if entity.entities else None,\n            created_at=entity.created_at,\n            updated_at=entity.updated_at,\n        )\n"
  },
  {
    "path": "shared/src/shared/infrastructure/main_db/repositories/story.py",
    "content": "from dataclasses import dataclass\n\nfrom shared.abstractions.repositories.story import StoryRepositoryInterface\nfrom shared.domain.dto.story import CreateStoryDTO, UpdateStoryDTO\nfrom shared.domain.models.story import Story as StoryModel\nfrom shared.infrastructure.main_db.entities import Story\nfrom shared.infrastructure.main_db.repositories.abstract import AbstractMainDBRepository\n\n\n@dataclass\nclass StoryRepository(\n    AbstractMainDBRepository[Story, StoryModel, CreateStoryDTO, UpdateStoryDTO],\n    StoryRepositoryInterface,\n):\n    def create_dto_to_entity(self, dto: CreateStoryDTO) -> Story:\n        return Story(\n            id=dto.id,\n            name=dto.name,\n            text=dto.text,\n            file_path=dto.file_path,\n            created_at=dto.created_at,\n            updated_at=dto.updated_at,\n        )\n\n    def entity_to_model(self, entity: Story) -> StoryModel:\n        return StoryModel(\n            id=entity.id,\n            name=entity.name,\n            text=entity.text,\n            file_path=entity.file_path,\n            created_at=entity.created_at,\n            updated_at=entity.updated_at,\n        )"
  },
  {
    "path": "shared/src/shared/infrastructure/main_db/repositories/user.py",
    "content": "from dataclasses import dataclass, field\nfrom typing import Optional, List\nfrom uuid import UUID\n\nfrom sqlalchemy import select\nfrom sqlalchemy.exc import NoResultFound\nfrom sqlalchemy.orm import joinedload\n\nfrom shared.abstractions.repositories import UserRepositoryInterface\nfrom shared.domain.dto import CreateUserDTO, UpdateUserDTO\nfrom shared.domain.models import User as UserModel, Proxy as ProxyModel\nfrom shared.infrastructure.main_db.entities import User, Proxy\nfrom .abstract import AbstractMainDBRepository\nfrom .exceptions import ProxyIsUnavailable, NoResultFoundException\n\n\n@dataclass\nclass UserRepository(\n    AbstractMainDBRepository[User, UserModel, CreateUserDTO, UpdateUserDTO],\n    UserRepositoryInterface,\n):\n\n    joined_fields: dict[str, Optional[List[str]]] = field(\n        default_factory=lambda: {\n            \"proxy\": None,\n        },\n    )\n\n    async def set_proxy(self, user_id: UUID, proxy_id: UUID) -> None:\n        async with self.session_maker() as session:\n            async with session.begin():\n                proxy = await session.get(Proxy, proxy_id, options=[joinedload(Proxy.user)])\n                if proxy is None:\n                    raise NoResultFoundException(f\"Proxy {proxy_id} not found\")\n\n                if not proxy.is_free:\n                    raise ProxyIsUnavailable(f\"Proxy {proxy.id} is in use by user {proxy.user.id}\")\n\n                proxy.is_free = False\n\n                user = await session.get(self.entity, user_id)\n                user.proxy_id = proxy_id\n\n    async def get_by_username(self, username: str) -> Optional[User]:\n        try:\n            async with self.session_maker() as session:\n                if self.options:\n                    res = await session.execute(\n                        select(self.entity)\n                        .where(self.entity.telegram_username == username)\n                        .options(*self.options)\n                    )\n                    user = res.unique().scalars().one()\n                else:\n                    res = await session.execute(\n                        select(self.entity)\n                        .where(self.entity.telegram_username == username)\n                    )\n                    user = res.scalars().one()\n        except NoResultFound:\n            return None\n\n        return self.entity_to_model(user)\n\n    async def get_by_telegram_id(self, telegram_id: int) -> Optional[User]:\n        try:\n            async with self.session_maker() as session:\n                if self.options:\n                    res = await session.execute(\n                        select(self.entity)\n                        .where(self.entity.telegram_id == telegram_id)\n                        .options(*self.options)\n                    )\n                    user = res.unique().scalars().one()\n                else:\n                    res = await session.execute(\n                        select(self.entity)\n                        .where(self.entity.telegram_id == telegram_id)\n                    )\n                    user = res.scalars().one()\n\n        except NoResultFound:\n            return None\n\n        return self.entity_to_model(user)\n\n    def create_dto_to_entity(self, dto: CreateUserDTO) -> User:\n        return User(\n            id=dto.id,\n            telegram_id=dto.telegram_id,\n            telegram_username=dto.telegram_username,\n            telegram_last_name=dto.telegram_last_name,\n            telegram_first_name=dto.telegram_first_name,\n            telegram_language_code=dto.telegram_language_code,\n            role=dto.role,\n            assistant_enabled=dto.assistant_enabled,\n            session_string=dto.session_string,\n            created_at=dto.created_at,\n            updated_at=dto.updated_at,\n        )\n\n    def entity_to_model(self, entity: User) -> User:\n        def _map_proxy(proxy: Proxy) -> ProxyModel:\n            return ProxyModel(\n                id=proxy.id,\n                proxy_string=proxy.proxy_string,\n                is_free=proxy.is_free,\n                is_deprecated=proxy.is_deprecated,\n                created_at=proxy.created_at,\n                updated_at=proxy.updated_at,\n            )\n\n        return UserModel(\n            id=entity.id,\n            telegram_id=entity.telegram_id,\n            telegram_username=entity.telegram_username,\n            telegram_last_name=entity.telegram_last_name,\n            telegram_first_name=entity.telegram_first_name,\n            telegram_language_code=entity.telegram_language_code,\n            role=entity.role,\n            assistant_enabled=entity.assistant_enabled,\n            session_string=entity.session_string,\n            proxy_id=entity.proxy_id,\n            proxy=_map_proxy(entity.proxy) if entity.proxy else None,\n            created_at=entity.created_at,\n            updated_at=entity.updated_at,\n        )\n"
  },
  {
    "path": "shared/src/shared/infrastructure/main_db/repositories/story_to_publish.py",
    "content": "from dataclasses import dataclass, field\nfrom typing import Optional\n\nfrom shared.abstractions.repositories import StoryToPublishRepositoryInterface\nfrom shared.domain.dto import CreateStoryToPublishDTO, UpdateStoryToPublishDTO\nfrom shared.domain.models import StoryToPublish as StoryToPublishModel, User as UserModel, Story as StoryModel\nfrom shared.infrastructure.main_db.entities import StoryToPublish, User, Story\nfrom .abstract import AbstractMainDBRepository\n\n\n@dataclass\nclass StoryToPublishRepository(\n    AbstractMainDBRepository[StoryToPublish, StoryToPublishModel, CreateStoryToPublishDTO, UpdateStoryToPublishDTO],\n    StoryToPublishRepositoryInterface,\n):\n    joined_fields: dict[str, Optional[list[str]]] = field(default_factory=lambda: {\n        \"manager\": None,\n        \"story\": None,\n    })\n\n    def create_dto_to_entity(self, dto: CreateStoryToPublishDTO) -> StoryToPublish:\n        return StoryToPublish(\n            id=dto.id,\n            story_id=dto.story_id,\n            manager_id=dto.manager_id,\n            scheduled_type=dto.scheduled_type,\n            scheduled_date=dto.scheduled_date,\n            scheduled_time=dto.scheduled_time,\n            status=dto.status,\n            created_at=dto.created_at,\n            updated_at=dto.updated_at,\n        )\n\n    def entity_to_model(self, entity: StoryToPublish) -> StoryToPublishModel:\n        def _map_user(user: User) -> UserModel:\n            return UserModel(\n                id=user.id,\n                telegram_id=user.telegram_id,\n                telegram_username=user.telegram_username,\n                telegram_last_name=user.telegram_last_name,\n                telegram_first_name=user.telegram_first_name,\n                telegram_language_code=user.telegram_language_code,\n                role=user.role,\n                assistant_enabled=user.assistant_enabled,\n                created_at=user.created_at,\n                updated_at=user.updated_at,\n            )\n\n        def _map_story(story: Story) -> StoryModel:\n            return StoryModel(\n                id=story.id,\n                text=story.text,\n                name=story.name,\n                file_path=story.file_path,\n                created_at=story.created_at,\n                updated_at=story.updated_at,\n            )\n\n        return StoryToPublishModel(\n            id=entity.id,\n            story_id=entity.story_id,\n            manager_id=entity.manager_id,\n            scheduled_type=entity.scheduled_type,\n            scheduled_date=entity.scheduled_date,\n            scheduled_time=entity.scheduled_time,\n            status=entity.status,\n            manager=_map_user(entity.manager),\n            story=_map_story(entity.story),\n            created_at=entity.created_at,\n            updated_at=entity.updated_at,\n        )\n"
  },
  {
    "path": "shared/src/shared/infrastructure/main_db/repositories/story_request.py",
    "content": "from dataclasses import dataclass, field\nfrom typing import Optional\n\nfrom sqlalchemy import select\n\nfrom shared.abstractions.repositories import PublishStoryRequestRepositoryInterface\nfrom shared.domain.dto import CreatePublishStoryRequestDTO, UpdatePublishStoryRequestDTO\nfrom shared.domain.enums import PublishStoryRequestStatus\nfrom shared.domain.models import (\n    Story as StoryModel,\n    PublishStoryRequest as PublishStoryRequestModel,\n    User as UserModel,\n)\nfrom shared.infrastructure.main_db.entities import Story, PublishStoryRequest, User\nfrom .abstract import AbstractMainDBRepository\n\n\n@dataclass\nclass PublishStoryRequestRepository(\n    AbstractMainDBRepository[\n        PublishStoryRequest, PublishStoryRequestModel, CreatePublishStoryRequestDTO, UpdatePublishStoryRequestDTO],\n    PublishStoryRequestRepositoryInterface,\n):\n    joined_fields: dict[str, Optional[list[str]]] = field(default_factory=lambda: {\n        \"user\": None,\n        \"story\": None,\n    })\n\n    async def get_queued_message(self) -> Optional[PublishStoryRequest]:\n        async with self.session_maker() as session:\n            result = await session.execute(\n                select(self.entity)\n                .where(self.entity.status == PublishStoryRequestStatus.PLANNED)\n                .order_by(self.entity.created_at)\n                .options(*self.options)\n                .limit(1)\n            )  # todo: batching?\n\n            message = result.unique().scalars().one_or_none()\n\n        return self.entity_to_model(message) if message else None\n\n    def create_dto_to_entity(self, dto: CreatePublishStoryRequestDTO) -> PublishStoryRequest:\n        return PublishStoryRequest(\n            id=dto.id,\n            story_id=dto.story_id,\n            user_id=dto.user_id,\n            scheduled_at=dto.scheduled_at,\n            status=dto.status,\n            published_at=dto.published_at,\n            publication_id=dto.publication_id,\n            created_at=dto.created_at,\n            updated_at=dto.updated_at,\n        )\n\n    def entity_to_model(self, entity: PublishStoryRequest) -> PublishStoryRequest:\n        def _map_user(user: User) -> UserModel:\n            return UserModel(\n                id=user.id,\n                telegram_id=user.telegram_id,\n                telegram_username=user.telegram_username,\n                telegram_last_name=user.telegram_last_name,\n                telegram_first_name=user.telegram_first_name,\n                telegram_language_code=user.telegram_language_code,\n                role=user.role,\n                assistant_enabled=user.assistant_enabled,\n                created_at=user.created_at,\n                updated_at=user.updated_at,\n            )\n\n        def _map_story(story: Story) -> StoryModel:\n            return StoryModel(\n                id=story.id,\n                name=story.name,\n                text=story.text,\n                file_path=story.file_path,\n                created_at=story.created_at,\n                updated_at=story.updated_at,\n            )\n\n        return PublishStoryRequestModel(\n            id=entity.id,\n            story_id=entity.story_id,\n            user_id=entity.user_id,\n            scheduled_at=entity.scheduled_at,\n            status=entity.status,\n            published_at=entity.published_at,\n            publication_id=entity.publication_id,\n            created_at=entity.created_at,\n            updated_at=entity.updated_at,\n            user=_map_user(entity.user),\n            story=_map_story(entity.story),\n        )\n"
  },
  {
    "path": "shared/src/shared/infrastructure/main_db/repositories/post_request.py",
    "content": "from dataclasses import dataclass, field\nfrom typing import Optional\nfrom uuid import UUID\n\nfrom shared.abstractions.repositories import SendPostRequestRepositoryInterface\nfrom shared.domain.dto import CreateSendPostRequestDTO, UpdateSendPostRequestDTO\nfrom shared.domain.dto.post_to_publish import MessageEntityDTO\nfrom shared.domain.enums import SendPostRequestStatus\nfrom shared.domain.models import (\n    Chat as ChatModel,\n    Post as PostModel,\n    SendPostRequest as SendPostRequestModel,\n    User as UserModel, SendingRequest,\n)\nfrom shared.infrastructure.main_db.entities import Chat, Post, SendPostRequest, User\nfrom sqlalchemy import select\n\nfrom .abstract import AbstractMainDBRepository\n\n\n@dataclass\nclass SendPostRequestRepository(\n    AbstractMainDBRepository[SendPostRequest, SendPostRequestModel, CreateSendPostRequestDTO, UpdateSendPostRequestDTO],\n    SendPostRequestRepositoryInterface,\n):\n    joined_fields: dict[str, Optional[list[str]]] = field(default_factory=lambda: {\n        \"user\": None,\n        \"chat\": None,\n        \"post\": None,\n    })\n\n    async def get_requests_from_same_publication(self, request_id: UUID) -> list[SendPostRequestModel]:\n        async with self.session_maker() as session:\n            request = await session.get(self.entity, request_id)\n            requests_result = await session.execute(\n                select(self.entity)\n                .where(self.entity.publication_id == request.publication_id)\n                .order_by(self.entity.created_at)\n                .options(*self.options)\n            )\n            requests = requests_result.unique().scalars().all()\n\n        return [self.entity_to_model(request) for request in requests]\n\n    async def get_queued_message(self) -> Optional[SendPostRequest]:\n        async with self.session_maker() as session:\n            result = await session.execute(\n                select(self.entity)\n                .where(self.entity.status == SendPostRequestStatus.PLANNED)\n                .order_by(self.entity.created_at)\n                .options(*self.options)\n                .limit(1)\n            )  # todo: batching?\n\n            message = result.unique().scalars().one_or_none()\n\n        return self.entity_to_model(message) if message else None\n\n    def create_dto_to_entity(self, dto: CreateSendPostRequestDTO) -> SendPostRequest:\n        return SendPostRequest(\n            id=dto.id,\n            post_id=dto.post_id,\n            chat_id=dto.chat_id,\n            user_id=dto.user_id,\n            scheduled_at=dto.scheduled_at,\n            publication_id=dto.publication_id,\n            status=dto.status,\n            sent_at=dto.sent_at,\n            created_at=dto.created_at,\n            updated_at=dto.updated_at,\n        )\n\n    def entity_to_model(self, entity: SendPostRequest) -> SendPostRequest:\n        def _map_user(user: User) -> UserModel:\n            return UserModel(\n                id=user.id,\n                telegram_id=user.telegram_id,\n                telegram_username=user.telegram_username,\n                telegram_last_name=user.telegram_last_name,\n                telegram_first_name=user.telegram_first_name,\n                telegram_language_code=user.telegram_language_code,\n                role=user.role,\n                assistant_enabled=user.assistant_enabled,\n                created_at=user.created_at,\n                updated_at=user.updated_at,\n            )\n\n        def _map_chat(chat: Chat) -> ChatModel:\n            return ChatModel(\n                id=chat.id,\n                chat_id=chat.chat_id,\n                name=chat.name,\n                invite_link=chat.invite_link,\n                created_at=chat.created_at,\n                updated_at=chat.updated_at,\n            )\n\n        def _map_post(post: Post) -> PostModel:\n            return PostModel(\n                id=post.id,\n                text=post.text,\n                name=post.name,\n                html=post.html,\n                entities=[MessageEntityDTO.model_validate(x) for x in post.entities] if post.entities else None,\n                image_path=post.image_path,\n                created_at=post.created_at,\n                updated_at=post.updated_at,\n            )\n\n        return SendPostRequestModel(\n            id=entity.id,\n            post_id=entity.post_id,\n            chat_id=entity.chat_id,\n            user_id=entity.user_id,\n            scheduled_at=entity.scheduled_at,\n            status=entity.status,\n            sent_at=entity.sent_at,\n            publication_id=entity.publication_id,\n            created_at=entity.created_at,\n            updated_at=entity.updated_at,\n            user=_map_user(entity.user),\n            chat=_map_chat(entity.chat),\n            post=_map_post(entity.post),\n        )\n"
  },
  {
    "path": "shared/src/shared/infrastructure/main_db/repositories/emoji.py",
    "content": "from dataclasses import dataclass\n\nfrom shared.abstractions.repositories.emojis import EmojisRepositoryInterface\nfrom shared.domain.dto.emoji import CreateEmojiDTO, UpdateEmojiDTO\nfrom shared.domain.models.emoji import Emoji as EmojiModel\nfrom shared.infrastructure.main_db.entities import Emoji\nfrom .abstract import AbstractMainDBRepository\n\n\n@dataclass\nclass EmojiRepository(\n    AbstractMainDBRepository[Emoji, EmojiModel, CreateEmojiDTO, UpdateEmojiDTO],\n    EmojisRepositoryInterface,\n):\n    def create_dto_to_entity(self, dto: CreateEmojiDTO) -> Emoji:\n        return Emoji(\n            id=dto.id,\n            name=dto.name,\n            custom_emoji_id=dto.custom_emoji_id,\n            img_url=dto.img_url,\n            created_at=dto.created_at,\n            updated_at=dto.updated_at,\n        )\n\n    def entity_to_model(self, entity: Emoji) -> Emoji:\n        return EmojiModel(\n            id=entity.id,\n            name=entity.name,\n            custom_emoji_id=entity.custom_emoji_id,\n            img_url=entity.img_url,\n            created_at=entity.created_at,\n            updated_at=entity.updated_at,\n        )\n"
  },
  {
    "path": "shared/src/shared/infrastructure/main_db/repositories/proxy.py",
    "content": "from dataclasses import dataclass, field\nfrom typing import Optional, List\n\nfrom sqlalchemy import select, func\n\nfrom shared.abstractions.repositories import ProxyRepositoryInterface\nfrom shared.domain.dto import CreateProxyDTO, UpdateProxyDTO\nfrom shared.domain.models import Proxy as ProxyModel, User as UserModel\nfrom shared.infrastructure.main_db.entities import Proxy, User\nfrom .abstract import AbstractMainDBRepository\nfrom .exceptions import NoFreeProxiesException\n\n\n@dataclass\nclass ProxyRepository(\n    AbstractMainDBRepository[Proxy, ProxyModel, CreateProxyDTO, UpdateProxyDTO],\n    ProxyRepositoryInterface,\n):\n    # joined_fields: dict[str, Optional[List[str]]] = field(\n    #     default_factory=lambda: {\n    #         'user': None,\n    #     },\n    # )\n\n    async def get_available_proxies_count(self) -> int:\n        async with self.session_maker() as session:  # session: AsyncSession\n            result = await session.execute(\n                select(func.count(self.entity.id))\n                .where(\n                    self.entity.is_free == True,\n                    self.entity.is_deprecated == False,\n                )\n            )\n            return result.scalar()\n\n    async def get_available_proxy(self) -> ProxyModel:\n        async with self.session_maker() as session:\n            result = await session.execute(\n                select(self.entity)\n                .where(\n                    self.entity.is_free == True,\n                    self.entity.is_deprecated == False,\n                )\n                .order_by(self.entity.created_at)\n                .limit(1)\n            )\n\n            result = result.scalars().one_or_none()\n            if result is None:\n                raise NoFreeProxiesException\n\n        return self.entity_to_model(result)\n\n    def create_dto_to_entity(self, dto: CreateProxyDTO) -> Proxy:\n        return Proxy(\n            id=dto.id,\n            proxy_string=dto.proxy_string,\n            is_free=dto.is_free,\n            is_deprecated=dto.is_deprecated,\n            created_at=dto.created_at,\n            updated_at=dto.updated_at,\n        )\n\n    def entity_to_model(self, entity: Proxy) -> ProxyModel:\n        def _map_user(user: User) -> UserModel:\n            return None  # noqa\n\n        return ProxyModel(\n            id=entity.id,\n            proxy_string=entity.proxy_string,\n            is_free=entity.is_free,\n            is_deprecated=entity.is_deprecated,\n            created_at=entity.created_at,\n            updated_at=entity.updated_at,\n        )\n"
  },
  {
    "path": "shared/src/shared/infrastructure/main_db/repositories/post_to_publish.py",
    "content": "from dataclasses import dataclass, field\nfrom typing import Optional\nfrom uuid import UUID\n\nfrom sqlalchemy import select\n\nfrom shared.abstractions.repositories import PostToPublishRepositoryInterface\nfrom shared.domain.dto import CreatePostToPublishDTO, UpdatePostToPublishDTO\nfrom shared.domain.dto.post_to_publish import MessageEntityDTO\nfrom shared.domain.enums import PublicationStatus\nfrom shared.domain.models import PostToPublish as PostToPublishModel, User as UserModel, Chat as ChatModel, Post as PostModel\nfrom shared.infrastructure.main_db.entities import PostToPublish, User, Chat, Post\nfrom .abstract import AbstractMainDBRepository\n\n\n@dataclass\nclass PostToPublishRepository(\n    AbstractMainDBRepository[PostToPublish, PostToPublishModel, CreatePostToPublishDTO, UpdatePostToPublishDTO],\n    PostToPublishRepositoryInterface,\n):\n    joined_fields: dict[str, Optional[list[str]]] = field(default_factory=lambda: {\n        \"manager\": None,\n        \"chats\": None,\n        \"post\": None,\n    })\n\n    async def get_queued_post(self) -> Optional[PostToPublish]:\n        async with self.session_maker() as session:\n            result = await session.execute(\n                select(self.entity)\n                .where(self.entity.status == PublicationStatus.PENDING)\n                .order_by(self.entity.created_at)\n                .options(*self.options)\n                .limit(1)\n            )\n\n            post = result.unique().scalars().one_or_none()\n\n        return self.entity_to_model(post) if post else None\n\n    async def set_status(self, post_id: UUID, status: PublicationStatus) -> None:\n        async with self.session_maker() as session:\n            async with session.begin():\n                post = await session.get(self.entity, post_id)\n                post.status = status\n\n\n    async def create(self, obj: CreatePostToPublishDTO) -> UUID:\n        async with self.session_maker() as session:\n            async with session.begin():\n                chats = await session.execute(\n                    select(Chat)\n                    .where(Chat.id.in_(obj.chat_ids))\n                )\n\n                post = self.create_dto_to_entity(obj)\n                post.chats = chats.scalars().all()\n                session.add(post)\n\n        return post.id\n\n    def create_dto_to_entity(self, dto: CreatePostToPublishDTO) -> PostToPublish:\n        return PostToPublish(\n            id=dto.id,\n            post_id=dto.post_id,\n            manager_id=dto.manager_id,\n            scheduled_type=dto.scheduled_type,\n            scheduled_date=dto.scheduled_date,\n            scheduled_time=dto.scheduled_time,\n            status=dto.status,\n            created_at=dto.created_at,\n            updated_at=dto.updated_at\n        )\n\n    def entity_to_model(self, entity: PostToPublish) -> PostToPublishModel:\n        def _map_user(user: User) -> UserModel:\n            return UserModel(\n                id=user.id,\n                telegram_id=user.telegram_id,\n                telegram_username=user.telegram_username,\n                telegram_last_name=user.telegram_last_name,\n                telegram_first_name=user.telegram_first_name,\n                telegram_language_code=user.telegram_language_code,\n                role=user.role,\n                assistant_enabled=user.assistant_enabled,\n                created_at=user.created_at,\n                updated_at=user.updated_at,\n            )\n\n        def _map_chat(chat: Chat) -> ChatModel:\n            return ChatModel(\n                id=chat.id,\n                chat_id=chat.chat_id,\n                name=chat.name,\n                invite_link=chat.invite_link,\n                created_at=chat.created_at,\n                updated_at=chat.updated_at,\n            )\n\n        def _map_post(post: Post) -> PostModel:\n            return PostModel(\n                id=post.id,\n                text=post.text,\n                name=post.name,\n                html=post.html,\n                entities=[MessageEntityDTO.model_validate(x) for x in post.entities] if post.entities else None,\n                image_path=post.image_path,\n                created_at=post.created_at,\n                updated_at=post.updated_at,\n            )\n\n        return PostToPublishModel(\n            id=entity.id,\n            post_id=entity.post_id,\n            manager_id=entity.manager_id,\n            scheduled_type=entity.scheduled_type,\n            scheduled_date=entity.scheduled_date,\n            scheduled_time=entity.scheduled_time,\n            status=entity.status,\n            manager=_map_user(entity.manager),\n            chats=[_map_chat(x) for x in entity.chats],\n            post=_map_post(entity.post),\n            created_at=entity.created_at,\n            updated_at=entity.updated_at,\n        )\n"
  },
  {
    "path": "shared/src/shared/infrastructure/main_db/repositories/__init__.py",
    "content": "from .user import UserRepository\nfrom .chat import ChatRepository\nfrom .post import PostRepository\nfrom .story import StoryRepository\nfrom .post_request import SendPostRequestRepository\nfrom .story_request import PublishStoryRequestRepository\nfrom .story_to_publish import StoryToPublishRepository\nfrom .post_to_publish import PostToPublishRepository\nfrom .worker_message import WorkerMessageRepository\nfrom .proxy import ProxyRepository\n\nfrom .exceptions import NoFreeProxiesException\n\n__all__ = [\n    \"UserRepository\",\n    \"ChatRepository\",\n    \"PostRepository\",\n    \"StoryRepository\",\n    \"SendPostRequestRepository\",\n    \"PublishStoryRequestRepository\",\n    \"StoryToPublishRepository\",\n    \"PostToPublishRepository\",\n    \"WorkerMessageRepository\",\n    \"ProxyRepository\",\n    \"NoFreeProxiesException\",\n]\n"
  },
  {
    "path": "shared/src/shared/infrastructure/main_db/repositories/chat.py",
    "content": "from dataclasses import dataclass\nfrom typing import Optional\n\nfrom sqlalchemy import select\nfrom sqlalchemy.exc import NoResultFound\n\nfrom shared.abstractions.repositories import ChatRepositoryInterface\nfrom shared.domain.dto import CreateChatDTO, UpdateChatDTO\nfrom shared.domain.models import Chat as ChatModel\nfrom shared.infrastructure.main_db.entities import Chat\nfrom .abstract import AbstractMainDBRepository\n\n\n@dataclass\nclass ChatRepository(\n    AbstractMainDBRepository[Chat, ChatModel, CreateChatDTO, UpdateChatDTO],\n    ChatRepositoryInterface,\n):\n    async def get_by_telegram_id(self, telegram_id: int) -> Optional[Chat]:\n        try:\n            async with self.session_maker() as session:\n                if self.options:\n                    res = await session.execute(\n                        select(self.entity)\n                        .where(self.entity.telegram_id == telegram_id)\n                        .options(*self.options)\n                    )\n                    chat = res.unique().scalars().one()\n                else:\n                    res = await session.execute(\n                        select(self.entity)\n                        .where(self.entity.telegram_id == telegram_id)\n                    )\n                    chat = res.scalars().one()\n\n        except NoResultFound:\n            return None\n\n        return self.entity_to_model(chat)\n\n    async def get_by_invite_link(self, invite_link: str) -> Chat:\n        try:\n            async with self.session_maker() as session:\n                if self.options:\n                    res = await session.execute(\n                        select(self.entity)\n                        .where(self.entity.invite_link == invite_link)\n                        .options(*self.options)\n                    )\n                    chat = res.unique().scalars().one()\n                else:\n                    res = await session.execute(\n                        select(self.entity)\n                        .where(self.entity.invite_link == invite_link)\n                    )\n                    chat = res.scalars().one()\n\n        except NoResultFound:\n            return None\n\n        return self.entity_to_model(chat)\n\n\n    def create_dto_to_entity(self, dto: CreateChatDTO) -> Chat:\n        return Chat(\n            id=dto.id,\n            invite_link=dto.invite_link,\n            chat_id=dto.chat_id,\n            name=dto.name,\n            created_at=dto.created_at,\n            updated_at=dto.updated_at,\n        )\n\n    def entity_to_model(self, entity: Chat) -> Chat:\n        return ChatModel(\n            id=entity.id,\n            invite_link=entity.invite_link,\n            chat_id=entity.chat_id,\n            name=entity.name,\n            created_at=entity.created_at,\n            updated_at=entity.updated_at,\n        )\n"
  },
  {
    "path": "shared/src/shared/infrastructure/main_db/repositories/exceptions.py",
    "content": "class NoFreeProxiesException(Exception):\n    ...\n\n\nclass ProxyIsUnavailable(Exception):\n    ...\n\n\nclass NoResultFoundException(Exception):\n    ...\n"
  },
  {
    "path": "shared/src/shared/domain/__init__.py",
    "content": ""
  },
  {
    "path": "shared/src/shared/domain/dto/abstract.py",
    "content": "from datetime import datetime\nfrom uuid import UUID, uuid4\n\nfrom pydantic import BaseModel, Field\n\n\nclass CreateDTO(BaseModel):\n    id: UUID = Field(default_factory=uuid4)\n    created_at: datetime = Field(default_factory=datetime.now)\n    updated_at: datetime = Field(default_factory=datetime.now)\n\n\nclass UpdateDTO(BaseModel):\n    updated_at: datetime = Field(default_factory=datetime.now)\n"
  },
  {
    "path": "shared/src/shared/domain/dto/worker_message.py",
    "content": "from datetime import datetime\nfrom typing import Optional\nfrom uuid import UUID\n\nfrom shared.domain.dto.abstract import CreateDTO, UpdateDTO\nfrom shared.domain.dto.post_to_publish import MessageEntityDTO\nfrom shared.domain.enums import WorkerMessageType, WorkerMessageStatus\n\n\nclass CreateWorkerMessageDTO(CreateDTO):\n    user_id: UUID\n    chat_id: int\n    type: WorkerMessageType\n    text: Optional[str] = None\n    media_path: Optional[str] = None\n    status: WorkerMessageStatus\n    sent_at: Optional[datetime] = None\n\n    request_id: Optional[UUID] = None\n\n    entities: Optional[list[MessageEntityDTO]] = None\n\n\nclass UpdateWorkerMessageDTO(UpdateDTO):\n    user_id: Optional[UUID] = None\n    chat_id: Optional[int] = None\n    type: Optional[WorkerMessageType] = None\n    text: Optional[str] = None\n    media_path: Optional[str] = None\n    status: Optional[WorkerMessageStatus] = None\n    sent_at: Optional[datetime] = None\n\n    request_id: Optional[UUID] = None\n\n    entities: Optional[list[MessageEntityDTO]] = None\n"
  },
  {
    "path": "shared/src/shared/domain/dto/post.py",
    "content": "from typing import Optional, List\n\nfrom pydantic import field_validator\nfrom pydantic_core.core_schema import FieldValidationInfo\n\nfrom .abstract import CreateDTO, UpdateDTO\nfrom .post_to_publish import MessageEntityDTO\n\n\nclass CreatePostDTO(CreateDTO):\n    name: str\n    text: str\n    image_path: Optional[str] = None\n\n    html: Optional[str] = None\n    entities: Optional[list[MessageEntityDTO]] = None\n\n    @field_validator(\"entities\", mode=\"after\")\n    def check_bounds(cls, entities: List[MessageEntityDTO], info: FieldValidationInfo) -> List[MessageEntityDTO]:\n        txt = info.data.get(\"text\", \"\")\n        custom_emojis = 0\n        for e in entities:\n            if e.type == 'custom_emoji':\n                custom_emojis += 1\n\n            text_len = len(txt) + custom_emojis\n            if not (0 <= e.offset < text_len and e.offset + e.length <= text_len):\n                raise ValueError(\n                    f\"Entity out of bounds: offset={e.offset} length={e.length} for text of length {len(txt)}\")\n\n        return entities\n\n\nclass UpdatePostDTO(UpdateDTO):\n    name: Optional[str] = None\n    text: Optional[str] = None\n    image_path: Optional[str] = None\n    html: Optional[str] = None\n    entities: Optional[list[MessageEntityDTO]] = None\n\n    @field_validator(\"entities\", mode=\"after\")\n    def check_bounds(cls, entities: List[MessageEntityDTO], info: FieldValidationInfo) -> List[MessageEntityDTO]:\n        txt = info.data.get(\"text\", \"\")\n        if not txt:\n            return entities\n\n        custom_emojis = 0\n        for e in entities:\n            if e.type == 'custom_emoji':\n                custom_emojis += 1\n\n            text_len = len(txt) + custom_emojis\n            if not (0 <= e.offset < text_len and e.offset + e.length <= text_len):\n                raise ValueError(\n                    f\"Entity out of bounds: offset={e.offset} length={e.length} for text of length {len(txt)}\")\n\n        return entities\n"
  },
  {
    "path": "shared/src/shared/domain/dto/service.py",
    "content": "from typing import Optional\n\nfrom .abstract import UpdateDTO, CreateDTO\n\n\nclass CreateServiceDTO(CreateDTO):\n    name: str\n    is_active: bool\n\n\nclass UpdateServiceDTO(UpdateDTO):\n    name: Optional[str] = None\n    is_active: Optional[bool] = None\n"
  },
  {
    "path": "shared/src/shared/domain/dto/story.py",
    "content": "from typing import Optional\n\nfrom .abstract import CreateDTO, UpdateDTO\n\n\nclass CreateStoryDTO(CreateDTO):\n    name: str\n    file_path: str\n    text: Optional[str] = None\n\n\nclass UpdateStoryDTO(UpdateDTO):\n    name: Optional[str] = None\n    file_path: Optional[str] = None\n    text: Optional[str] = None\n"
  },
  {
    "path": "shared/src/shared/domain/dto/user.py",
    "content": "from typing import Optional\nfrom uuid import UUID\n\nfrom .abstract import CreateDTO, UpdateDTO\nfrom shared.domain.enums import UserRole\n\n\nclass CreateUserDTO(CreateDTO):\n    telegram_id: int\n    telegram_username: Optional[str] = None\n    telegram_first_name: Optional[str] = None\n    telegram_last_name: Optional[str] = None\n    telegram_language_code: Optional[str] = None\n\n    role: UserRole\n\n    session_string: Optional[str] = None\n    assistant_enabled: bool\n\n\nclass UpdateUserDTO(UpdateDTO):\n    telegram_username: Optional[str] = None\n    telegram_first_name: Optional[str] = None\n    telegram_last_name: Optional[str] = None\n    telegram_language_code: Optional[str] = None\n\n    role: Optional[UserRole] = None\n\n    session_string: Optional[str] = None\n    assistant_enabled: Optional[bool] = None\n"
  },
  {
    "path": "shared/src/shared/domain/dto/story_to_publish.py",
    "content": "from datetime import date, time\nfrom typing import Optional\nfrom uuid import UUID\n\nfrom shared.domain.enums import ScheduledType, PublicationStatus\nfrom .abstract import UpdateDTO, CreateDTO\n\n\nclass CreateStoryToPublishDTO(CreateDTO):\n    story_id: UUID\n    manager_id: UUID\n    scheduled_type: ScheduledType\n    scheduled_date: Optional[date]\n    scheduled_time: time\n    status: PublicationStatus\n\n\nclass UpdateStoryToPublishDTO(UpdateDTO):\n    story_id: Optional[UUID] = None\n    manager_id: Optional[UUID] = None\n    scheduled_type: Optional[ScheduledType] = None\n    scheduled_date: Optional[date] = None\n    scheduled_time: Optional[time] = None\n    status: Optional[PublicationStatus] = None\n"
  },
  {
    "path": "shared/src/shared/domain/dto/story_request.py",
    "content": "from datetime import datetime\nfrom typing import Optional\nfrom uuid import UUID\n\nfrom .abstract import CreateDTO, UpdateDTO\nfrom shared.domain.enums import SendPostRequestStatus, PublishStoryRequestStatus\n\n\nclass CreatePublishStoryRequestDTO(CreateDTO):\n    story_id: UUID\n    user_id: UUID\n    scheduled_at: Optional[datetime] = None\n\n    publication_id: UUID\n\n    status: PublishStoryRequestStatus\n    published_at: Optional[datetime] = None\n\n\nclass UpdatePublishStoryRequestDTO(UpdateDTO):\n    story_id: Optional[UUID] = None\n    user_id: Optional[UUID] = None\n    scheduled_at: Optional[datetime] = None\n    publication_id: Optional[UUID] = None\n    status: Optional[PublishStoryRequestStatus] = None\n    published_at: Optional[datetime] = None\n"
  },
  {
    "path": "shared/src/shared/domain/dto/post_request.py",
    "content": "from datetime import datetime\nfrom typing import Optional\nfrom uuid import UUID\n\nfrom .abstract import CreateDTO, UpdateDTO\nfrom shared.domain.enums import SendPostRequestStatus\n\n\nclass CreateSendPostRequestDTO(CreateDTO):\n    post_id: UUID\n    chat_id: UUID\n    user_id: UUID\n    scheduled_at: Optional[datetime] = None\n    publication_id: UUID\n    status: SendPostRequestStatus\n    sent_at: Optional[datetime] = None\n\n\nclass UpdateSendPostRequestDTO(UpdateDTO):\n    post_id: Optional[UUID] = None\n    chat_id: Optional[UUID] = None\n    user_id: Optional[UUID] = None\n    publication_id: Optional[UUID] = None\n    scheduled_at: Optional[datetime] = None\n    status: Optional[SendPostRequestStatus] = None\n    sent_at: Optional[datetime] = None\n"
  },
  {
    "path": "shared/src/shared/domain/dto/emoji.py",
    "content": "from typing import Optional\n\nfrom .abstract import CreateDTO, UpdateDTO\n\nclass CreateEmojiDTO(CreateDTO):\n    name: str\n    custom_emoji_id: str\n    img_url: str\n\n\nclass UpdateEmojiDTO(UpdateDTO):\n    name: Optional[str] = None\n    custom_emoji_id: Optional[str] = None\n    img_url: Optional[str] = None\n"
  },
  {
    "path": "shared/src/shared/domain/dto/proxy.py",
    "content": "from typing import Optional\n\nfrom .abstract import CreateDTO, UpdateDTO\n\n\nclass CreateProxyDTO(CreateDTO):\n    proxy_string: str\n    is_free: bool = True\n    is_deprecated: bool = False\n\n\nclass UpdateProxyDTO(UpdateDTO):\n    proxy_string: Optional[str] = None\n    is_free: Optional[bool] = None\n    is_deprecated: Optional[bool] = None\n"
  },
  {
    "path": "shared/src/shared/domain/dto/post_to_publish.py",
    "content": "from datetime import date, time\nfrom typing import Optional, List\nfrom uuid import UUID\n\nfrom pydantic import BaseModel, field_validator, ConfigDict\nfrom pydantic_core.core_schema import FieldValidationInfo\n\nfrom shared.domain.enums import ScheduledType, PublicationStatus\nfrom .abstract import CreateDTO, UpdateDTO\n\n\nclass MessageEntityDTO(BaseModel):\n    type: str\n    offset: int\n    length: int\n    custom_emoji_id: Optional[int] = None\n\n    model_config = ConfigDict(from_attributes=True)\n\n\nclass CreatePostToPublishDTO(CreateDTO):\n    post_id: UUID\n    manager_id: UUID\n    scheduled_type: ScheduledType\n    scheduled_date: Optional[date] = None\n    scheduled_time: time\n    chat_ids: list[UUID]\n    status: PublicationStatus\n\n\nclass UpdatePostToPublishDTO(UpdateDTO):\n    post_id: Optional[UUID] = None\n    manager_id: Optional[UUID] = None\n    scheduled_type: Optional[ScheduledType] = None\n    scheduled_date: Optional[date] = None\n    scheduled_time: Optional[time] = None\n    chat_ids: Optional[list[UUID]] = None\n    status: Optional[PublicationStatus] = None\n"
  },
  {
    "path": "shared/src/shared/domain/dto/__init__.py",
    "content": "from .user import CreateUserDTO, UpdateUserDTO\nfrom .post import CreatePostDTO, UpdatePostDTO\nfrom .chat import CreateChatDTO, UpdateChatDTO\nfrom .post_request import CreateSendPostRequestDTO, UpdateSendPostRequestDTO\nfrom .story_request import CreatePublishStoryRequestDTO, UpdatePublishStoryRequestDTO\nfrom .worker_message import CreateWorkerMessageDTO, UpdateWorkerMessageDTO\nfrom .story_to_publish import CreateStoryToPublishDTO, UpdateStoryToPublishDTO\nfrom .post_to_publish import CreatePostToPublishDTO, UpdatePostToPublishDTO\nfrom .service import CreateServiceDTO, UpdateServiceDTO\nfrom .proxy import CreateProxyDTO, UpdateProxyDTO\n\n__all__ = [\n    \"CreateUserDTO\",\n    \"UpdateUserDTO\",\n    \"CreatePostDTO\",\n    \"UpdatePostDTO\",\n    \"CreateChatDTO\",\n    \"UpdateChatDTO\",\n    \"CreateSendPostRequestDTO\",\n    \"UpdateSendPostRequestDTO\",\n    \"CreatePublishStoryRequestDTO\",\n    \"UpdatePublishStoryRequestDTO\",\n    \"CreateWorkerMessageDTO\",\n    \"UpdateWorkerMessageDTO\",\n    \"CreatePostToPublishDTO\",\n    \"UpdatePostToPublishDTO\",\n    \"CreateStoryToPublishDTO\",\n    \"UpdateStoryToPublishDTO\",\n    \"CreateServiceDTO\",\n    \"UpdateServiceDTO\",\n    \"CreateProxyDTO\",\n    \"UpdateProxyDTO\",\n]\n"
  },
  {
    "path": "shared/src/shared/domain/dto/chat.py",
    "content": "from typing import Optional\n\nfrom .abstract import CreateDTO, UpdateDTO\n\n\nclass CreateChatDTO(CreateDTO):\n    name: str\n    chat_id: int\n    invite_link: Optional[str] = None\n\n\nclass UpdateChatDTO(UpdateDTO):\n    name: Optional[str] = None\n    chat_id: Optional[int] = None\n    invite_link: Optional[str] = None\n"
  },
  {
    "path": "shared/src/shared/domain/enums/user_role.py",
    "content": "from enum import Enum\n\n\nclass UserRole(Enum):\n    MANAGER = \"manager\"\n    ADMIN = \"admin\"\n"
  },
  {
    "path": "shared/src/shared/domain/enums/__init__.py",
    "content": "from typing import TypeVar\n\nfrom .scheduled_type import ScheduledType\nfrom .worker_message_type import WorkerMessageType\nfrom .worker_message_status import WorkerMessageStatus\nfrom .publication_status import PublicationStatus\nfrom .send_post_request_status import SendPostRequestStatus\nfrom .publish_story_request_status import PublishStoryRequestStatus\nfrom .user_role import UserRole\n\nRequestStatus = TypeVar(\"RequestStatus\", SendPostRequestStatus, PublishStoryRequestStatus)\n\n__all__ = [\n    \"ScheduledType\",\n    \"WorkerMessageType\",\n    \"WorkerMessageStatus\",\n    \"PublicationStatus\",\n    \"SendPostRequestStatus\",\n    \"PublishStoryRequestStatus\",\n    \"UserRole\",\n    \"RequestStatus\",\n]\n"
  },
  {
    "path": "shared/src/shared/domain/enums/scheduled_type.py",
    "content": "from enum import StrEnum\n\n\nclass ScheduledType(StrEnum):\n    EVERYDAY = \"everyday\"\n    SINGLE = \"single\""
  },
  {
    "path": "shared/src/shared/domain/enums/worker_message_status.py",
    "content": "from enum import StrEnum\n\nclass WorkerMessageStatus(StrEnum):\n    PENDING = \"pending\"\n    IN_PROGRESS = \"in_progress\"\n    SENT = \"sent\"\n    FAILED = \"failed\"\n"
  },
  {
    "path": "shared/src/shared/domain/enums/worker_message_type.py",
    "content": "from enum import StrEnum\n\n\nclass WorkerMessageType(StrEnum):\n    POST = \"post\"\n    STORY = \"story\"\n\n"
  },
  {
    "path": "shared/src/shared/domain/enums/publication_status.py",
    "content": "from enum import StrEnum\n\n\nclass PublicationStatus(StrEnum):\n    PENDING = \"pending\"\n    SCHEDULED = \"scheduled\"\n    SCHEDULING = \"scheduling\"\n    IN_PROGRESS = \"in_progress\"\n    POSTED = \"posted\"\n    FAILED = \"failed\"\n    CANCELED = \"canceled\"\n"
  },
  {
    "path": "shared/src/shared/domain/enums/publish_story_request_status.py",
    "content": "from enum import StrEnum\n\n\nclass PublishStoryRequestStatus(StrEnum):\n    PLANNED = \"planned\"\n    IN_PROGRESS = \"in_progress\"\n    PUBLISHED = \"published\"\n    FAILED = \"failed\"\n    CANCELLED = \"cancelled\"\n"
  },
  {
    "path": "shared/src/shared/domain/enums/send_post_request_status.py",
    "content": "from enum import StrEnum\n\n\nclass SendPostRequestStatus(StrEnum):\n    PLANNED = \"planned\"\n    IN_PROGRESS = \"in_progress\"\n    SENT = \"sent\"\n    FAILED = \"failed\"\n    CANCELLED = \"cancelled\"\n"
  },
  {
    "path": "shared/src/shared/domain/models/abstract.py",
    "content": "from datetime import datetime\nfrom uuid import UUID\n\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass Model(BaseModel):\n    id: UUID\n    created_at: datetime\n    updated_at: datetime\n\n    model_config = ConfigDict(from_attributes=True)\n"
  },
  {
    "path": "shared/src/shared/domain/models/worker_message.py",
    "content": "from datetime import datetime\nfrom typing import Optional\nfrom uuid import UUID\n\nfrom shared.domain.dto.post_to_publish import MessageEntityDTO\nfrom shared.domain.models import User\nfrom shared.domain.models.abstract import Model\nfrom shared.domain.enums import WorkerMessageType, WorkerMessageStatus\n\n\nclass WorkerMessage(Model):\n    user_id: UUID\n    type: WorkerMessageType\n    text: Optional[str] = None\n    media_path: Optional[str] = None\n    chat_id: Optional[int] = None\n    status: WorkerMessageStatus\n    sent_at: Optional[datetime] = None\n\n    request_id: Optional[UUID] = None\n    entities: Optional[list[MessageEntityDTO]] = None\n\n    user: Optional[User] = None\n"
  },
  {
    "path": "shared/src/shared/domain/models/post.py",
    "content": "from typing import Optional\n\nfrom pydantic import ConfigDict\nfrom sqlalchemy.orm import Mapped\n\nfrom .abstract import Model\nfrom shared.domain.dto.post_to_publish import MessageEntityDTO\n\n\nclass Post(Model):\n    text: str\n    name: str\n    image_path: Optional[str] = None\n\n    html: Optional[str] = None\n    entities: Optional[list[MessageEntityDTO]] = None\n\n    model_config = ConfigDict(from_attributes=True)\n\n"
  },
  {
    "path": "shared/src/shared/domain/models/story.py",
    "content": "from typing import Optional\n\nfrom pydantic import ConfigDict\n\nfrom .abstract import Model\n\n\nclass Story(Model):\n    name: str\n    file_path: str\n    text: Optional[str]\n\n    model_config = ConfigDict(from_attributes=True)\n"
  },
  {
    "path": "shared/src/shared/domain/models/user.py",
    "content": "from typing import Optional\nfrom uuid import UUID\n\nfrom shared.domain.enums import UserRole\nfrom .abstract import Model\nfrom .proxy import Proxy\n\n\nclass User(Model):\n    telegram_id: int\n    telegram_username: Optional[str] = None\n    telegram_first_name: Optional[str] = None\n    telegram_last_name: Optional[str] = None\n    telegram_language_code: Optional[str] = None\n\n    role: UserRole\n\n    session_string: Optional[str] = None\n    proxy_id: Optional[UUID] = None\n\n    proxy: Optional[Proxy] = None\n\n    assistant_enabled: bool\n\n\nclass UserWithSessionString(User):\n    session_string: str\n"
  },
  {
    "path": "shared/src/shared/domain/models/story_to_publish.py",
    "content": "from datetime import date, time\nfrom typing import Optional\nfrom uuid import UUID\nfrom pydantic import ConfigDict\n\nfrom shared.domain.enums import ScheduledType, PublicationStatus\nfrom .user import User\nfrom .abstract import Model\nfrom .story import Story\n\n\nclass StoryToPublish(Model):\n    story_id: UUID\n    manager_id: UUID\n    scheduled_type: ScheduledType\n    scheduled_date: Optional[date]\n    scheduled_time: time\n    status: PublicationStatus\n\n    manager: User\n    story: Story\n\n    model_config = ConfigDict(from_attributes=True)\n"
  },
  {
    "path": "shared/src/shared/domain/models/story_request.py",
    "content": "from datetime import datetime\nfrom typing import Optional\nfrom uuid import UUID\n\nfrom shared.domain.enums import PublishStoryRequestStatus\nfrom .abstract import Model\nfrom .story import Story\nfrom .user import User\n\n\nclass PublishStoryRequest(Model):\n    story_id: UUID\n    user_id: UUID\n    scheduled_at: Optional[datetime] = None\n\n    publication_id: UUID\n\n    status: PublishStoryRequestStatus\n    published_at: Optional[datetime] = None\n\n    user: Optional[\"User\"] = None\n    story: Optional[\"Story\"] = None\n"
  },
  {
    "path": "shared/src/shared/domain/models/post_request.py",
    "content": "from datetime import datetime\nfrom typing import Optional\nfrom uuid import UUID\n\nfrom shared.domain.models import User, Post, Chat\nfrom shared.domain.enums import SendPostRequestStatus\nfrom .abstract import Model\n\n\nclass SendPostRequest(Model):\n    post_id: UUID\n    chat_id: UUID\n    user_id: UUID\n    scheduled_at: Optional[datetime] = None\n\n    publication_id: UUID\n\n    status: SendPostRequestStatus\n    sent_at: Optional[datetime] = None\n\n    user: Optional[\"User\"] = None\n    chat: Optional[\"Chat\"] = None\n    post: Optional[\"Post\"] = None\n"
  },
  {
    "path": "shared/src/shared/domain/models/emoji.py",
    "content": "from typing import Optional\n\nfrom .abstract import Model\n\n\nclass Emoji(Model):\n    custom_emoji_id: str\n    name: str\n    img_url: str\n"
  },
  {
    "path": "shared/src/shared/domain/models/proxy.py",
    "content": "from typing import Optional, TYPE_CHECKING\n\nfrom .abstract import Model\n\nif TYPE_CHECKING:\n    from .user import User\n\n\nclass Proxy(Model):\n    proxy_string: str\n    is_free: bool\n    is_deprecated: bool\n\n    user: Optional['User'] = None\n"
  },
  {
    "path": "shared/src/shared/domain/models/post_to_publish.py",
    "content": "from datetime import date, time\nfrom typing import Optional\nfrom uuid import UUID\n\nfrom pydantic import ConfigDict\n\nfrom shared.domain.enums import ScheduledType, PublicationStatus\nfrom .abstract import Model\nfrom .chat import Chat\nfrom .post import Post\nfrom .user import User\n\n\nclass PostToPublish(Model):\n    post_id: UUID\n    manager_id: UUID\n    scheduled_type: ScheduledType\n    scheduled_date: Optional[date]\n    scheduled_time: time\n    status: PublicationStatus\n\n    manager: User\n    chats: list[Chat] = []\n    post: Post\n\n    model_config = ConfigDict(from_attributes=True)\n"
  },
  {
    "path": "shared/src/shared/domain/models/__init__.py",
    "content": "from .user import User, UserWithSessionString\nfrom .post import Post\nfrom .chat import Chat\nfrom .post_request import SendPostRequest\nfrom .worker_message import WorkerMessage\nfrom .story_request import PublishStoryRequest\nfrom .analytics_service import Service\nfrom .post_to_publish import PostToPublish\nfrom .story_to_publish import StoryToPublish\nfrom .story import Story\nfrom .proxy import Proxy\n\nfrom typing import TypeVar\n\nSendingRequest = TypeVar(\n    \"SendingRequest\",\n    SendPostRequest,\n    PublishStoryRequest,\n)\n\nPublication = TypeVar(\n    \"Publication\",\n    PostToPublish,\n    StoryToPublish,\n)\n\n\n__all__ = [\n    \"User\",\n    \"Post\",\n    \"Chat\",\n    \"SendPostRequest\",\n    \"PublishStoryRequest\",\n    \"WorkerMessage\",\n    \"UserWithSessionString\",\n    \"SendingRequest\",\n    \"Service\",\n    \"PostToPublish\",\n    \"StoryToPublish\",\n    \"Story\",\n    \"Proxy\"\n]\n\nProxy.model_rebuild()\n"
  },
  {
    "path": "shared/src/shared/domain/models/chat.py",
    "content": "from typing import Optional\n\nfrom .abstract import Model\n\n\nclass Chat(Model):\n    name: str\n    chat_id: int\n    invite_link: Optional[str] = None\n"
  },
  {
    "path": "shared/src/shared/domain/models/analytics_service.py",
    "content": "from pydantic import ConfigDict\n\nfrom .abstract import Model\n\n\nclass Service(Model):\n    name: str\n    is_active: bool\n\n    model_config = ConfigDict(from_attributes=True)\n"
  },
  {
    "path": "shared/src/shared/domain/requests/enums.py",
    "content": "from enum import StrEnum\n\n\nclass PublicationType(StrEnum):\n    STORY = \"story\"\n    POST = \"post\"\n"
  },
  {
    "path": "shared/src/shared/domain/requests/proxy.py",
    "content": "from pydantic import BaseModel\n\n\nclass CreateProxyRequest(BaseModel):\n    urls: list[str]\n"
  },
  {
    "path": "shared/src/shared/domain/requests/__init__.py",
    "content": "from .enums import PublicationType\nfrom .watcher import (\n    PublicationStartedRequest,\n    RequestProcessingStartedRequest,\n    MessageSentRequest,\n    PostPublicationStartedRequest,\n    PostRequestProcessingStartedRequest,\n    PostMessageSentRequest,\n    StoryPublicationStartedRequest,\n    StoryRequestProcessingStartedRequest,\n    StoryMessageSentRequest,\n)\nfrom .proxy import CreateProxyRequest\n\n__all__ = [\n    \"PublicationType\",\n    \"PublicationStartedRequest\",\n    \"RequestProcessingStartedRequest\",\n    \"MessageSentRequest\",\n    'PostPublicationStartedRequest',\n    'PostRequestProcessingStartedRequest',\n    'PostMessageSentRequest',\n    'StoryPublicationStartedRequest',\n    'StoryRequestProcessingStartedRequest',\n    'StoryMessageSentRequest'\n]\n"
  },
  {
    "path": "shared/src/shared/domain/requests/chat.py",
    "content": "from pydantic import BaseModel\n\n\nclass CreateChatRequest(BaseModel):\n    invite_link: str\n\n"
  },
  {
    "path": "shared/src/shared/domain/requests/watcher/story.py",
    "content": "from shared.domain.requests.enums import PublicationType\nfrom .base import PublicationStartedRequest, RequestProcessingStartedRequest, MessageSentRequest\n\n\nclass StoryPublicationStartedRequest(PublicationStartedRequest):\n    type: PublicationType = PublicationType.STORY\n\n\nclass StoryRequestProcessingStartedRequest(RequestProcessingStartedRequest):\n    type: PublicationType = PublicationType.STORY\n\n\nclass StoryMessageSentRequest(MessageSentRequest):\n    type: PublicationType = PublicationType.STORY\n"
  },
  {
    "path": "shared/src/shared/domain/requests/watcher/posts.py",
    "content": "from shared.domain.requests.enums import PublicationType\nfrom .base import PublicationStartedRequest, RequestProcessingStartedRequest, MessageSentRequest\n\n\nclass PostPublicationStartedRequest(PublicationStartedRequest):\n    type: PublicationType = PublicationType.POST\n\n\nclass PostRequestProcessingStartedRequest(RequestProcessingStartedRequest):\n    type: PublicationType = PublicationType.POST\n\n\nclass PostMessageSentRequest(MessageSentRequest):\n    type: PublicationType = PublicationType.POST\n"
  },
  {
    "path": "shared/src/shared/domain/requests/watcher/__init__.py",
    "content": "from .base import PublicationStartedRequest, RequestProcessingStartedRequest, MessageSentRequest\nfrom .posts import PostPublicationStartedRequest, PostRequestProcessingStartedRequest, PostMessageSentRequest\nfrom .story import StoryPublicationStartedRequest, StoryRequestProcessingStartedRequest, StoryMessageSentRequest\n\n__all__ = (\n    'PublicationStartedRequest',\n    'RequestProcessingStartedRequest',\n    'MessageSentRequest',\n    'PostPublicationStartedRequest',\n    'PostRequestProcessingStartedRequest',\n    'PostMessageSentRequest',\n    'StoryPublicationStartedRequest',\n    'StoryRequestProcessingStartedRequest',\n    'StoryMessageSentRequest'\n)\n"
  },
  {
    "path": "shared/src/shared/domain/requests/watcher/base.py",
    "content": "from uuid import UUID\n\nfrom pydantic import BaseModel\n\nfrom shared.domain.requests.enums import PublicationType\n\n\nclass PublicationStartedRequest(BaseModel):\n    type: PublicationType\n    publication_id: UUID\n    child_requests: list[UUID] = []\n\n\nclass RequestProcessingStartedRequest(BaseModel):\n    type: PublicationType\n    request_id: UUID\n    child_messages: list[UUID] = []\n\n\nclass MessageSentRequest(BaseModel):\n    type: PublicationType\n    message_id: UUID\n"
  },
  {
    "path": "shared/src/shared/services/emoji.py",
    "content": "from dataclasses import dataclass\nfrom typing import List\nfrom uuid import UUID\n\nfrom shared.abstractions.repositories.emojis import EmojisRepositoryInterface\nfrom shared.abstractions.services.emoji import EmojiServiceInterface\nfrom shared.domain.dto.emoji import CreateEmojiDTO\nfrom shared.domain.models.emoji import Emoji\n\n\n@dataclass\nclass EmojiService(EmojiServiceInterface):\n    emoji_repository: EmojisRepositoryInterface\n\n    async def get_all_emojis(self) -> List[Emoji]:\n        return await self.emoji_repository.get_all()\n\n    async def create_emoji(self, emoji: CreateEmojiDTO) -> UUID:\n        return await self.emoji_repository.create(emoji)\n"
  },
  {
    "path": "shared/src/shared/services/__init__.py",
    "content": "from .upload import UploadService\n\n__all__ = [\n    'UploadService',\n]"
  },
  {
    "path": "shared/src/shared/services/scheduler.py",
    "content": "from dataclasses import field, dataclass\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Callable, Coroutine, Any\n\nfrom apscheduler.jobstores.sqlalchemy import SQLAlchemyJobStore\nfrom apscheduler.schedulers.asyncio import AsyncIOScheduler\n\nfrom shared.abstractions.services.scheduler import SchedulerInterface\nfrom shared.abstractions.singleton import Singleton\n\n\n@dataclass\nclass Scheduler(\n    SchedulerInterface,\n    Singleton,\n):\n    job_store_sqlite_path: Path\n\n    scheduler: AsyncIOScheduler = field(default=None, init=False)\n\n    def __post_init__(self):\n        jobstores = {\n            'default': SQLAlchemyJobStore(\n                url=f\"sqlite:///{self.job_store_sqlite_path.absolute()}\",\n                tablename='apscheduler_jobs',\n            )\n        }\n        executors = {'default': {'type': 'asyncio'}}\n        job_defaults = {'coalesce': False, 'max_instances': 1}\n\n        self.scheduler = AsyncIOScheduler(\n            jobstores=jobstores,\n            executors=executors,\n            job_defaults=job_defaults,\n        )\n        self.scheduler.start()\n\n    def initialize(self) -> None:\n        pass\n\n    def schedule_once(\n            self,\n            callback: Callable[[Any], Coroutine[Any, Any, None]],\n            runs_on: datetime,\n            args: tuple[Any, ...] = (),\n            job_id: str = None,\n    ) -> None:\n        self.scheduler.add_job(\n            callback,\n            next_run_time=runs_on,\n            args=args,\n            id=job_id,\n            replace_existing=True if job_id else False,\n        )\n"
  },
  {
    "path": "shared/src/shared/services/watcher_client/client.py",
    "content": "from contextlib import asynccontextmanager\nfrom dataclasses import dataclass\nfrom typing import AsyncGenerator\n\nfrom httpx import AsyncClient\nfrom pydantic import BaseModel\n\nfrom shared.abstractions.services.watcher_client import WatcherClientInterface\nfrom shared.domain.requests import MessageSentRequest, RequestProcessingStartedRequest, PublicationStartedRequest\n\n\n@dataclass\nclass WatcherClient(WatcherClientInterface):\n    base_url: str\n\n    publication_started_endpoint: str = \"/watch/publication\"\n    request_processing_started_endpoint: str = \"/watch/request\"\n    message_sent_endpoint: str = \"/watch/message\"\n\n    async def report_publication_started(self, request: PublicationStartedRequest) -> None:\n        await self._send_post_request(\n            request=request,\n            endpoint=self.publication_started_endpoint,\n        )\n\n    async def report_request_processing_started(self, request: RequestProcessingStartedRequest) -> None:\n        await self._send_post_request(\n            request=request,\n            endpoint=self.request_processing_started_endpoint,\n        )\n\n    async def report_message_sent(self, request: MessageSentRequest) -> None:\n        await self._send_post_request(\n            request=request,\n            endpoint=self.message_sent_endpoint,\n        )\n\n    async def _send_post_request(self, request: BaseModel, endpoint: str) -> None:\n        async with self._get_client() as client:\n            await client.post(\n                url=endpoint,\n                json=request.model_dump(mode=\"json\"),\n            )\n\n    @asynccontextmanager\n    async def _get_client(self) -> AsyncGenerator[AsyncClient, None]:\n        async with AsyncClient(base_url=self.base_url) as client:\n            yield client\n"
  },
  {
    "path": "shared/src/shared/services/watcher_client/__init__.py",
    "content": "from .settings import WatcherSettings\nfrom .client import WatcherClient\n\n__all__ = [\n    \"WatcherSettings\",\n    \"WatcherClient\",\n]\n"
  },
  {
    "path": "shared/src/shared/services/watcher_client/settings.py",
    "content": "from pathlib import Path\n\nfrom pydantic import Field\nfrom pydantic_settings import SettingsConfigDict\n\nfrom shared.settings import AbstractSettings\n\n\nclass WatcherSettings(AbstractSettings):\n    host: str = Field('watcher')\n    port: int = Field(8080)\n\n    @property\n    def url(self):\n        return f\"http://{self.host}:{self.port}\"\n\n    model_config = SettingsConfigDict(\n        extra=\"ignore\",\n        json_file=Path(__file__).parent.parent.parent / \"watcher_settings.json\",\n        json_file_encoding=\"utf-8\",\n        populate_by_name=True,\n    )\n"
  },
  {
    "path": "shared/src/shared/services/upload/__init__.py",
    "content": "import logging\nimport os\nfrom dataclasses import field, dataclass\nfrom pathlib import Path\nfrom typing import Annotated\nfrom uuid import uuid4\n\nimport aiofiles\n\nfrom shared.abstractions.services import UploadServiceInterface\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass UploadService(UploadServiceInterface):\n    public_backend_base_url: str\n    images_dir: str = field(default=\"/app/upload\")\n\n    files_endpoint: str = 'upload'\n\n    @staticmethod\n    def get_extension(filename: str) -> str:\n        return filename.split('.')[-1]\n\n    def get_file_url(self, name: str) -> str:\n        return f'{self.public_backend_base_url}/{self.files_endpoint}/{name}'\n\n    async def upload(self, file: bytes, extension: str) -> str:\n        new_filename, new_filepath = self._get_new_file_path(extension)\n        try:\n            async with aiofiles.open(new_filepath, \"wb\") as f:\n                await f.write(file)\n\n            return new_filename\n        except Exception:\n            logger.error(\"There was an error while uploading file\", exc_info=True)\n            raise\n\n    def get_file_path(self, filename: str) -> str:\n        return os.path.join(self.images_dir, filename)\n\n    def _get_new_file_path(\n            self,\n            extension: str,\n    ) -> tuple[\n        Annotated[str, 'filename'],\n        Annotated[str, 'file path'],\n    ]:\n        new_filename = f\"{uuid4()}.{extension}\"\n        return new_filename, self.get_file_path(new_filename)\n\n    async def initialize(self) -> None:\n        images = Path(self.images_dir)\n\n        if not images.exists():\n            images.mkdir(parents=True, exist_ok=True)\n"
  },
  {
    "path": "shared/src/shared/services/upload/settings.py",
    "content": "from pathlib import Path\n\nfrom pydantic import Field\nfrom pydantic_settings import SettingsConfigDict\n\nfrom shared.settings import AbstractSettings\n\n\nclass UploadSettings(AbstractSettings):\n    host_upload_dir: str = Field('/Users/daria/PycharmProjects/ai_assistant/upload/', alias='HOST_UPLOAD_DIR')\n    app_upload_dir: str = Field('/app/upload/')\n\n    model_config = SettingsConfigDict(\n        extra=\"ignore\",\n        json_file=Path(__file__).parent.parent.parent / \"upload_settings.json\",\n        json_file_encoding=\"utf-8\",\n        populate_by_name=True,\n    )\n"
  },
  {
    "path": "bot/__init__.py",
    "content": ""
  },
  {
    "path": "bot/settings.py",
    "content": "from pathlib import Path\n\nfrom pydantic import Field\nfrom pydantic_settings import (\n    SettingsConfigDict,\n)\nfrom shared.infrastructure.main_db import MainDBSettings\nfrom shared.settings import AbstractSettings, EnvironmentSettings, BotSettings, MiniappSettings\n\n\nclass Settings(AbstractSettings):\n    main_db: MainDBSettings = Field(default_factory=MainDBSettings)\n    env: EnvironmentSettings = Field(default_factory=EnvironmentSettings)\n    bot: BotSettings\n    miniapp: MiniappSettings\n\n    model_config = SettingsConfigDict(\n        extra=\"ignore\",\n        json_file=Path(__file__).parent / \"settings.json\",\n        json_file_encoding=\"utf-8\",\n    )\n\n\nsettings = Settings()\n"
  },
  {
    "path": "bot/main.py",
    "content": "import asyncio\nimport logging\n\nfrom aiogram import Bot, Dispatcher, types, F\nfrom aiogram.filters import CommandStart, Command, StateFilter\nfrom aiogram.fsm.context import FSMContext\nfrom aiogram.fsm.state import StatesGroup, State\nfrom aiogram.fsm.storage.memory import MemoryStorage\nfrom aiogram.types import (\n    InlineKeyboardMarkup,\n    InlineKeyboardButton,\n    WebAppInfo,\n    ContentType,\n)\nfrom httpx import AsyncClient\nfrom shared.dependencies.repositories import get_proxy_repository\nfrom shared.dependencies.services.emoji import get_emoji_service\nfrom shared.domain.dto import CreateProxyDTO\nfrom shared.domain.dto.emoji import CreateEmojiDTO\nfrom shared.infrastructure.main_db import init_db\n\nfrom dependencies.service.upload import get_upload_service\nfrom settings import settings\n\n# ——— Logging & Bot setup —————————————————————————————————————\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n)\nlogger = logging.getLogger(__name__)\n\nlogger.info(f'starting bot with token: {settings.bot.token.get_secret_value()}')\n\nbot = Bot(token=settings.bot.token.get_secret_value())\ndp = Dispatcher(storage=MemoryStorage())  # <-- attach FSM storage\n\n\n# ——— Define our two “waiting” states —————————————————————————\nclass BotStates(StatesGroup):\n    waiting_for_proxy = State()\n    waiting_for_emoji = State()\n\n\n# ——— /start handlers (unchanged) ————————————————————————————\n@dp.message(CommandStart(deep_link=True))\nasync def handler_start_deep(message: types.Message):\n    kb = InlineKeyboardMarkup(\n        inline_keyboard=[\n            [\n                InlineKeyboardButton(\n                    text=\"Открыть админку\",\n                    web_app=WebAppInfo(url=settings.miniapp.url),\n                )\n            ]\n        ]\n    )\n    await message.answer(\n        \"Привет! ♡\\n\\nЭто админ-панель…\\n\\n*✧･ﾟ: *✧･ﾟ:*\",\n        reply_markup=kb,\n        parse_mode=\"HTML\",\n        disable_web_page_preview=True,\n    )\n\n\n@dp.message(CommandStart(deep_link=False))\nasync def handler_start_plain(message: types.Message):\n    kb = InlineKeyboardMarkup(\n        inline_keyboard=[\n            [\n                InlineKeyboardButton(\n                    text=\"Открыть админку\",\n                    web_app=WebAppInfo(url=settings.miniapp.url),\n                )\n            ]\n        ]\n    )\n    await message.answer(\n        \"Привет! ♡\\n\\nЭто админ-панель…\",\n        reply_markup=kb,\n        disable_web_page_preview=True,\n    )\n\n\n# ——— /add_proxy — ask for text, go into proxy‐state —————————————\n@dp.message(Command(commands=[\"add_proxy\"]))\nasync def cmd_add_proxy(message: types.Message, state: FSMContext):\n    await message.reply(\n        \"🌐 Пришлите список URL для подключения прокси. Каждый URL – на новой строке\"\n    )\n    await state.set_state(BotStates.waiting_for_proxy)\n\n\n# ——— proxy‐state handler: only text, only in waiting_for_proxy —————\n@dp.message(\n    StateFilter(BotStates.waiting_for_proxy),\n    F.content_type == ContentType.TEXT,\n)\nasync def process_proxy(msg: types.Message, state: FSMContext):\n    proxies = msg.text.split()\n    repo = get_proxy_repository()\n    for proxy in proxies:\n        dto = CreateProxyDTO(proxy_string=proxy)\n        await repo.create(dto)\n    total = await repo.get_available_proxies_count()\n    await msg.reply(f\"Добавлено {len(proxies)} новых прокси. Всего доступно {total} прокси.\")\n    await state.clear()  # done with proxies\n\n\n# ——— /add_emoji — ask for sticker, go into emoji‐state ——————————\n@dp.message(Command(commands=[\"add_emoji\"]))\nasync def cmd_add_emoji(message: types.Message, state: FSMContext):\n    await message.reply(\"📩 Пришлите ваш кастом-эмоджи-стикер.\")\n    await state.set_state(BotStates.waiting_for_emoji)\n\n\n# ——— emoji‐state handler: only stickers, only in waiting_for_emoji ——\n@dp.message(\n    StateFilter(BotStates.waiting_for_emoji),\n)\nasync def process_sticker(msg: types.Message, state: FSMContext):\n    entities: list = msg.entities or [None]\n    sticker = entities[0]\n    if not sticker or not sticker.type == \"custom_emoji\":\n        return await msg.reply(\"Это не эмоджи-стикер, попробуйте ещё раз.\")\n\n    # download the file from Telegram\n    entity = (await bot.get_custom_emoji_stickers([sticker.custom_emoji_id]))[0]\n    file = await bot.get_file(entity.file_id)\n    url = f\"https://api.telegram.org/file/bot{settings.bot.token.get_secret_value()}/{file.file_path}\"\n    upload_service = get_upload_service()\n\n    async with AsyncClient() as client:\n        resp = await client.get(url)\n        if not resp.is_success:\n            logger.error(\"Unable to fetch sticker from Telegram: %s\", resp.status_code)\n            return await msg.reply(\"Не удалось загрузить медиа, попробуйте ещё раз.\")\n\n    ext = file.file_path.rsplit(\".\", 1)[-1]\n    filename = await upload_service.upload(resp.content, extension=ext)\n    public_url = upload_service.get_file_url(filename)\n\n    name = f\"{entity.emoji}_{entity.set_name}_{sticker.custom_emoji_id}\"\n    dto = CreateEmojiDTO(\n        name=name,\n        img_url=public_url,\n        custom_emoji_id=sticker.custom_emoji_id,\n    )\n    await get_emoji_service().create_emoji(dto)\n\n    await msg.reply(f\"✅ Эмоджи «{name}» зарегистрировано.\")\n    await state.clear()  # done with emoji\n\n\n# ——— bootstrap & run ——————————————————————————————————————\nasync def main():\n    init_db(settings.main_db.url)\n    logger.info(\"DB initialized\")\n    logger.info(\"Starting bot...\")\n    await dp.start_polling(bot)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n"
  },
  {
    "path": "bot/dependencies/__init__.py",
    "content": ""
  },
  {
    "path": "bot/dependencies/service/upload.py",
    "content": "from shared.abstractions.services import UploadServiceInterface\nfrom shared.dependencies.services import get_upload_service as get_base_upload_service\n\nfrom settings import settings\n\n\ndef get_upload_service() -> UploadServiceInterface:\n    return get_base_upload_service(\n        public_backend_base_url=settings.env.host + '/api',\n    )\n"
  },
  {
    "path": "bot/dependencies/service/__init__.py",
    "content": ""
  },
  {
    "path": "worker/__init__.py",
    "content": ""
  },
  {
    "path": "worker/settings.py",
    "content": "from pathlib import Path\n\nfrom pydantic import Field\nfrom pydantic_settings import SettingsConfigDict\nfrom shared.infrastructure.main_db import MainDBSettings\nfrom shared.services.upload.settings import UploadSettings\nfrom shared.services.watcher_client import WatcherSettings\nfrom shared.settings.worker import WorkerSettings\n\n\nclass Settings(WorkerSettings):\n    db: MainDBSettings = Field(default_factory=MainDBSettings)\n    upload: UploadSettings = Field(default_factory=UploadSettings)\n    watcher: WatcherSettings = Field(default_factory=WatcherSettings)\n\n    model_config = SettingsConfigDict(\n        extra=\"ignore\",\n        json_file=Path(__file__).parent / \"settings.json\",\n        json_file_encoding=\"utf-8\",\n    )\n\nsettings = Settings()\n"
  },
  {
    "path": "worker/main.py",
    "content": "import logging\n\nfrom shared.infrastructure.main_db import init_db\n\nfrom dependencies.services.message_consumer import get_message_consumer\nfrom services.exceptions import NoMessagesShutdown\nfrom settings import settings\n\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n)\nlogger = logging.getLogger(__name__)\n\n\nasync def main():\n    init_db(settings.db.url)\n\n    consumer = get_message_consumer()\n\n    try:\n        await consumer.execute()\n    except NoMessagesShutdown:\n        logger.info(\"No messages in queue, shutting down...\")\n        exit(0)\n    except KeyboardInterrupt:\n        logger.info(f\"Received KeyboardInterrupt, shutting down...\")\n        exit(0)\n    except Exception as e:\n        logger.error(e, exc_info=True)\n        exit(1)\n\n\nif __name__ == '__main__':\n    import asyncio\n\n    # time.sleep(10000)\n\n    asyncio.run(main())\n"
  },
  {
    "path": "worker/dependencies/__init__.py",
    "content": ""
  },
  {
    "path": "worker/dependencies/repositories/telegram.py",
    "content": "from abstractions.repositories import TelegramMessagesRepositoryInterface\nfrom infrastructure.repositories.telegram import TelethonTelegramMessagesRepository\nfrom settings import settings\n\n\ndef get_telegram_message_repository() -> TelegramMessagesRepositoryInterface:\n    return TelethonTelegramMessagesRepository(\n        api_id=settings.api_id,\n        api_hash=settings.api_hash,\n        worker=settings.user,\n    )\n"
  },
  {
    "path": "worker/dependencies/repositories/__init__.py",
    "content": ""
  },
  {
    "path": "worker/dependencies/services/sender.py",
    "content": "from abstractions.services.sender import SenderInterface\nfrom dependencies.repositories.telegram import get_telegram_message_repository\nfrom services.sender import Sender\n\n\ndef get_sender() -> SenderInterface:\n    return Sender(\n        messenger=get_telegram_message_repository(),\n    )\n"
  },
  {
    "path": "worker/dependencies/services/__init__.py",
    "content": ""
  },
  {
    "path": "worker/dependencies/services/watcher_client.py",
    "content": "from shared.abstractions.services.watcher_client import WatcherClientInterface\nfrom shared.dependencies.services.watcher_client import get_watcher_client_from_url\n\nfrom settings import settings\n\n\ndef get_watcher_client() -> WatcherClientInterface:\n    return get_watcher_client_from_url(settings.watcher.url)\n"
  },
  {
    "path": "worker/dependencies/services/message_consumer.py",
    "content": "from shared.dependencies.repositories.worker_message import get_worker_message_repository\n\nfrom abstractions.services.message_consumer import MessageConsumerInterface\nfrom dependencies.services.sender import get_sender\nfrom dependencies.services.watcher_client import get_watcher_client\nfrom services.message_consumer import MessageConsumer\n\n\ndef get_message_consumer() -> MessageConsumerInterface:\n    return MessageConsumer(\n        sender=get_sender(),\n        worker_messages_repository=get_worker_message_repository(),\n        watcher_client=get_watcher_client(),\n    )\n"
  },
  {
    "path": "worker/abstractions/__init__.py",
    "content": ""
  },
  {
    "path": "worker/abstractions/repositories/telegram.py",
    "content": "from abc import ABC, abstractmethod\nfrom typing import Optional\n\nfrom shared.domain.dto.post_to_publish import MessageEntityDTO\n\n\nclass TelegramMessagesRepositoryInterface(\n    ABC,\n):\n    @abstractmethod\n    async def send_message(\n            self,\n            chat_id: int,\n            text: str,\n            entities: Optional[list[MessageEntityDTO]] = None,\n            media_path: Optional[str] = None,\n            reply_to: Optional[int] = None,\n    ) -> int:\n        pass\n\n    @abstractmethod\n    async def join_chat(self, chat: str | int):\n        ...\n"
  },
  {
    "path": "worker/abstractions/repositories/__init__.py",
    "content": "from .telegram import TelegramMessagesRepositoryInterface\n"
  },
  {
    "path": "worker/abstractions/services/sender.py",
    "content": "from abc import ABC, abstractmethod\n\nfrom shared.domain.models import WorkerMessage\n\n\nclass SenderInterface(ABC):\n    @abstractmethod\n    async def send(self, message: WorkerMessage):\n        ...\n"
  },
  {
    "path": "worker/abstractions/services/__init__.py",
    "content": ""
  },
  {
    "path": "worker/abstractions/services/message_consumer.py",
    "content": "from abc import ABC\n\nfrom shared.abstractions.services.consumer import ConsumerInterface\n\nfrom abstractions.services.sender import SenderInterface\n\n\nclass MessageConsumerInterface(\n    ConsumerInterface[SenderInterface],\n    ABC,\n):\n    ...\n"
  },
  {
    "path": "worker/infrastructure/__init__.py",
    "content": ""
  },
  {
    "path": "worker/infrastructure/repositories/__init__.py",
    "content": ""
  },
  {
    "path": "worker/infrastructure/repositories/telegram/__init__.py",
    "content": "import logging\nimport re\nfrom asyncio import IncompleteReadError\nfrom dataclasses import dataclass\nfrom typing import Optional, Any\n\nfrom shared.dependencies.services import get_upload_service\nfrom shared.domain.dto.post_to_publish import MessageEntityDTO\nfrom telethon import TelegramClient as Client\nfrom telethon.sessions import StringSession\nfrom telethon.tl.functions.channels import JoinChannelRequest\nfrom telethon.tl.types import MessageEntityCustomEmoji\n\nfrom abstractions.repositories import TelegramMessagesRepositoryInterface\nfrom shared.domain.models import UserWithSessionString\n\nfrom settings import settings\nfrom .exceptions import ChatJoinError, UnhandlableError\n\nlogger = logging.getLogger(__name__)\nclient_logger = logger.getChild(\"client\")\nclient_logger.setLevel(logging.ERROR)\n\n\n@dataclass\nclass TelethonTelegramMessagesRepository(\n    TelegramMessagesRepositoryInterface,\n):\n    api_id: int\n    api_hash: str\n\n    worker: UserWithSessionString\n\n    async def join_chat(self, chat: str | int):\n        logger.info(f\"Joining chat {chat} with bot {self.worker.telegram_username} ({self.worker.id})\")\n\n        client = Client(\n            session=StringSession(self.worker.session_string),\n            api_id=self.api_id,\n            api_hash=self.api_hash,\n            base_logger=client_logger,\n        )\n\n        await client.connect()\n        try:\n            entity = await client.get_entity(chat)\n\n            await client(JoinChannelRequest(entity))  # noqa\n            await client.disconnect()\n        except Exception as e:\n            await client.disconnect()\n            raise ChatJoinError(\n                f\"There is an error joining chat {chat} with bot {self.worker.telegram_username} ({self.worker.id}):\"\n                f\" {type(e).__name__}: {e}\"\n            )\n\n    async def send_message(\n            self,\n            chat_id: int,\n            text: str,\n            entities: Optional[list[MessageEntityDTO]] = None,\n            media_path: Optional[str] = None,\n            reply_to: Optional[int] = None,\n            retry: int = 0,\n    ) -> int:\n        if not self.api_id or not self.api_hash or not self.worker.session_string:\n            raise ValueError(\"api_id, api_hash and session_string are required\")\n\n        client = Client(\n            session=StringSession(self.worker.session_string),\n            api_id=self.api_id,\n            api_hash=self.api_hash,\n            base_logger=client_logger,\n            proxy=self.parse_proxy(self.worker.proxy.proxy_string) if self.worker.proxy else None,\n            auto_reconnect=False,\n        )\n\n        try:\n            await client.connect()\n            logger.info(\"Client connected\")\n\n            sending_args: dict[str, Any] = {\n                \"entity\": chat_id,\n                \"message\": text,\n            }\n\n            if reply_to:\n                sending_args['reply_to'] = reply_to\n\n            if media_path:\n                upload_service = get_upload_service(settings.upload.app_upload_dir)\n                sending_args['file'] = upload_service.get_file_path(media_path)\n\n            if entities:\n                entities_to_send = []\n                for raw_entity in entities:\n                    if raw_entity.type == 'custom_emoji':\n                        entity_to_add = MessageEntityCustomEmoji(\n                            offset=raw_entity.offset,\n                            length=raw_entity.length,\n                            document_id=raw_entity.custom_emoji_id,\n                        )\n                        entities_to_send.append(entity_to_add)\n\n                sending_args['formatting_entities'] = entities_to_send\n\n            message = await client.send_message(**sending_args)\n            logger.info('Message sent')\n\n            await client.disconnect()\n            logger.info(\"Client disconnected\")\n            return message.id\n        except (RuntimeError, IncompleteReadError) as e:\n            try:\n                await client.disconnect()\n            except:\n                pass\n\n            if retry > 5:\n                logger.error(\"Cannot connect to Telegram\")\n                raise UnhandlableError from e\n\n            return await self.send_message(\n                chat_id=chat_id,\n                text=text,\n                reply_to=reply_to,\n                retry=retry + 1,\n            )\n\n    @staticmethod\n    def parse_proxy(proxy_string: Optional[str]) -> Optional[tuple]:\n        if not proxy_string:\n            return\n\n        # Regex to parse the proxy string\n        pattern = re.compile(\n            r\"^(?P<protocol>http|socks5|socks4)://(?P<username>.+?):(?P<password>.+?)@(?P<host>.+?):(?P<port>\\d+)$\"\n        )\n        match = pattern.match(proxy_string)\n        if not match:\n            raise ValueError(\"Invalid proxy format\")\n\n        # Extracting components\n        components = match.groupdict()\n        protocol = components[\"protocol\"]\n        username = components[\"username\"]\n        password = components[\"password\"]\n        host = components[\"host\"]\n        port = int(components[\"port\"])\n\n        # Map protocol to PySocks format\n        proxy_type = {\n            \"http\": \"HTTP\",\n            \"socks5\": \"SOCKS5\",\n            \"socks4\": \"SOCKS4\"\n        }.get(protocol, None)\n\n        if not proxy_type:\n            raise ValueError(\"Unsupported proxy protocol\")\n\n        # PySocks/Telethon-compatible format\n        proxy = (proxy_type, host, port, True, username, password)\n        return proxy\n"
  },
  {
    "path": "worker/infrastructure/repositories/telegram/exceptions.py",
    "content": "class NoSuchWorkerException(Exception):\n    ...\n\n\nclass ChatJoinError(Exception):\n    ...\n\n\nclass UnhandlableError(Exception):\n    ...\n"
  },
  {
    "path": "worker/services/sender.py",
    "content": "from dataclasses import dataclass\n\nfrom shared.abstractions.services.watcher_client import WatcherClientInterface\nfrom shared.domain.enums import WorkerMessageType\nfrom shared.domain.models import WorkerMessage\nfrom shared.domain.requests import PostMessageSentRequest\n\nfrom abstractions.repositories import TelegramMessagesRepositoryInterface\nfrom abstractions.services.sender import SenderInterface\nfrom services.exceptions import CannotSendMessageException\n\n\n@dataclass\nclass Sender(SenderInterface):\n    messenger: TelegramMessagesRepositoryInterface\n\n    async def send(self, message: WorkerMessage):\n        match message.type:\n            case WorkerMessageType.POST:\n                await self._send_post(message)\n\n    async def _send_post(self, message: WorkerMessage):\n        try:\n            await self.messenger.send_message(\n                chat_id=message.chat_id,\n                text=message.text,\n                entities=message.entities,\n                media_path=message.media_path,\n            )\n        except Exception as e:\n            raise CannotSendMessageException from e\n"
  },
  {
    "path": "worker/services/__init__.py",
    "content": ""
  },
  {
    "path": "worker/services/exceptions.py",
    "content": "class NoMessagesShutdown(Exception):\n    ...\n\nclass CannotSendMessageException(Exception):\n    ...\n"
  },
  {
    "path": "worker/services/message_consumer.py",
    "content": "import logging\nfrom asyncio import sleep\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom typing import NoReturn\n\nfrom shared.abstractions.repositories.worker_message import WorkerMessageRepositoryInterface\nfrom shared.abstractions.services.watcher_client import WatcherClientInterface\nfrom shared.domain.dto import UpdateWorkerMessageDTO\nfrom shared.domain.enums import WorkerMessageStatus\nfrom shared.domain.requests import MessageSentRequest, PostMessageSentRequest\n\nfrom abstractions.services.message_consumer import MessageConsumerInterface\nfrom abstractions.services.sender import SenderInterface\nfrom services.exceptions import NoMessagesShutdown, CannotSendMessageException\n\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass MessageConsumer(MessageConsumerInterface):\n    sender: SenderInterface\n    worker_messages_repository: WorkerMessageRepositoryInterface\n    watcher_client: WatcherClientInterface\n\n    global_delay: int = 1\n    shutdown_delay: int = 60\n\n    async def execute(self) -> NoReturn:\n        to_shutdown = False\n        while True:\n            message = await self.worker_messages_repository.get_queued_message()\n            logger.info(f\"message: {message}\")\n            if not message:\n                if to_shutdown:\n                    raise NoMessagesShutdown\n\n                to_shutdown = True\n                await sleep(self.shutdown_delay)\n                continue\n\n            await self.worker_messages_repository.set_message_status(\n                message_id=message.id,\n                status=WorkerMessageStatus.IN_PROGRESS,\n            )\n\n            try:\n                await self.sender.send(message)\n                await self.worker_messages_repository.set_message_status(\n                    message_id=message.id,\n                    status=WorkerMessageStatus.SENT,\n                    sent_at=datetime.now(),\n                )\n                report = PostMessageSentRequest(\n                    message_id=message.id,\n                )\n                await self.watcher_client.report_message_sent(report)\n            except CannotSendMessageException:\n                await self.worker_messages_repository.set_message_status(\n                    message_id=message.id,\n                    status=WorkerMessageStatus.FAILED,\n                )\n                logger.error(\"Cannot send message\", exc_info=True)\n            except Exception as e:\n                logger.error(e, exc_info=True)\n                await self.worker_messages_repository.set_message_status(\n                    message_id=message.id,\n                    status=WorkerMessageStatus.FAILED,\n                )\n\n\n            await sleep(self.global_delay)\n"
  },
  {
    "path": "assistant-service/__init__.py",
    "content": ""
  },
  {
    "path": "story-service/__init__.py",
    "content": ""
  },
  {
    "path": "story-service/scheduler.py",
    "content": "from apscheduler.schedulers.asyncio import AsyncIOScheduler\nfrom apscheduler.triggers.date import DateTrigger\nfrom services.story import publish_story\n\nscheduler = AsyncIOScheduler()\n\ndef schedule_story(story_id: int, run_date):\n    scheduler.add_job(\n        func=publish_story,\n        trigger=DateTrigger(run_date=run_date),\n        args=[story_id],\n        id=f\"story_{story_id}\",\n        replace_existing=True,\n    )\n"
  },
  {
    "path": "story-service/main.py",
    "content": "import logging\n\nfrom backend.dependencies.services.bot import get_bot\nfrom backend.dependencies import get_mailing_service\n\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n)\nlogger = logging.getLogger(__name__)\n\nbot = get_bot()\n\n\nasync def main():\n    mailing = get_mailing_service()\n    mailing.schedule_jobs()\n\n    print('Бот и шедулер запущены...')\n    await bot.run_until_disconnected()\n\n    print(\"Бот остановлен\")\n\n\nif __name__ == '__main__':\n    bot.loop.run_until_complete(main())\n"
  },
  {
    "path": "story-service/dependencies/__init__.py",
    "content": ""
  },
  {
    "path": "story-service/dependencies/repositories/user.py",
    "content": "from backend.abstractions.repositories import UserRepositoryInterface\nfrom backend.dependencies.repositories.session_maker import get_session_maker\nfrom infrastructure.repositories.user import UserRepository\n\n\ndef get_user_repository() -> UserRepositoryInterface:\n    return UserRepository(\n        session_maker=get_session_maker()\n    )"
  },
  {
    "path": "story-service/dependencies/repositories/__init__.py",
    "content": ""
  },
  {
    "path": "story-service/dependencies/repositories/session_maker.py",
    "content": "from sqlalchemy.ext.asyncio import async_sessionmaker\n\nfrom infrastructure import session_maker\n\n\ndef get_session_maker() -> async_sessionmaker:\n    return session_maker"
  },
  {
    "path": "story-service/dependencies/repositories/analytics_service.py",
    "content": "from backend.abstractions.repositories import AnalyticsServiceRepositoryInterface\nfrom backend.dependencies.repositories.session_maker import get_session_maker\nfrom infrastructure.repositories.analytics_service import AnalyticsServiceRepository\n\n\ndef get_analytics_service_repository() -> AnalyticsServiceRepositoryInterface:\n    return AnalyticsServiceRepository(\n        session_maker=get_session_maker()\n    )"
  },
  {
    "path": "story-service/dependencies/services/user.py",
    "content": "from backend.abstractions.services.user import UserServiceInterface\nfrom backend.dependencies.repositories.user import get_user_repository\nfrom backend.services.user import UserService\n\n\ndef get_user_service() -> UserServiceInterface:\n    return UserService(\n        user_repository=get_user_repository()\n    )"
  },
  {
    "path": "story-service/dependencies/services/mailing.py",
    "content": "from backend.abstractions.services.mailing import MailingServiceInterface\nfrom backend.dependencies.services.analytics_service import get_analytics_service_service\nfrom backend.dependencies.services.bot import get_bot\nfrom backend.dependencies.services.gpt import get_gpt_service\nfrom backend.dependencies.services.user import get_user_service\nfrom backend.services import MailingService\n\n\ndef get_mailing_service() -> MailingServiceInterface:\n    return MailingService(\n        bot=get_bot(),\n        gpt=get_gpt_service(),\n        user_service=get_user_service(),\n        analytics_service_service=get_analytics_service_service()\n    )\n"
  },
  {
    "path": "story-service/dependencies/services/__init__.py",
    "content": ""
  },
  {
    "path": "story-service/dependencies/services/gpt.py",
    "content": "from backend.abstractions.services.gpt import GPTServiceInterface\nfrom backend.services import GPTService\n\ndef get_gpt_service() -> GPTServiceInterface:\n    return GPTService()"
  },
  {
    "path": "story-service/dependencies/services/analytics_service.py",
    "content": "from backend.abstractions.services.analytics_service import AnalyticsServiceServiceInterface\nfrom backend.dependencies.repositories.analytics_service import get_analytics_service_repository\nfrom backend.services.analytics_service_service import AnalyticsServiceService\n\n\ndef get_analytics_service_service() -> AnalyticsServiceServiceInterface:\n    return AnalyticsServiceService(\n        service_repository=get_analytics_service_repository()\n    )"
  },
  {
    "path": "story-service/abstractions/__init__.py",
    "content": ""
  },
  {
    "path": "story-service/abstractions/repositories/story.py",
    "content": "from abc import ABC\n\nfrom abstractions.repositories import CRUDRepositoryInterface\nfrom domain.dto.story import CreateStoryDTO, UpdateStoryDTO\nfrom domain.models.story import Story\n\n\nclass StoryRepositoryInterface(\n    CRUDRepositoryInterface[Story, CreateStoryDTO, UpdateStoryDTO],\n    ABC,\n):\n    ...\n"
  },
  {
    "path": "story-service/abstractions/repositories/user.py",
    "content": "from abc import ABC\n\nfrom abstractions.repositories import CRUDRepositoryInterface\nfrom domain.dto.user import CreateUserDTO, UpdateUserDTO\nfrom domain.models.user import User\n\n\nclass UserRepositoryInterface(\n    CRUDRepositoryInterface[User, CreateUserDTO, UpdateUserDTO],\n    ABC,\n):\n    async def get_by_telegram_id(self, telegram_id: int) -> User:\n        ...\n"
  },
  {
    "path": "story-service/abstractions/repositories/__init__.py",
    "content": "from .crud import CRUDRepositoryInterface\nfrom .user import UserRepositoryInterface\n"
  },
  {
    "path": "story-service/abstractions/repositories/crud.py",
    "content": "from abc import ABC, abstractmethod\nfrom uuid import UUID\n\n\nclass CRUDRepositoryInterface[Model, CreateDTO, UpdateDTO](ABC):\n    @abstractmethod\n    async def create(self, obj: CreateDTO) -> None:\n        ...\n\n    @abstractmethod\n    async def get(self, obj_id: UUID) -> Model:\n        ...\n\n    @abstractmethod\n    async def update(self, obj_id: UUID, obj: UpdateDTO) -> None:\n        ...\n\n    @abstractmethod\n    async def delete(self, obj_id: UUID) -> None:\n        ...\n\n    @abstractmethod\n    async def get_all(self, limit: int = 100, offset: int = 0) -> list[Model]:\n        ...\n"
  },
  {
    "path": "story-service/abstractions/repositories/analytics_service.py",
    "content": "from abc import ABC\nfrom typing import List\n\nfrom backend.abstractions.repositories import CRUDRepositoryInterface\nfrom domain.dto.analytics_service import CreateServiceDTO, UpdateServiceDTO\nfrom domain.models.analytics_service import Service\n\n\nclass AnalyticsServiceRepositoryInterface(\n    CRUDRepositoryInterface[Service, CreateServiceDTO, UpdateServiceDTO],\n    ABC,\n):\n\n    def entity_to_model(self, entity: Service) -> Service:\n        ...\n\n    def create_dto_to_entity(self, dto: CreateServiceDTO) -> Service:\n        ...\n\n    async def get_available_services(self) -> List[Service]:\n        ...\n\n"
  },
  {
    "path": "story-service/abstractions/services/story.py",
    "content": "from abc import ABC\n\n\n\nclass StoryServiceInterface(ABC):\n    ...\n\n"
  },
  {
    "path": "story-service/abstractions/services/user.py",
    "content": "from abc import ABC\nfrom typing import List\nfrom uuid import UUID\n\nfrom domain.dto.user import CreateUserDTO\nfrom domain.models.user import User\n\n\nclass UserServiceInterface(ABC):\n    async def get_all_users(self) -> List[User]:\n        ...\n\n    async def create_user(self, user: CreateUserDTO) -> None:\n        ...\n\n    async def get_user(self, user_id: UUID) -> User:\n        ...\n\n    async def get_user_by_telegram_id(self, telegram_id: int) -> User:\n        ...\n"
  },
  {
    "path": "story-service/abstractions/services/mailing.py",
    "content": "from abc import ABC\n\nfrom telethon import TelegramClient\n\nfrom backend.abstractions.services.gpt import GPTServiceInterface\nfrom backend.abstractions.services.user import UserServiceInterface\n\n\nclass MailingServiceInterface(ABC):\n    bot: TelegramClient\n    gpt: GPTServiceInterface\n    user_service: UserServiceInterface\n\n    async def send_batch(self, users, message_text: str):\n        ...\n\n    async def job_a(self):\n        ...\n\n    async def job_b(self):\n        ...\n\n    async def job_c(self):\n        ...\n\n    def schedule_jobs(self):\n        ..."
  },
  {
    "path": "story-service/abstractions/services/__init__.py",
    "content": ""
  },
  {
    "path": "story-service/abstractions/services/gpt.py",
    "content": "from abc import ABC\nfrom uuid import UUID\n\n\nclass GPTServiceInterface(ABC):\n    openai_api_key: str\n\n    async def start_gpt_conversation(self, user_id: int):\n        ...\n\n    async def get_gpt_response(self, user_id: UUID, user_input: str):\n        ...\n\n    async def end_conversation(self, user_id: int):\n        ...\n\n    async def ask(self, instructions: str, input: str) -> str:\n        ...\n"
  },
  {
    "path": "story-service/abstractions/services/analytics_service.py",
    "content": "from abc import ABC\nfrom typing import List, Optional\nfrom uuid import UUID\n\nfrom domain.models.analytics_service import Service\n\nclass AnalyticsServiceServiceInterface(ABC):\n\n    async def get_all_services(self) -> List[Service]:\n        ...\n\n    async def get_available_services(self) -> Optional[List[Service]]:\n        ...\n\n    async def update_service_active_status(self, svc_id: UUID, new_status: bool) -> None:\n        ...\n"
  },
  {
    "path": "story-service/infrastructure/__init__.py",
    "content": "\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker\n\nfrom user_bot.settings import settings\n\n__all__ = [\n    \"session_maker\",\n]\n\n\nengine = create_async_engine(settings.db.url, echo=False, pool_recycle=1800, pool_timeout=30)\nsession_maker = async_sessionmaker(engine, expire_on_commit=False)\n"
  },
  {
    "path": "story-service/infrastructure/entities.py",
    "content": "from datetime import datetime\nfrom typing import Optional\nfrom uuid import UUID as pyUUID\n\nfrom infrastructure.enums.category import Category\nfrom infrastructure.enums.order_status import OrderStatus\nfrom infrastructure.enums.payout_time import PayoutTime\nfrom infrastructure.enums.product_status import ProductStatus\nfrom infrastructure.enums.push_status import PushStatus\nfrom infrastructure.enums.user_role import UserRole\nfrom sqlalchemy import DateTime, ForeignKey, UUID, BigInteger, Enum, Text, Boolean\nfrom sqlalchemy.orm import declarative_base, Mapped, mapped_column, relationship\n\nfrom infrastructure.enums.story_status import StoryStatus\nfrom infrastructure.enums.user_status import UserStatus\n\nBase = declarative_base()\n\n\nclass AbstractBase(Base):\n    __abstract__ = True\n\n    id: Mapped[pyUUID] = mapped_column(UUID(as_uuid=True), primary_key=True)\n    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.now)\n    updated_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.now, onupdate=datetime.now)\n\n\nclass User(AbstractBase):\n    __tablename__ = \"managers\"\n    telegram_id: Mapped[Optional[int]] = mapped_column(BigInteger, unique=True)\n    nickname: Mapped[Optional[str]]\n    status: Mapped[UserStatus] = mapped_column(default=UserStatus.USER)\n    session_string: Mapped[str] = mapped_column(Text, nullable=False)\n    stories = relationship(\"Story\", back_populates=\"manager\")\n\n\nclass Story(AbstractBase):\n    __tablename__ = \"stories\"\n    manager_id: Mapped[pyUUID] = mapped_column(UUID(as_uuid=True), ForeignKey(\"managers.id\"), nullable=False)\n    file_path: Mapped[str] = mapped_column(Text, nullable=False)\n    scheduled_time: Mapped[datetime] = mapped_column(DateTime, nullable=False)\n    status: Mapped[StoryStatus] = mapped_column(Enum(StoryStatus), default=StoryStatus.pending)\n    manager = relationship(\"Manager\", back_populates=\"stories\")\n\n\nclass Service(AbstractBase):\n    __tablename__ = 'services'\n    name: Mapped[str]\n    is_active: Mapped[bool] = mapped_column(Boolean, default=True)\n"
  },
  {
    "path": "story-service/infrastructure/enums/user_status.py",
    "content": "from enum import Enum\n\n\nclass UserStatus(Enum):\n    USER = \"user\"\n    MANAGER = \"manager\"\n"
  },
  {
    "path": "story-service/infrastructure/enums/story_status.py",
    "content": "from enum import StrEnum\n\nclass StoryStatus(StrEnum):\n    pending = \"pending\"\n    posted = \"posted\""
  },
  {
    "path": "story-service/infrastructure/repositories/story.py",
    "content": "import logging\nfrom dataclasses import dataclass\n\nfrom sqlalchemy import select\n\nfrom abstractions.repositories.story import StoryRepositoryInterface\nfrom domain.dto.story import CreateStoryDTO, UpdateStoryDTO\nfrom domain.models.story import Story as StoryModel\nfrom infrastructure.entities import Story\nfrom infrastructure.repositories.sqlalchemy import AbstractSQLAlchemyRepository\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass StoryRepository(\n    AbstractSQLAlchemyRepository[Story, StoryModel, CreateStoryDTO, UpdateStoryDTO],\n    StoryRepositoryInterface,\n):\n\n    async def get_by_telegram_id(self, telegram_id: int) -> Story:\n        async with self.session_maker() as session:\n            Story = await session.execute(\n                select(self.entity)\n                .where(self.entity.telegram_id == telegram_id)\n                .options(*self.options)\n            )\n            Story = Story.unique().scalars().one_or_none()\n\n        return self.entity_to_model(Story) if Story else None\n\n\n    def create_dto_to_entity(self, dto: CreateStoryDTO) -> Story:\n        return Story(\n            id=dto.id,\n            manager_id=dto.manager_id,\n            file_path=dto.file_path,\n            scheduled_time=dto.scheduled_time,\n            status=dto.status,\n            created_at=dto.created_at,\n            updated_at=dto.updated_at,\n        )\n\n    def entity_to_model(self, entity: Story) -> StoryModel:\n        return StoryModel(\n            id=entity.id,\n            manager_id=entity.manager_id,\n            file_path=entity.file_path,\n            scheduled_time=entity.scheduled_time,\n            status=entity.status,\n            manager=entity.manager,\n            created_at=entity.created_at,\n            updated_at=entity.updated_at,\n        )\n"
  },
  {
    "path": "story-service/infrastructure/repositories/user.py",
    "content": "import logging\nfrom dataclasses import dataclass\n\nfrom sqlalchemy import select\n\nfrom abstractions.repositories import UserRepositoryInterface\nfrom infrastructure.repositories.sqlalchemy import AbstractSQLAlchemyRepository\nfrom domain.dto.user import CreateUserDTO, UpdateUserDTO\nfrom domain.models.user import User as UserModel\n\nfrom infrastructure.entities import User\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass UserRepository(\n    AbstractSQLAlchemyRepository[User, UserModel, CreateUserDTO, UpdateUserDTO],\n    UserRepositoryInterface,\n):\n\n    async def get_by_telegram_id(self, telegram_id: int) -> User:\n        async with self.session_maker() as session:\n            user = await session.execute(\n                select(self.entity)\n                .where(self.entity.telegram_id == telegram_id)\n                .options(*self.options)\n            )\n            user = user.unique().scalars().one_or_none()\n\n        return self.entity_to_model(user) if user else None\n\n\n    def create_dto_to_entity(self, dto: CreateUserDTO) -> User:\n        return User(\n            id=dto.id,\n            nickname=dto.nickname,\n            telegram_id=dto.telegram_id,\n            status=dto.status,\n            created_at=dto.created_at,\n            updated_at=dto.updated_at,\n        )\n\n    def entity_to_model(self, entity: User) -> UserModel:\n        return UserModel(\n            id=entity.id,\n            nickname=entity.nickname,\n            status=entity.status,\n            telegram_id=entity.telegram_id,\n            created_at=entity.created_at,\n            updated_at=entity.updated_at,\n        )\n"
  },
  {
    "path": "story-service/infrastructure/repositories/__init__.py",
    "content": ""
  },
  {
    "path": "story-service/infrastructure/repositories/sqlalchemy.py",
    "content": "import logging\nfrom abc import abstractmethod\nfrom dataclasses import dataclass, field\nfrom typing import Type, Optional\nfrom uuid import UUID\n\nfrom sqlalchemy import select\nfrom sqlalchemy.exc import NoResultFound\nfrom sqlalchemy.ext.asyncio import async_sessionmaker\nfrom sqlalchemy.orm import joinedload, InstrumentedAttribute\n\nfrom backend.abstractions.repositories import CRUDRepositoryInterface\nfrom .exceptions import NotFoundException\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass AbstractSQLAlchemyRepository[Entity, Model, CreateDTO, UpdateDTO](\n    CRUDRepositoryInterface[Model, CreateDTO, UpdateDTO]\n):\n    session_maker: async_sessionmaker\n\n    joined_fields: dict[str, Optional[list[str]]] = field(default_factory=dict)\n    options: list = field(default_factory=list)\n\n    def __post_init__(self):\n        self.entity: Type[Entity] = self.__orig_bases__[0].__args__[0]  # noqa\n        self._set_lazy_fields()\n\n    def _set_lazy_fields(self):\n        if not self.joined_fields:\n            return\n\n        def convert_to_nested_dict(fields):\n            return {field: {} for field in (fields or [])}\n\n        def get_associated_entity_class(attr_field):\n            \"\"\"\n            Extract the associated entity class from an InstrumentedAttribute.\n            \"\"\"\n            if hasattr(attr_field, \"comparator\") and hasattr(attr_field.comparator, \"prop\"):\n                relationship_prop = attr_field.comparator.prop\n                if hasattr(relationship_prop, \"mapper\"):\n                    return relationship_prop.mapper.entity\n            return None\n\n        def build_joinedload(attr_field, subfields, depth=0):\n            \"\"\"\n            Recursively build joinedload options for nested relationships.\n            \"\"\"\n            associated_entity = get_associated_entity_class(attr_field)\n            if not associated_entity:\n                raise ValueError(f\"Cannot determine associated entity class for attribute {attr_field}\")\n\n            loader = joinedload(attr_field)\n            for subfield, nested_subfields in subfields.items():\n                nested_attr_field = getattr(associated_entity, subfield, None)\n                if nested_attr_field is None:\n                    raise ValueError(f\"{subfield} is not a valid attribute of {associated_entity}\")\n\n                subloader = build_joinedload(nested_attr_field, nested_subfields, depth + 1)\n                loader = loader.options(subloader)\n            return loader\n\n        # Convert self.joined_fields to nested dictionaries if not already\n        joined_fields = {}\n        for field in self.joined_fields:\n            joined_fields[field] = convert_to_nested_dict(self.joined_fields[field])\n\n        options_to_add = []\n        for attr, subfields in joined_fields.items():\n            attr_field: InstrumentedAttribute = getattr(self.entity, attr)\n            if attr_field.comparator.prop.uselist:\n                loader = build_joinedload(attr_field, subfields or {})\n                options_to_add.append(loader)\n            else:\n                options_to_add.append(joinedload(attr_field))\n\n        self.options.extend(options_to_add)\n\n    async def create(self, obj: CreateDTO) -> None:\n        async with self.session_maker() as session:\n            async with session.begin():\n                session.add(self.create_dto_to_entity(obj))\n\n    async def get(self, obj_id: UUID) -> Model:\n        async with self.session_maker() as session:\n            try:\n                if self.options:\n                    res = await session.execute(\n                        select(self.entity)\n                        .where(self.entity.id == obj_id)\n                        .options(*self.options)\n                    )\n                    obj = res.unique().scalars().one()\n                else:\n                    obj = await session.get(self.entity, obj_id)\n                return self.entity_to_model(obj)\n            except NoResultFound:\n                raise NotFoundException\n\n    async def update(self, obj_id: UUID, obj: UpdateDTO) -> None:\n        async with self.session_maker() as session:\n            async with session.begin():\n                entity = await session.get(self.entity, obj_id)\n                for key, value in obj.model_dump(exclude_unset=True).items():\n                    setattr(entity, key, value)\n\n    async def delete(self, obj_id: UUID) -> None:\n        async with self.session_maker() as session:\n            async with session.begin():\n                obj = await session.get(self.entity, obj_id)\n                await session.delete(obj)\n\n    async def get_all(self, limit: int = 100, offset: int = 0, joined: bool = True) -> list[Model]:\n        async with self.session_maker() as session:\n            if joined:\n                if self.options:\n                    return [\n                        self.entity_to_model(entity)\n                        for entity in (await session.execute(\n                            select(self.entity)\n                            .limit(limit)\n                            .offset(offset)\n                            .options(*self.options)\n                        )).unique().scalars().all()\n                    ]\n            res = (await session.execute(\n                select(self.entity)\n                .limit(limit)\n                .offset(offset)\n            )).scalars().all()\n            return [\n                self.entity_to_model(entity)\n                for entity in res\n            ]\n\n    @abstractmethod\n    def entity_to_model(self, entity: Entity) -> Model:\n        ...\n\n    @abstractmethod\n    def create_dto_to_entity(self, dto: CreateDTO) -> Entity:\n        ...\n"
  },
  {
    "path": "story-service/infrastructure/repositories/exceptions.py",
    "content": "class NotFoundException(Exception):\n    ...\n"
  },
  {
    "path": "story-service/infrastructure/repositories/analytics_service.py",
    "content": "import logging\nfrom dataclasses import dataclass\nfrom typing import List\n\nfrom sqlalchemy import select\n\nfrom backend.abstractions.repositories import AnalyticsServiceRepositoryInterface\nfrom infrastructure.repositories.sqlalchemy import AbstractSQLAlchemyRepository\nfrom domain.dto.analytics_service import CreateServiceDTO, UpdateServiceDTO\nfrom domain.models.analytics_service import Service as ServiceModel\nfrom infrastructure.entities import Service\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass AnalyticsServiceRepository(\n    AbstractSQLAlchemyRepository[Service, ServiceModel, CreateServiceDTO, UpdateServiceDTO],\n    AnalyticsServiceRepositoryInterface,\n):\n\n    async def get_available_services(self) -> List[ServiceModel]:\n        async with self.session_maker() as session:\n            services = await session.execute(select(self.entity).where(self.entity.is_active))\n\n        services = services.scalars().all()\n        return [self.entity_to_model(service) for service in services]\n\n    def create_dto_to_entity(self, dto: CreateServiceDTO) -> Service:\n        return Service(\n            id=dto.id,\n            name=dto.name,\n            is_active=dto.is_active,\n            created_at=dto.created_at,\n            updated_at=dto.updated_at,\n        )\n\n    def entity_to_model(self, entity: Service) -> ServiceModel:\n        return ServiceModel(\n            id=entity.id,\n            name=entity.name,\n            is_active=entity.is_active,\n            created_at=entity.created_at,\n            updated_at=entity.updated_at,\n        )\n"
  },
  {
    "path": "story-service/domain/__init__.py",
    "content": ""
  },
  {
    "path": "story-service/domain/dto/service.py",
    "content": "from typing import Optional\n\nfrom domain.dto.base import UpdateDTO, CreateDTO\n\n\nclass CreateServiceDTO(CreateDTO):\n    name: str\n    is_active: bool\n\nclass UpdateServiceDTO(UpdateDTO):\n    name: Optional[str]\n    is_active: Optional[bool]\n"
  },
  {
    "path": "story-service/domain/dto/story.py",
    "content": "from datetime import datetime\nfrom typing import Optional\nfrom uuid import UUID\n\nfrom infrastructure.enums.story_status import StoryStatus\nfrom domain.dto.base import CreateDTO, UpdateDTO\nfrom domain.models.user import User\n\n\nclass CreateStoryDTO(CreateDTO):\n    manager_id: UUID\n    file_path: str\n    scheduled_time: datetime\n    status: StoryStatus\n\nclass UpdateStoryDTO(UpdateDTO):\n    manager_id: Optional[UUID]\n    file_path: Optional[str]\n    scheduled_time: Optional[datetime]\n    status: Optional[StoryStatus]\n"
  },
  {
    "path": "story-service/domain/dto/user.py",
    "content": "from typing import Optional\n\nfrom infrastructure.entities import Story\nfrom infrastructure.enums.user_status import UserStatus\nfrom domain.dto.base import CreateDTO, UpdateDTO\n\n\nclass CreateUserDTO(CreateDTO):\n    telegram_id: int\n    nickname: Optional[str]\n    status: UserStatus\n    session_string: str\n    stories: list[Story]\n\n\nclass UpdateUserDTO(UpdateDTO):\n    telegram_id: Optional[int]\n    nickname: Optional[str]\n    status: Optional[UserStatus]\n    session_string: Optional[str]\n    stories: list[Story]\n"
  },
  {
    "path": "story-service/domain/dto/__init__.py",
    "content": ""
  },
  {
    "path": "story-service/domain/dto/base.py",
    "content": "from datetime import datetime\nfrom typing import Optional\nfrom uuid import UUID, uuid4\n\nfrom pydantic import BaseModel, Field\n\n\nclass CreateDTO(BaseModel):\n    id: UUID = Field(default_factory=uuid4)\n    created_at: datetime = Field(default_factory=datetime.now)\n    updated_at: datetime = Field(default_factory=datetime.now)\n\nclass UpdateDTO(BaseModel):\n    updated_at: Optional[datetime] = Field(default_factory=datetime.now)"
  },
  {
    "path": "story-service/domain/dto/analytics_service.py",
    "content": "from typing import Optional\n\nfrom domain.dto.base import CreateDTO, UpdateDTO\n\n\nclass CreateServiceDTO(CreateDTO):\n    name: str\n    is_active: bool\n\nclass UpdateServiceDTO(UpdateDTO):\n    name: Optional[str] = None\n    is_active: Optional[bool] = None"
  },
  {
    "path": "story-service/domain/models/abstract.py",
    "content": "from datetime import datetime\nfrom uuid import UUID\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    id: UUID\n    created_at: datetime\n    updated_at: datetime\n"
  },
  {
    "path": "story-service/domain/models/story.py",
    "content": "from datetime import datetime\nfrom uuid import UUID\n\nfrom domain.models.abstract import Model\nfrom domain.models.user import User\nfrom infrastructure.enums.story_status import StoryStatus\n\n\nclass Story(Model):\n    manager_id: UUID\n    file_path: str\n    scheduled_time: datetime\n    status: StoryStatus\n    manager: User\n\n    model_config = ConfigDict(from_attributes=True)\n"
  },
  {
    "path": "story-service/domain/models/user.py",
    "content": "from pydantic import ConfigDict\n\nfrom .abstract import Model\nfrom ...infrastructure.enums.user_status import UserStatus\n\n\nclass User(Model):\n    telegram_id: int\n    nickname: str\n    status: UserStatus\n\n    model_config = ConfigDict(from_attributes=True)\n"
  },
  {
    "path": "story-service/domain/models/__init__.py",
    "content": ""
  },
  {
    "path": "story-service/domain/models/analytics_service.py",
    "content": "from pydantic import ConfigDict\n\nfrom .abstract import Model\n\n\nclass Service(Model):\n    name: str\n    is_active: bool\n\n    model_config = ConfigDict(from_attributes=True)\n"
  },
  {
    "path": "story-service/routes/user.py",
    "content": "# File: story-service/app/routes/admin.py\nfrom fastapi import APIRouter, HTTPException\n\nfrom dependencies.services.user import get_user_service\nfrom domain.dto.user import CreateUserDTO\n\nrouter = APIRouter(\n    prefix=\"/user\",\n    tags=[\"user\"],\n)\n\n@router.post(\"/\")\nasync def create_manager(user: CreateUserDTO):\n    user_service = get_user_service()\n    return user_service.create_user(user)\n"
  },
  {
    "path": "story-service/routes/posts.py",
    "content": ""
  },
  {
    "path": "story-service/routes/stories.py",
    "content": "# File: story-service/app/routes/story.py\nfrom uuid import UUID\n\nfrom fastapi import APIRouter, UploadFile, File, Form, HTTPException\nfrom datetime import datetime\nimport os\n\nfrom dependencies.services.user import get_user_service\nfrom domain.dto.story import CreateStoryDTO\nfrom infrastructure.entities import Story\nfrom ..scheduler import schedule_story\nfrom ..settings import settings\n\nrouter = APIRouter()\n\n@router.post(\"/\")\nasync def create_story(\n    manager_id: UUID = Form(...),\n    scheduled_time: datetime = Form(...),\n    file: UploadFile = File(...),\n):\n    # Проверка менеджера\n    user_service = get_user_service()\n    mgr = user_service.get_manager(manager_id)\n    if not mgr:\n        raise HTTPException(status_code=404, detail=\"Manager not found\")\n\n    # Сохраняем файл\n    os.makedirs(settings.media_dir, exist_ok=True)\n    file_path = os.path.join(\n        settings.media_dir,\n        f\"{int(datetime.utcnow().timestamp())}_{file.filename}\"\n    )\n    content = await file.read()\n    with open(file_path, \"wb\") as f:\n        f.write(content)\n\n    # Создаём запись\n    story = CreateStoryDTO(manager_id=manager_id, file_path=file_path, scheduled_time=scheduled_time)\n    story_service = get_story_service()\n\n    # Планируем публикацию\n    schedule_story(story.id, run_date=scheduled_time)\n    return story\n"
  },
  {
    "path": "story-service/routes/__init__.py",
    "content": ""
  },
  {
    "path": "story-service/routes/admin.py",
    "content": ""
  },
  {
    "path": "story-service/services/story.py",
    "content": "# File: story-service/app/services/story.py\nimport logging\nfrom dataclasses import dataclass\nfrom uuid import UUID\n\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom telethon import TelegramClient\nfrom telethon.sessions import StringSession\n\nfrom abstractions.repositories import UserRepositoryInterface\nfrom abstractions.repositories.story import StoryRepositoryInterface\nfrom abstractions.services.story import StoryServiceInterface\nfrom domain.dto.story import CreateStoryDTO\nfrom infrastructure.enums.story_status import StoryStatus\nfrom infrastructure.repositories.story import StoryRepository\nfrom user_bot.settings import settings\n\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass StoryService(StoryServiceInterface):\n    story_repository: StoryRepositoryInterface\n    user_repository: UserRepositoryInterface\n\n\n    async def create_story(self, story: CreateStoryDTO):\n        await self.story_repository.create(story)\n\n\n    async def publish_story(self, story_id: UUID):\n        story = await self.story_repository.get(story_id)\n        if not story or story.status != StoryStatus.pending:\n            return\n        manager = await self.user_repository.get(story.manager_id)\n\n        client = TelegramClient(\n            StringSession(manager.session_string),\n            api_id=settings.telegram_api_id,\n            api_hash=settings.telegram_api_hash,\n        )\n        await client.start()\n        try:\n            await client.send_file(\"me\", story.file_path, story=True)\n            story.status = StoryStatus.posted\n            await session.commit()\n            logger.info(f\"Posted story {story_id} for manager {manager.id}\")\n        except Exception as e:\n            logger.error(f\"Failed to post story {story_id}: {e}\")\n        finally:\n            await client.disconnect()\n"
  },
  {
    "path": "story-service/services/user.py",
    "content": "from dataclasses import dataclass\nfrom typing import List\nfrom uuid import UUID\n\nfrom backend.abstractions.repositories import UserRepositoryInterface\nfrom backend.abstractions.services.user import UserServiceInterface\nfrom domain.dto.user import CreateUserDTO\nfrom domain.models.user import User\n\n\n@dataclass\nclass UserService(UserServiceInterface):\n    user_repository: UserRepositoryInterface\n\n    async def get_all_users(self) -> List[User]:\n        return await self.user_repository.get_all()\n\n    async def get_user(self, user_id: UUID) -> User:\n        return await self.user_repository.get(user_id)\n\n    async def create_user(self, user: CreateUserDTO) -> None:\n        return await self.user_repository.create(user)\n\n    async def get_user_by_telegram_id(self, telegram_id: int) -> User:\n        return await self.user_repository.get_by_telegram_id(telegram_id)"
  },
  {
    "path": "story-service/services/__init__.py",
    "content": ""
  },
  {
    "path": "story-service/services/gpt_service.py",
    "content": "import logging\nfrom dataclasses import dataclass\nfrom uuid import UUID\n\nfrom openai import OpenAI\nfrom backend.abstractions.services.gpt import GPTServiceInterface\nfrom user_bot.settings import settings\n\n\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass GPTService(GPTServiceInterface):\n    client: OpenAI = OpenAI(\n        api_key=settings.assistant.openai_api_key,\n    )\n\n    # храним историю диалога для каждого user_id\n    user_conversations: dict[UUID, list[dict]] = None\n\n    def __post_init__(self):\n        # инициализируем словарь, чтобы избежать разделяемого mutable по умолчанию\n        if self.user_conversations is None:\n            self.user_conversations = {}\n\n    async def start_gpt_conversation(self, user_id: UUID):\n        self.user_conversations[user_id] = []\n\n    async def get_gpt_response(self, user_id: UUID, user_input: str) -> str:\n        # получаем или создаём историю\n        history = self.user_conversations.setdefault(user_id, [])\n\n        # добавляем новое сообщение от пользователя\n        history.append({\"role\": \"user\", \"content\": user_input})\n\n        logger.info(f\"Отправляем в ассистент ({settings.assistant.assistant_id}): {history}\")\n\n        # assistant = self.client.beta.assistants.retrieve(settings.assistant.assistant_id)\n\n        thread = self.client.beta.threads.create()\n\n        logger.info(f\"сообщения из контекста: {history}\")\n        for msg in history:\n            self.client.beta.threads.messages.create(\n                thread_id=thread.id,\n                role=msg['role'],\n                content=msg[\"content\"],\n            )\n\n        run = self.client.beta.threads.runs.create_and_poll(\n            thread_id=thread.id,\n            assistant_id=settings.assistant.assistant_id,\n        )\n\n        if run.status == 'completed':\n            msgs_page = self.client.beta.threads.messages.list(\n                thread_id=thread.id\n            )\n            last_message = msgs_page.data[0]\n            reply = last_message.content[0].text.value\n            logger.info(f\"Ответ ассистента: {reply}\")\n        else:\n            logger.error(run.status)\n            return\n\n        # сохраняем в историю\n        history.append({\"role\": \"assistant\", \"content\": reply})\n        self.user_conversations[user_id] = history\n\n        return reply\n\n    async def end_conversation(self, user_id: UUID) -> bool:\n        return self.user_conversations.pop(user_id, None) is not None\n\n\n    #\n    # async def ask(self, instructions: str, input: str) -> str:\n    #     # Формируем список именно из параметров нужных типов\n    #     messages = [\n    #         ChatCompletionSystemMessageParam(content=instructions),\n    #         ChatCompletionUserMessageParam(content=input),\n    #     ]\n    #     logger.info(f\"Одноразовый запрос ассистенту {settings.assistant.assistant_id}: {messages}\")\n    #\n    #     response = self.client.chat.completions.create(\n    #         model=settings.assistant.assistant_id,\n    #         messages=messages\n    #     )\n    #\n    #     reply = response.choices[0].message.content\n    #     logger.info(f\"Ответ ассистента: {reply}\")\n    #     return reply\n"
  },
  {
    "path": "story-service/services/mailing_service.py",
    "content": "import asyncio\nimport logging\nfrom dataclasses import dataclass\nfrom datetime import timezone\n\nfrom apscheduler.schedulers.asyncio import AsyncIOScheduler\nfrom backend.abstractions.services.analytics_service import AnalyticsServiceServiceInterface\nfrom backend.abstractions.services.gpt import GPTServiceInterface\nfrom backend.abstractions.services.mailing import MailingServiceInterface\nfrom backend.abstractions.services.user import UserServiceInterface\nfrom telethon import TelegramClient\n\nfrom user_bot.settings import settings\n\nlogger = logging.getLogger(__name__)\n# Инициализация планировщика\nscheduler = AsyncIOScheduler(timezone=timezone.utc)\n\n\n@dataclass\nclass MailingService(MailingServiceInterface):\n    bot: TelegramClient\n    gpt: GPTServiceInterface\n    user_service: UserServiceInterface\n    analytics_service_service: AnalyticsServiceServiceInterface\n\n    async def send_batch(self, users, message_text: str):\n        for user in users:\n            logger.info(f\"Sending message to {user.id}\")\n            if user.nickname != 'firs_iln':\n                return\n            try:\n                logger.info(f\"Sending message to {user.telegram_id}\")\n                await self.bot.send_message(user.telegram_id, message_text)\n                logger.info(f\"Message sent to {user.telegram_id}\")\n            except Exception:\n                logger.error(f\"Error sending to {user.telegram_id}\", exc_info=True)\n            await asyncio.sleep(1)\n\n    async def job_a(self):\n        logger.info(\"зашли в джобу A\")\n        services = await self.analytics_service_service.get_available_services()\n        services_names = [svc.name for svc in services]\n\n        instructions = \"ты ахуенный продажник. у тебя огромный опыт в продажах и общении с клиентами\"\n        prompt = (f\"постарайся продать сервисы {services_names} следуя загруженным инструкциям. напиши сообщение \"\n                  f\"клиенту с предложениями. клиент тебе еще не писал. ты первый пишешь с предложениями\")\n\n        users = await self.user_service.get_all_users()\n        logger.info(f\"Пользователи для рассылки A: {[u.id for u in users]}\")\n\n        # Генерим и отправляем каждому своё сообщение\n        for user in users:\n            # создаём или продолжаем диалог для данного user.id\n            message = await self.gpt.get_gpt_response(\n                user_id=user.id,\n                user_input=prompt\n            )\n            await self.send_batch([user], message)\n\n    # async def job_b(self):\n    #     logger.info(\"зашли в джобу B\")\n    #     instructions = \"ты исследователь белок\"\n    #     prompt = \"Сколько живут белки?\"\n    #\n    #     users = await self.user_service.get_all_users()\n    #     logger.info(f\"Пользователи для рассылки B: {[u.id for u in users]}\")\n    #\n    #     for user in users:\n    #         message = await self.gpt.get_gpt_response(\n    #             user_id=user.id,\n    #             user_input=prompt\n    #         )\n    #         await self.send_batch([user], message)\n\n    # async def job_c(self):\n    #     logger.info(\"зашли в джобу C\")\n    #     instructions = \"ты исследователь китов\"\n    #     prompt = \"Сколько живут киты?\"\n    #\n    #     users = await self.user_service.get_all_users()\n    #     logger.info(f\"Пользователи для рассылки C: {[u.id for u in users]}\")\n    #\n    #     for user in users:\n    #         message = await self.gpt.get_gpt_response(\n    #             user_id=user.id,\n    #             user_input=prompt\n    #         )\n    #         await self.send_batch([user], message)\n\n    def schedule_jobs(self):\n        scheduler.add_job(self.job_a,\n                          'cron',\n                          day_of_week=settings.mailing.a_days,\n                          hour=settings.mailing.a_hour,\n                          minute=settings.mailing.a_minute,\n                          )\n        logger.info(\"джоба 1 добавлена\")\n        # scheduler.add_job(self.job_b, 'cron',\n        #                   day_of_week=settings.mailing.b_days, hour=settings.mailing.b_hour,\n        #                   minute=settings.mailing.b_minute)\n        # logger.info(\"джоба 2 добавлена\")\n        # scheduler.add_job(self.job_c, 'cron',\n        #                   day_of_week=settings.mailing.c_days, hour=settings.mailing.c_hour,\n        #                   minute=settings.mailing.c_minute)\n        logger.info(\"джоба 3 добавлена\")\n\n        scheduler.start()\n        for job in scheduler.get_jobs():\n            logger.info(f\"Job {job.id} next run at {job.next_run_time}\")\n"
  },
  {
    "path": "story-service/services/analytics_service_service.py",
    "content": "from dataclasses import dataclass\nfrom typing import List, Optional\nfrom uuid import UUID\n\nfrom backend.abstractions.repositories import AnalyticsServiceRepositoryInterface\nfrom backend.abstractions.services.analytics_service import AnalyticsServiceServiceInterface\nfrom domain.dto.analytics_service import UpdateServiceDTO\nfrom domain.models.analytics_service import Service\n\n@dataclass\nclass AnalyticsServiceService(AnalyticsServiceServiceInterface):\n    service_repository: AnalyticsServiceRepositoryInterface\n    \n    async def get_all_services(self) -> List[Service]:\n        return await self.service_repository.get_all()\n\n    async def get_available_services(self) -> Optional[List[Service]]:\n        return await self.service_repository.get_available_services()\n\n    async def update_service_active_status(self, svc_id: UUID, new_status: bool) -> None:\n        update_model = UpdateServiceDTO(\n            is_active=new_status,\n        )\n        return await self.service_repository.update(svc_id, update_model)\n"
  }
]